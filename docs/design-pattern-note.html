<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-design-pattern-note">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Design Pattern 笔记 | Xiaoyureed&#x27;s 网络 Wiki </title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://xiaoyureed.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://xiaoyureed.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://xiaoyureed.github.io/docs/design-pattern-note"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Design Pattern 笔记 | Xiaoyureed&#x27;s 网络 Wiki "><meta data-rh="true" name="description" content="https://github.com/xiaoyureed/design-patern-note"><meta data-rh="true" property="og:description" content="https://github.com/xiaoyureed/design-patern-note"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://xiaoyureed.github.io/docs/design-pattern-note"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/en/docs/design-pattern-note" hreflang="en"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/design-pattern-note" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/design-pattern-note" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Xiaoyureed&#39;s 网络 Wiki  RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Xiaoyureed&#39;s 网络 Wiki  Atom Feed"><link rel="stylesheet" href="/assets/css/styles.ca3abbab.css">
<link rel="preload" href="/assets/js/runtime~main.a7606eaf.js" as="script">
<link rel="preload" href="/assets/js/main.c0bf4a94.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Xiaoyureed</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/xiaoyureed" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="打开/收起侧边栏菜单「Tutorial - Basics」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="打开/收起侧边栏菜单「Tutorial - Extras」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/SpringBoot-note">Spring Boot 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/agile-development-user-story-scrum">敏捷开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/autohotkey">Autohotkey 脚本</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/chatgpt">Chatgpt Usage Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cpp">CPP and C 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cross-gfw">Cross The GFW</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cs-note">Computer Science Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/css-pre-processor">几种CSS预处理器比较选型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/data-structure-and-algorithm">Data Structure and Algorithm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/design-pattern-note">Design Pattern 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev-resources">开发者资源</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/distributed-system">Distributed System 分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/docker-note-virtual-dev-env">Docker Note &amp; Other Virtual Develop Environment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/effective-java-reading-note">Effective Java 阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/how-to-test-java-app">How to Test Java App</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/html-note">HTML 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/idea-note">InteliJ idea tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/interview-system-design">经典的系统设计思路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/java-code-clean">Java Clean Code Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/java-note">Java Core 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/linux-note">鸟哥的 Linux 私房菜阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/mybatis-note">MyBatis Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-audio-video">Audio and Video development Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-big-data-introduce">大数据开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-computational-ad">计算广告 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-crawler-spider">网络爬虫 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-desktop-develop">桌面应用开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-http">HTTP protocol Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-reactive-programming">响应式编程 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-rpc">RPC Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-rule-engine-note">规则引擎 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/quant-money">量化交易</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/saas-paas-iaas-as-a-service">SaaS Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/spring-note">Spring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/springmvc-note">Spring MVC</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Design Pattern 笔记</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Design Pattern 笔记</h1></header><div align="center">https://github.com/xiaoyureed/design-patern-note https://github.com/iluwatar/java-design-patterns<p><a href="https://www.zhihu.com/question/39972591" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/39972591</a></p></div><ul><li><a href="#1-%E5%AE%9E%E8%B7%B5-%E6%A1%88%E4%BE%8B">1. 实践 案例</a></li><li><a href="#2-uml-%E7%B1%BB%E5%9B%BE">2. uml 类图</a></li><li><a href="#3-%E7%A8%8B%E5%BA%8F-6-%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">3. 程序 6 大设计原则</a><ul><li><a href="#31-open-close-principle">3.1. open close principle</a></li><li><a href="#32-single-responsibility-principle">3.2. single responsibility principle</a></li><li><a href="#33-interface-separation-principle">3.3. interface separation principle</a></li><li><a href="#34-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">3.4. 里氏替换原则</a></li><li><a href="#35-dependence-inversion-principle">3.5. dependence inversion principle</a></li><li><a href="#36-least-knowledge-principle">3.6. Least Knowledge Principle</a></li></ul></li><li><a href="#4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A6%81">4. 设计模式概要</a><ul><li><a href="#41-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">4.1. 设计模式总结</a></li><li><a href="#42-spring-%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">4.2. spring 中的设计模式</a></li><li><a href="#43-%E4%B8%8D%E8%A6%81%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">4.3. 不要过度使用设计模式</a></li></ul></li><li><a href="#5-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">5. 工厂模式</a><ul><li><a href="#51-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">5.1. 工厂方法</a></li><li><a href="#52-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">5.2. 抽象工厂</a></li></ul></li><li><a href="#6-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F">6. 模板模式</a></li><li><a href="#7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">7. 策略模式</a></li><li><a href="#8-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">8. 观察者模式</a><ul><li><a href="#81-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89">8.1. 观察者模式定义</a></li><li><a href="#82-jdk-%E4%B8%AD%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">8.2. jdk 中的观察者模式</a><ul><li><a href="#821-jdk-%E4%B8%AD%E7%9A%84-api">8.2.1. jdk 中的 api</a></li><li><a href="#822-jdk-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">8.2.2. jdk 观察者模式使用示例</a></li></ul></li><li><a href="#83-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B">8.3. 事件驱动模型</a></li></ul></li><li><a href="#9-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">9. 代理模式</a><ul><li><a href="#91-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">9.1. 静态代理</a></li><li><a href="#92-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">9.2. 动态代理</a><ul><li><a href="#921-%E7%9C%8B%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">9.2.1. 看一个使用示例</a></li><li><a href="#922-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0">9.2.2. 自定义数据库连接池</a></li></ul></li></ul></li><li><a href="#10-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F">10. 装饰器模式</a></li><li><a href="#11-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">11. 适配器模式</a></li><li><a href="#12-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">12. 责任链模式</a></li><li><a href="#13-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">13. 单例模式</a></li><li><a href="#14-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">14. 命令模式</a></li><li><a href="#15-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F">15. 门面模式</a></li><li><a href="#16-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">16. 建造者模式</a></li><li><a href="#17-%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%A8%A1%E5%BC%8F">17. 流水线模式</a></li><li><a href="#18-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-state-machine">18. 状态模式 state machine</a></li></ul><h1>实践 案例</h1><p><a href="https://mp.weixin.qq.com/s/3wHFNFQPtj86AocLhUQahw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/3wHFNFQPtj86AocLhUQahw</a>
TODO</p><h1>uml 类图</h1><ul><li><p>三角空心箭头, 虚线 - 实现关系, 代码中为<code>继承抽象类or接口</code></p></li><li><p>三角空心箭头, 实线 - 泛化关系, 代码中为 <code>继承非抽象类</code></p></li><li><p>普通箭头, 虚线 - 依赖关系, 代码中为 <code>类方法中的传入参数</code></p></li></ul><h1>程序 6 大设计原则</h1><p>ref: &lt;&lt;设计模式之禅&gt;&gt;</p><ul><li><p>开放封闭原则（Open Close Principle,简称OCP） - 尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</p><p>  &quot;对新增开放, 对修改关闭&quot;</p><p>  即抽象出一个 interface, 新的功能只需要增加实现类即可, 使用的时候, 通过 interface 的 api 使用.</p></li></ul><ul><li><p>单一职责原则(Single Responsibility Principle，简称SRP )</p><p>  一个类的职责应该尽可能少, 尽可能拆分类为多个</p><p>  如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。</p></li><li><p>接口隔离原则（Interface Separation Principle,简称ISP）;</p><p>  尽量细化接口，接口中的方法尽量少. (这样实现类就无需实现不关心的方法)</p><p>  和单一职责原则类似, 只不过针对接口来说的. </p><p>  解决类似这种问题: 类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。</p></li><li><p>里氏替换原则（Liskov Substitution Principle,简称LSP）</p><p>  在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类</p><p>  也就是: 子类一般不会重写父类的方法, 尽量不要破坏继承体系</p><p>  需要多注意的是：有时候会为了灵活性牺牲这个原则</p></li><li><p>依赖倒置原则（Dependence Inversion Principle,简称DIP）</p><p>  即实现都是易变的，而只有抽象是稳定的，所以当依赖于抽象时，实现的变化并不会影响客户端的调用。</p><p>  也就是 &quot;面向接口编程&quot;</p></li><li><p>最少知识原则/迪米特法则 (Least Knowledge Principle, LKP)</p><ul><li><p>类间解耦: talk only to your immediate friends（只和直接的朋友交流）.</p><p>  出现在成员变量, 方法的输入输出参数中的类 就是直接的朋友。迪米特法则要求只和直接的朋友通信. 只出现在方法体内部的类就不是直接的朋友</p></li><li><p>暴露尽量少的方法给外界 (能 private 就不要 public).</p></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="open-close-principle">open close principle<a href="#open-close-principle" class="hash-link" aria-label="open close principle的直接链接" title="open close principle的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// bad demo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 信息发送类, 通过短信发送</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version: 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author: xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date: 2018年1月23日 下午10:27:28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MessageSend {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void send(String msg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Text Message send : &quot; + msg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 服务类, 供客户端调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version: 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author: xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date: 2018年1月23日 下午10:29:09</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MessageService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private MessageSend sender;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MessageService() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.sender = new MessageSend();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void send(String msg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sender.send(msg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 客户端调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version: 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author: xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date: 2018年1月23日 下午10:30:11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MessageClient {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MessageService messageService = new MessageService();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        messageService.send(&quot;Merry Christmas !&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 现在需要新支持另一种发送方式: 微信, 只好修改源码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 新增的信息发送帮助类, 支持email</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version: 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author: xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date: 2018年1月23日 下午10:37:55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class EmailMessageSend {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public  void send(String msg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Email Message send: &quot; + msg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 新增的信息发送类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version: 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author: xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date: 2018年1月23日 下午10:42:36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public enum SendType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 短信</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TEXT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 邮件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EMAIL </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 服务类, 供客户端调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月23日 下午10:53:18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MessageService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private MessageSend sender;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private SendType t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MessageService(SendType t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.t= t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void send(String msg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据不同的类型进行不同的处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 然后是client增加新的调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 后续如果又要支持新的发送方式, 又需要大改MessageService源码;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果遵循开闭原则设计, 会怎么样呢?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// good demo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 信息发送接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月23日 下午11:02:30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface ISendable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void send();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 各个信息发送类实现接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MessageSend implements ISendable{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class EmailMessageSend implements ISendable{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// messageService以后可以一直不变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MessageService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ISendable sender;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MessageService(ISendable sender) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.sender = messageHelper;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void send(String msg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sender.send(msg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 客户端调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MessageClient {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MessageService messageService = new MessageService(new MessageSend());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        messageService.send(&quot;Merry Christmas !&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MessageService messageService2 = new MessageService(new EmailMessageSend());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        messageService2.send(&quot;Merry Christmas !&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于MessageService服务类来说，不用做任何修改，只需要扩展新的推送消息的工具类即可, 这就是遵循开闭原则的好处</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="single-responsibility-principle">single responsibility principle<a href="#single-responsibility-principle" class="hash-link" aria-label="single responsibility principle的直接链接" title="single responsibility principle的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// bad demo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Calculator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int add() throws NumberFormatException, IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //这里读取和加法耦合在一起了，如果需要增加业务方法【减法】，就要更改代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        File file = new File(&quot;E:/data.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedReader br = new BufferedReader(new FileReader(file));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int a = Integer.valueOf(br.readLine());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int b = Integer.valueOf(br.readLine());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return a+b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws NumberFormatException, IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Calculator calculator = new Calculator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;result:&quot; + calculator.add());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// good demo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//遵循单一职责原则后, 是这样: 分离出来一个类用来读取数据，将一</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//个类拆成了两个类，这样以后我们如果有减法，乘法等等，就不用出现那么多重复代码了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Reader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int a,b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Reader(String path) throws NumberFormatException, IOException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedReader br = new BufferedReader(new FileReader(new File(path)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a = Integer.valueOf(br.readLine());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b = Integer.valueOf(br.readLine());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getA(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getB(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//单独的计算类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Calculator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int add(int a,int b){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws NumberFormatException, IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Reader reader = new Reader(&quot;E:/data.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Calculator calculator = new Calculator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;result:&quot; + calculator.add(reader.getA(),reader.getB()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interface-separation-principle">interface separation principle<a href="#interface-separation-principle" class="hash-link" aria-label="interface separation principle的直接链接" title="interface separation principle的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//这是错误示例，当实现此接口 时，必须实现不必要的方法 other()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Mobile {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void call();//手机可以打电话</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void sendMessage();//手机可以发短信</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void game();//手机可以玩愤怒的小鸟？这是不合适的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//正确的方式是：新建一个接口来拓展Mobile接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface SmartPhone extends Mobile{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void game();//智能手机的接口就可以加入这个方法了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="里氏替换原则">里氏替换原则<a href="#里氏替换原则" class="hash-link" aria-label="里氏替换原则的直接链接" title="里氏替换原则的直接链接">​</a></h2><p>基类子类可替换</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 看一个破坏继承体系的例子</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 也就是不符合李氏替换原则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 父类 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Parent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void method(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;parent method&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 子类 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SubClass extends Parent{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //结果某一个子类重写了父类的方法，说不支持该操作了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void method() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new UnsupportedOperationException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//某一个类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SomeoneClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //有某一个方法，使用了一个父类类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void someoneMethod(Parent parent){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        parent.method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 测试类 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SomeoneClass someoneClass = new SomeoneClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        someoneClass.someoneMethod(new Parent());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        someoneClass.someoneMethod(new SubClass());//此处报错, 运行时才产生报错 // 破坏了继承体系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="dependence-inversion-principle">dependence inversion principle<a href="#dependence-inversion-principle" class="hash-link" aria-label="dependence inversion principle的直接链接" title="dependence inversion principle的直接链接">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="least-knowledge-principle">Least Knowledge Principle<a href="#least-knowledge-principle" class="hash-link" aria-label="Least Knowledge Principle的直接链接" title="Least Knowledge Principle的直接链接">​</a></h2><p>类间解耦</p><p>一个类应该尽量不要和陌生的类有太多接触。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 错误示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class demo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void a() {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void b() {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void c() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 改进后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 只暴露必须的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class demo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void a() {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void b() {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void c() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>设计模式概要</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="设计模式总结">设计模式总结<a href="#设计模式总结" class="hash-link" aria-label="设计模式总结的直接链接" title="设计模式总结的直接链接">​</a></h2><p>常见的:</p><ul><li><p>工厂模式 &amp; 抽象工厂模式 - 不同条件下创建不同实例</p></li><li><p>模板模式 - 在父类中定义高层的算法执行顺序, 子类中具体实现每个步骤</p></li><li><p>策略模式 - 策略对象依赖注入到context对象，context对象根据它的策略改变而改变它的相关行为</p></li><li><p>适配器模式 - 使得某个不可修改的目标类符合特定要求的接口</p></li><li><p>装饰器模式 - 对被装饰类增强</p></li><li><p>责任链模式 - 拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p></li><li><p>代理模式 - 为目标对象提供一种代理以控制对这个对象的访问</p></li><li><p>观察者模式 - 一对多的依赖关系，在观察目标类里有一个 ArrayList 存放观察者们。当观察目标对象的状态发生改变，所有依赖于它的观察者都将得到通知，使这些观察者能够自动更新（即使用推送方式）</p></li><li><p>单例模式 - 保证一个类仅有一个实例</p></li></ul><p>不常见的:</p><ul><li><p>建造者模式 - 用于构造复杂对象</p></li><li><p>原型模式 - 通过拷贝原型创建新的对象</p></li><li><p>过滤器模式 - </p></li><li><p>桥接模式</p></li><li><p>门面模式 - 在客户端和复杂系统之间再加一层, 隐藏系统的复杂性</p></li><li><p>组合模式</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="spring-中的设计模式">spring 中的设计模式<a href="#spring-中的设计模式" class="hash-link" aria-label="spring 中的设计模式的直接链接" title="spring 中的设计模式的直接链接">​</a></h2><ul><li><p>简单工厂</p><ul><li>BeanFactory, 根据传入一个唯一的标识来获得Bean对象</li></ul></li><li><p>工厂方法模式</p><ul><li><p>FactoryBean接口。</p><p>  实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p></li></ul></li><li><p>单例模式</p><ul><li>Spring依赖注入Bean实例默认是单例的。</li></ul></li><li><p>代理模式</p><ul><li>aop 底层，就是动态代理模式的实现。</li></ul></li><li><p>观察者模式</p><ul><li><p>spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</p><p>  底层是通过 jdk 提供的事件模型实现的. EventObject, EventListener</p></li></ul></li><li><p>适配器模式</p><ul><li><p>SpringMVC中的适配器HandlerAdatper</p><p>  HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。</p></li></ul></li><li><p>装饰器模式</p><ul><li>spring 中 类名中含有Wrapper, 都是, 如: httpServletRquestWrapper...</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="不要过度使用设计模式">不要过度使用设计模式<a href="#不要过度使用设计模式" class="hash-link" aria-label="不要过度使用设计模式的直接链接" title="不要过度使用设计模式的直接链接">​</a></h2><p><a href="https://www.zhihu.com/question/23757906/answer/25567356" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/23757906/answer/25567356</a></p><p>除了Java, 其他提供动态编程的特性的语言无需设计模式, 因为:</p><ul><li>如果你用的语言能把类型像变量一样赋值并传来传去，很多创建型模式就没用了。</li><li>如果你用的语言能把函数像变量一样赋值并传来传去，很多行为模式就没用了。</li><li>如果你用的语言 style 反对叠床架屋的 class hierarchy，很多结构模式就没用了。</li></ul><h1>工厂模式</h1><p>优点:</p><ul><li>将复杂的对象创建过程封装, 简化对象的创建</li><li>解耦</li></ul><p>不同的工厂模式有不同特点:</p><ul><li><p>简单工厂(静态工厂): 提供一个超级工厂类, 通过 if else 封装所有 product 的创建逻辑. </p><ul><li><p>这样带来两个问题:</p><ul><li><p>工厂类违背 single responsibilities principle</p><p>  如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因。违背了单一职责原则</p></li><li><p>工厂类违背了 open close principle </p><p>  当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，所以这就违背了开闭原则</p></li></ul></li><li><p>选择关键点：一种产品是否可根据某个参数决定它的种类</p><p>  工厂类负责创建的对象较少, 不会造成工厂方法太过复杂</p><p>  客户端只知道传入参数, 对于是什么对象不关心</p></li></ul></li><li><p>工厂方法模式: 每个产品都提供一个单独的工厂类</p><ul><li><p>解决了简单工厂模式的两个问题.</p><p>  新增 product 创建 时, 增加 对应 factory class 即可, 无需修改已有的工厂类</p></li><li><p>还是存在问题: 工厂类不是面向接口的</p><p>  工厂方法模式可以进一步优化，提取出工厂接口</p></li><li><p>选择关键点：工厂类和产品类是否是同生同灭的关系</p><p>  客户端只知道具体工厂类和产品参数</p><p>  将创建对象的任务委托给多个工厂中的一个, client无需关心到底是哪个工厂类, 需要时再动态指定, 可以将工厂子类的类名存储在配置文件中or数据库中</p></li></ul></li><li><p>抽象工厂模式: 不同产品的工厂类实现同一个 factory interface, 每个 具体的 工厂实现类用来创建一个产品族</p><ul><li><p>使用场景: 系统中有多于一个的产品族，而且每次只使用其中一个产品族。</p><p>  一个产品族使用一个工厂类.</p><p>  产品族表示不同的产品的集合, 之间没有继承关系</p></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="工厂方法">工厂方法<a href="#工厂方法" class="hash-link" aria-label="工厂方法的直接链接" title="工厂方法的直接链接">​</a></h2><p>===============简单工厂 是工厂方法模式的特例</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class FruitFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Fruit create(String type){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        switch (type){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &quot;苹果&quot;: return new Apple(); // 对象创建逻辑可能非常复杂</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            case &quot;梨子&quot;: return new Pear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            default: throw new IllegalArgumentException(&quot;暂时没有这种水果&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void eat(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FruitFactory fruitFactory = new FruitFactory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fruit apple = fruitFactory.create(&quot;苹果&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fruit pear = fruitFactory.create(&quot;梨子&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        apple.eat();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pear.eat();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>==============工厂方法模式</p><p>为了解决简单工厂模式的这两个弊端，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class AppleFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Fruit create(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Apple();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class PearFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Fruit create(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Pear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void eat(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        AppleFactory appleFactory = new AppleFactory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fruit apple = appleFactory.create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PearFactory pearFactory = new PearFactory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fruit pear = pearFactory.create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        apple.eat();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pear.eat();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="抽象工厂">抽象工厂<a href="#抽象工厂" class="hash-link" aria-label="抽象工厂的直接链接" title="抽象工厂的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface IFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Fruit create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AppleFactory implements IFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Fruit create(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Apple();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class PearFactory implements IFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Fruit create(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Pear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void eat(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IFactory appleFactory = new AppleFactory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fruit apple = appleFactory.create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IFactory pearFactory = new PearFactory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fruit pear = pearFactory.create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        apple.eat();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pear.eat();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>模板模式</h1><p>定义: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中</p><p>优点: </p><ul><li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//举个例子，以准备去学校所要做的工作（prepareGotoSchool）为例，假设需要分三步：穿衣服（dressUp），吃早饭（eatBreakfast），带上东西（takeThings）。学生和老师要做得具体事情肯定有所区别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractPerson{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     //抽象类定义整个流程骨架  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     public void prepareGotoSchool(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          dressUp();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          eatBreakfast();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          takeThings();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     //以下是不同子类根据自身特性完成的具体步骤  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     protected abstract void dressUp();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     protected abstract void eatBreakfast();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     protected abstract void takeThings();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Student extends AbstractPerson{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     protected void dressUp() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(&quot;穿校服&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     protected void eatBreakfast() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(&quot;吃妈妈做好的早饭&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     protected void takeThings() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(&quot;背书包，带上家庭作业和红领巾&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Teacher extends AbstractPerson{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     protected void dressUp() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(&quot;穿工作服&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     protected void eatBreakfast() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(&quot;做早饭，照顾孩子吃早饭&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     protected void takeThings() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(&quot;带上昨晚准备的考卷&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     public static void main(String[] args) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Student student = new Student()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     student.prepareGotoSchool();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Teacher teacher  = new Teacher()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     teacher.prepareGotoSchool();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>策略模式</h1><p>定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换. </p><p>场景: (去除 if else)</p><p>涉及到三个角色:</p><ul><li><p>环境(Context)角色：持有一个Strategy的引用。</p></li><li><p>抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</p></li><li><p>具体策略(ConcreteStrategy)角色：包装了相关的具体算法或行为</p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//假设某店家推出三种会员，分别为普通会员，金牌会员和钻石会员，还有就是普通顾客，针对不同的会员顾客，购物结算时有不同的打折方式。购物后，客户的历史购物金额累计，可以自动升级到相应的会员级别。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 策略接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface IVipAlgo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int calc(int originalPrice);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//实现接口, 有多个实现, 每个实现的算法不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class VipAlgo1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int calc(int originalPrice) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class VipAlgo2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int calc(int originalPrice) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//上下文类, 具体执行某个算法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class VipCalculator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private IVipAlgo vipAlgo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public VipCalculator(IVipAlgo IVipAlgo) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.vipAlgo = IVipAlgo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int execAlgo(int originalPrice) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return vipAlgo.calc(originalPrice)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        VipCalculator calc = new VipCalculator(new VipAlgo1());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int result = calc(112);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>===========在 spring 中这么使用:</p><h1>观察者模式</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="观察者模式定义">观察者模式定义<a href="#观察者模式定义" class="hash-link" aria-label="观察者模式定义的直接链接" title="观察者模式定义的直接链接">​</a></h2><p>别名 发布订阅模式</p><p>定义: 观察目标发生状态变化时, 会通知众多的观察者</p><p>这就要求观察目标内部维护一个观察者列表, 以便一一通知</p><p>一个观察目标有多个观察者, 这些观察者派生自同一个接口</p><p>优点:</p><ul><li>解耦合</li></ul><p>缺点:</p><ul><li>观察者很多时耗时严重</li><li>观察者模式无法让观察者知道目标是如何变化的, 仅仅只是知道目标发生了变化</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 抽象观察者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月25日 下午9:29:32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface IObserver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 目标对象调用这个方法通知观察者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void update(Target t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * observe target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月25日 下午11:19:52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class Target {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * observer list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;IObserver&gt; observerList = new ArrayList&lt;IObserver&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * add observer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param observer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void add(IObserver observer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        observerList.add(observer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * remove observer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param observer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void remove(IObserver observer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        observerList.remove(observer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * change status</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void change() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Target状态发生变化&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.inform();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * inform observers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void inform() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(IObserver observer: observerList) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            observer.update(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////// 如何使用?  ////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 先定义 observers, 多个, 实现自己的 update()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *  concrete observer1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月25日 下午11:42:45</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Observer1 implements IObserver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void update(Target t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Observer1观察到&quot; + t.getClass().getSimpleName()+ &quot;发生变化&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * concrete observer2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月25日 下午11:45:16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Observer2 implements IObserver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void update(Target t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Observer2观察到&quot; + t.getClass().getSimpleName() + &quot;发生变化.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月25日 下午11:53:28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyTarget extends Target {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Target t = new MyTarget();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IObserver observer1 = new Observer1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IObserver observer2=  new Observer2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.add(observer1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.add(observer2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.change();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="jdk-中的观察者模式">jdk 中的观察者模式<a href="#jdk-中的观察者模式" class="hash-link" aria-label="jdk 中的观察者模式的直接链接" title="jdk 中的观察者模式的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="jdk-中的-api">jdk 中的 api<a href="#jdk-中的-api" class="hash-link" aria-label="jdk 中的 api的直接链接" title="jdk 中的 api的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//观察者接口，每一个观察者都必须实现这个接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Observer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这个方法是观察者在观察对象产生变化时所做的响应动作，从中传入了观察的对象和一个预留参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void update(Observable o, Object arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//被观察者类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Observable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这是一个改变标识，来标记该被观察者有没有改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean changed = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //持有一个观察者列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Vector obs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Observable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        obs = new Vector();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //添加观察者，添加时会去重</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void addObserver(Observer o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (o == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!obs.contains(o)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            obs.addElement(o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //删除观察者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void deleteObserver(Observer o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        obs.removeElement(o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //notifyObservers(Object arg)的重载方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void notifyObservers() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyObservers(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //通知所有观察者，被观察者改变了，可以执行update方法了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void notifyObservers(Object arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //一个临时的数组，用于并发访问被观察者时，留住观察者列表的当前状态，这种处理方式其实也算是一种设计模式，即备忘录模式。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object[] arrLocal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //注意这个同步块，它表示在获取观察者列表时，该对象是被锁定的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //也就是说，在我获取到观察者列表之前，不允许其他线程改变观察者列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (this) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //如果没变化直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!changed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //这里将当前的观察者列表放入临时数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arrLocal = obs.toArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //将改变标识重新置回未改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clearChanged();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //注意这个for循环没有在同步块，此时已经释放了被观察者的锁，其他线程可以改变观察者列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //但是这并不影响我们当前进行的操作，因为我们已经将观察者列表复制到临时数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //在通知时我们只通知数组中的观察者，当前删除和添加观察者，都不会影响我们通知的对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = arrLocal.length-1; i&gt;=0; i--)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((Observer)arrLocal[i]).update(this, arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //删除所有观察者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void deleteObservers() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        obs.removeAllElements();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //标识被观察者被改变过了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected synchronized void setChanged() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        changed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //标识被观察者没改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected synchronized void clearChanged() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        changed = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //返回被观察者是否改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized boolean hasChanged() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return changed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //返回观察者数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized int countObservers() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return obs.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="jdk-观察者模式使用示例">jdk 观察者模式使用示例<a href="#jdk-观察者模式使用示例" class="hash-link" aria-label="jdk 观察者模式使用示例的直接链接" title="jdk 观察者模式使用示例的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//读者类，要实现观察者接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Reader implements Observer{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Reader(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //读者可以关注某一位作者，关注则代表把自己加到作者的观察者列表里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void subscribe(String writerName){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WriterManager.getInstance().getWriter(writerName).addObserver(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //读者可以取消关注某一位作者，取消关注则代表把自己从作者的观察者列表里删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void unsubscribe(String writerName){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WriterManager.getInstance().getWriter(writerName).deleteObserver(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //当关注的作者发表新小说时，会通知读者去看</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void update(Observable o, Object obj) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (o instanceof Writer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Writer writer = (Writer) o;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(name+&quot;知道&quot; + writer.getName() + &quot;发布了新书《&quot; + writer.getLastNovel() + &quot;》，非要去看！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//作者类，要继承自被观察者类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Writer extends Observable{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;//作者的名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String lastNovel;//记录作者最新发布的小说</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Writer(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WriterManager.getInstance().add(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //作者发布新小说了，要通知所有关注自己的读者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void addNovel(String novel) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(name + &quot;发布了新书《&quot; + novel + &quot;》！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastNovel = novel;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setChanged();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyObservers();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getLastNovel() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return lastNovel;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//管理器，保持一份独有的作者列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WriterManager{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Map&lt;String, Writer&gt; writerMap = new HashMap&lt;String, Writer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //添加作者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void add(Writer writer){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writerMap.put(writer.getName(), writer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据作者姓名获取作者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Writer getWriter(String name){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return writerMap.get(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //单例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private WriterManager(){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static WriterManager getInstance(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return WriterManagerInstance.instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class WriterManagerInstance{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static WriterManager instance = new WriterManager();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//客户端调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //假设四个读者，两个作者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Reader r1 = new Reader(&quot;谢广坤&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Reader r2 = new Reader(&quot;赵四&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Reader r3 = new Reader(&quot;七哥&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Reader r4 = new Reader(&quot;刘能&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Writer w1 = new Writer(&quot;谢大脚&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Writer w2 = new Writer(&quot;王小蒙&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //四人关注了谢大脚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r1.subscribe(&quot;谢大脚&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r2.subscribe(&quot;谢大脚&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r3.subscribe(&quot;谢大脚&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r4.subscribe(&quot;谢大脚&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //七哥和刘能还关注了王小蒙</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r3.subscribe(&quot;王小蒙&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r4.subscribe(&quot;王小蒙&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //作者发布新书就会通知关注的读者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //谢大脚写了设计模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        w1.addNovel(&quot;设计模式&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //王小蒙写了JAVA编程思想</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        w2.addNovel(&quot;JAVA编程思想&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //谢广坤取消关注谢大脚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r1.unsubscribe(&quot;谢大脚&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //谢大脚再写书将不会通知谢广坤</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        w1.addNovel(&quot;观察者模式&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="事件驱动模型">事件驱动模型<a href="#事件驱动模型" class="hash-link" aria-label="事件驱动模型的直接链接" title="事件驱动模型的直接链接">​</a></h2><p>观察者模式的另一种形态, 例如Tomcat中的监听器listener</p><p>两种形态区别:</p><ul><li><p>观察者模式中, 只要 target 发生变化, 都会通知 观察者, 而而事件驱动则不是，因为我们可以定义自己感兴趣的事情, 忽略其他变化</p></li><li><p>观察者模式要求被观察者继承Observable类, 事件驱动中事件源则不需要，因为事件源所维护的监听器列表是给自己定制的，所以无法去制作一个通用的父类去完成这个工作。</p></li><li><p>被观察者传送给观察者的信息是模糊的，比如update中第二个参数，类型是Object，这需要观察者和被观察者之间有约定才可以使用这个参数。而在事件驱动模型中，这些信息是被封装在Event当中的，可以更清楚的告诉监听器，每个信息都是代表的什么。</p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//定义作者事件, 这代表了一个作者事件: 发布新书</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个事件当中一般就是包含一个事件源，在这里就是作者, 通过 constructor 传入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WriterEvent extends EventObject{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final long serialVersionUID = 8546459078247503692L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public WriterEvent(Writer writer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(writer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Writer getWriter(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (Writer) super.getSource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//对应的 需要有一个监听器监听这个事件, 对&quot;指定事件&quot; 做出反应</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface WriterListener extends EventListener{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 参数: 被监听的事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void addNovel(WriterEvent writerEvent);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//作者类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 可以看到，作者类的主要变化是添加了一个自己的监听器列表，我们使用set是为了它的天然去重效果，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Writer{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;//作者的名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String lastNovel;//记录作者最新发布的小说</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Set&lt;WriterListener&gt; writerListenerList = new HashSet&lt;WriterListener&gt;();//作者类要包含一个自己监听器的列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Writer(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WriterManager.getInstance().add(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //作者发布新小说了，要通知所有关注自己的读者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void addNovel(String novel) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(name + &quot;发布了新书《&quot; + novel + &quot;》！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastNovel = novel;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fireEvent();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //触发发布新书的事件，通知所有监听这件事的监听器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void fireEvent(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WriterEvent writerEvent = new WriterEvent(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (WriterListener writerListener : writerListenerList) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            writerListener.addNovel(writerEvent);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //提供给外部注册成为自己的监听器的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void registerListener(WriterListener writerListener){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writerListenerList.add(writerListener);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //提供给外部注销的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void unregisterListener(WriterListener writerListener){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writerListenerList.remove(writerListener);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getLastNovel() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return lastNovel;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 读者类的变化，首先本来是实现Observer接口，现在要实现WriterListener接口，响应的update方法就改为我们定义的addNovel方法，当中的响应基本没变。另外就是关注和取消关注的方法中，原来是给作者类添加观察者和删除观察者，现在是注册监听器和注销监听器，几乎是没什么变化的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Reader implements WriterListener{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Reader(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //读者可以关注某一位作者，关注则代表把自己加到作者的监听器列表里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void subscribe(String writerName){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WriterManager.getInstance().getWriter(writerName).registerListener(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //读者可以取消关注某一位作者，取消关注则代表把自己从作者的监听器列表里注销</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void unsubscribe(String writerName){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WriterManager.getInstance().getWriter(writerName).unregisterListener(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void addNovel(WriterEvent writerEvent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Writer writer = writerEvent.getWriter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(name+&quot;知道&quot; + writer.getName() + &quot;发布了新书《&quot; + writer.getLastNovel() + &quot;》，非要去看！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>代理模式</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="静态代理">静态代理<a href="#静态代理" class="hash-link" aria-label="静态代理的直接链接" title="静态代理的直接链接">​</a></h2><p>代理对象和被代理对象实现相同的接口</p><p>代理内部维护一个被代理对象</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 代理目标和代理都要实现的统一接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午10:40:28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Moveable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void move();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 代理目标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午10:43:01</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Car implements Moveable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void move() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Car 开始移动...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(new Random().nextInt(10000));// 单位是ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Car 代理类, 添加了时间统计功能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午10:47:44</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CarTimingProxy implements Moveable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Moveable car;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CarTimingProxy(Moveable car) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.car = car;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void move() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long start = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        car.move();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long end = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;move持续时间: &quot; + (end-start));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * car 代理类, 记录日志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午10:57:13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CarLogProxy implements Moveable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Moveable car;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CarLogProxy(Moveable car) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.car = car;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void move() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;log: Car开始移动&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        car.move();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;log: Car结束移动&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午11:00:13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Moveable car = new CarLogProxy(new CarTimingProxy(new Car()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        car.move();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="动态代理">动态代理<a href="#动态代理" class="hash-link" aria-label="动态代理的直接链接" title="动态代理的直接链接">​</a></h2><p>如果需要代理的类只有一个，那么静态代理没什么问题，如果有很多类需要代理呢，用静态代理的话就需要为每一个类创建一个代理类，显然这么做太过繁琐也容易出错。</p><p>JDK 5引入的动态代理机制，允许开发人员在运行时刻动态的创建出代理类及其对象。也就是说，我们不用为每个类再单独创建一个代理对象了。</p><p>比如我们有两个业务，要为这两个业务添加日志打印功能。如果是静态代理，那么就需要分别为每个业务类写一个代理类，而如果用动态代理，只需要实现一个日志打印功能的handler即可，完全不需要自己再单独写代理类</p><p>定义: 在程序运行时, 动态为不同的对象生成代理对象. 动态代理主要是利用了Java的反射机制。</p><p>场景: 比如Spring的aop</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="看一个使用示例">看一个使用示例<a href="#看一个使用示例" class="hash-link" aria-label="看一个使用示例的直接链接" title="看一个使用示例的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Car car = new Car();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里必须使用接口接收, 不然会转型异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Moveable proxy = (Moveable) Proxy.newProxyInstance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                car.getClass().getClassLoader(), // 被代理对象的classloader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new Class[] {Moveable.class},// 手动列出接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvocationHandler() {// 请求处理类, 因为知道不会复用, 这里直接使用匿名类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Object rst = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        String methodName = method.getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (&quot;move&quot;.equals(methodName)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;方法被代理前...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            rst = method.invoke(car, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;方法被代理后...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            rst = method.invoke(car, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return rst;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        proxy.move();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="自定义数据库连接池">自定义数据库连接池<a href="#自定义数据库连接池" class="hash-link" aria-label="自定义数据库连接池的直接链接" title="自定义数据库连接池的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 数据库连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 现在需要手动实现一个数据库连接池, 没有使用代理模式的情况下是这样:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyPool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int init_count = 3;        // 初始化连接数目</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int max_count = 6;        // 最大连接数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int current_count = 0;  // 记录当前使用连接数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 连接池 （存放所有的初始化连接）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //1.  构造函数中，初始化连接放入连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyPool() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初始化连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i=0; i&lt;init_count; i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 记录当前连接数目</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            current_count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建原始的连接对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Connection con = createConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 把连接加入连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pool.addLast(con);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //2. 创建一个新的连接的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Connection createConnection(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 原始的目标对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             Connection con = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc_demo&quot;, &quot;root&quot;, &quot;root&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return con;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //3. 获取连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Connection getConnection(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.1 判断连接池中是否有连接, 如果有连接，就直接从连接池取出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pool.size() &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return pool.removeFirst();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.2 连接池中没有连接： 判断，如果没有达到最大连接数，创建；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (current_count &lt; max_count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 记录当前使用的连接数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            current_count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return createConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.3 如果当前已经达到最大连接数，抛出异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new RuntimeException(&quot;当前连接已经达到最大连接数目 ！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //4. 释放连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void realeaseConnection(Connection con) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 4.1 判断： 池的数目如果小于初始化连接，就放入池中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pool.size() &lt; init_count){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pool.addLast(con);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 4.2 关闭 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                current_count--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                con.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (SQLException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 测试：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyPool pool = new MyPool();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;当前连接: &quot; + pool.current_count);  // 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Connection con4 = pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Connection con3 = pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Connection con2 = pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Connection con1 = pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 释放连接, 连接放回连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//        pool.realeaseConnection(con1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 希望：当关闭连接的时候，要把连接放入连接池！【当调用Connection接口的close方法时候，希望触发pool.addLast(con);操作】把连接放入连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 解决1：实现Connection接口，重写close方法   connection接口方法太多，都实现太麻烦，放弃</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 解决2：动态代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    con1.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 再获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;连接池：&quot; + pool.pool.size());      // 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;当前连接: &quot; + pool.current_count);  // 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>采用动态的代理后, 改进如下:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *  JDK 动态代理  Object obj = Proxy.newProxyInstance(....)；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *  1.参数1：ClassLoader loader ,确定类加载器。程序运行时动态创建类，需要类加载加载到内存。类加载器作用：class文件 --&gt; Class对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      * 一般情况使用都是当前类的类加载器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      * 类加载器获得方式：MyFactory.class.getClassLoader();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *  2.参数2：Class[] interfaces  代理需要实现的接口们（可能有多个）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      * 方式1：userService.getClass().getInterfaces()【此方式只能在代理对象和接口是父子关系时使用】</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      * 方式2：new Class[]{UserService.class}【当被代理对象和其实现接口之间是隔代关系时（即祖孙关系）(即:一个一个列出接口)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *  3.参数3：InvocationHandler h 请求处理类，代理类方法执行时，需要请求处理类来处理。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      * 一般采用匿名内部类：new InvocationHandler(){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      * 实现方法 invoke ，代理类每一个方法执行一次，将调用一次invoke</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          参数1.1：Object proxy ,代理对象（即 proxyService，不是“代理之前对象”），一般不用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          参数2.2：Method method ，当前执行的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              * 当前调用方法名：method.getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              * 执行目标类方法：Object obj = method.invoke(代理之前对象 , args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          参数3.3：Object[] args</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *              * 当前方法实际参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyPool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int init_count = 3;        // 初始化连接数目</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int max_count = 6;        // 最大连接数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int current_count = 0;  // 记录当前使用连接数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 连接池 （存放所有的初始化连接）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //1.  构造函数中，初始化连接放入连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyPool() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初始化连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i=0; i&lt;init_count; i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 记录当前连接数目</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            current_count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建原始的连接对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Connection con = createConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 把连接加入连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pool.addLast(con);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //2. 创建一个新的连接的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Connection createConnection(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 原始的目标对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final Connection con = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc_demo&quot;, &quot;root&quot;, &quot;root&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /**********对con对象代理**************/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 对con创建其代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Connection proxy = (Connection) Proxy.newProxyInstance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    con.getClass().getClassLoader(),    // 类加载器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //con.getClass().getInterfaces(),   // 当目标对象是一个具体的类的时候 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    new Class[]{Connection.class},      // 目标对象实现的接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    new InvocationHandler() {            // 当调用con对象方法的时候， 自动触发事务处理器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        public Object invoke(Object proxy, Method method, Object[] args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 方法返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Object result = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 当前执行的方法的方法名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            String methodName = method.getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 判断当执行了close方法的时候，把连接放入连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (&quot;close&quot;.equals(methodName)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                System.out.println(&quot;begin:当前执行close方法开始！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                // 连接放入连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                pool.addLast(con);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                System.out.println(&quot;end: 当前连接已经放入连接池了！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                // 调用目标对象方法，注意这里不是代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                result = method.invoke(con, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return proxy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //3. 获取连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Connection getConnection(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.1 判断连接池中是否有连接, 如果有连接，就直接从连接池取出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pool.size() &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return pool.removeFirst();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.2 连接池中没有连接： 判断，如果没有达到最大连接数，创建；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (current_count &lt; max_count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 记录当前使用的连接数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            current_count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return createConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3.3 如果当前已经达到最大连接数，抛出异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new RuntimeException(&quot;当前连接已经达到最大连接数目 ！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //4. 释放连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void realeaseConnection(Connection con) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 4.1 判断： 池的数目如果小于初始化连接，就放入池中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pool.size() &lt; init_count){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pool.addLast(con);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 4.2 关闭 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                current_count--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                con.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (SQLException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 测试：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyPool pool = new MyPool();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;当前连接: &quot; + pool.current_count);  // 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Connection con4 = pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Connection con3 = pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Connection con2 = pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Connection con1 = pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 释放连接, 连接放回连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//        pool.realeaseConnection(con1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 希望：当关闭连接的时候，要把连接放入连接池！【当调用Connection接口的close方法时候，希望触发pool.addLast(con);操作】把连接放入连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 解决1：实现Connection接口，重写close方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 解决2：动态代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        con1.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 再获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pool.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;连接池：&quot; + pool.pool.size());      // 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;当前连接: &quot; + pool.current_count);  // 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>装饰器模式</h1><p>希望给一个对象添加行为, 但是又希望这个改动对调用者透明</p><p>这个和适配器模式相似, 但是有区别: 适配器模式的目的在于适配接口，装饰器模式的目的在于动态的添加功能，且可以叠加</p><p>一般有两种方式可以实现给一个类或对象增加行为(和 adapter 类似)：</p><ul><li><p>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</p></li><li><p>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</p></li></ul><p>场景: 带 wrapper 的类, 如 servlet 中的 HttpServletRequestWrapper</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//待装饰接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Component {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//具体待装饰类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ConcreteComponent implements Component{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void method() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;原来的方法&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//抽象装饰器父类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class Decorator implements Component{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Component component;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Decorator(Component component) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.component = component;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void method() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        component.method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//具体装饰器类A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ConcreteDecoratorA extends Decorator{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ConcreteDecoratorA(Component component) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(component);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void methodA(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;被装饰器A扩展的功能&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 重写父类方法, 进行增强</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void method(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;针对该方法加一层A包装&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;A包装结束&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//具体装饰器类B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ConcreteDecoratorB extends Decorator{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ConcreteDecoratorB(Component component) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(component);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void methodB(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;被装饰器B扩展的功能&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void method(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;针对该方法加一层B包装&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;B包装结束&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>适配器模式</h1><p>将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作</p><p>java.util.Arrays#asList()
java.util.Collections#list()</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 待适配类, 已存在的、具有特殊功能、希望被重用, 但不符合我们既有的标准接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Adaptee {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void specificRequest() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;被适配类具有 特殊功能...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 目标接口，或称为标准接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Target {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void request();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 具体目标类，但是只提供普通功能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class ConcreteTarget implements Target {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void request() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;普通类 具有 普通功能...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 适配器类，继承了被适配类，同时实现标准接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Adapter extends Adaptee implements Target{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void request() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.specificRequest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 测试类public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用普通功能类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Target concreteTarget = new ConcreteTarget();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        concreteTarget.request();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用特殊功能类，即适配类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Target adapter = new Adapter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        adapter.request();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对象适配器 ---------------- 使用组合(推荐)</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 适配器类，直接关联被适配类，同时实现标准接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Adapter implements Target{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 直接关联被适配类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Adaptee adaptee;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可以通过构造函数传入具体需要适配的被适配类对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Adapter (Adaptee adaptee) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.adaptee = adaptee;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void request() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里是使用委托的方式完成特殊功能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.adaptee.specificRequest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 测试类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用普通功能类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Target concreteTarget = new ConcreteTarget();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        concreteTarget.request();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用特殊功能类，即适配类，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 需要先创建一个被适配类的对象作为参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Target adapter = new Adapter(new Adaptee());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        adapter.request();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>责任链模式</h1><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。</p><p>典型如 流程审批</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 信息处理接口, 链条上的每个过滤器都实现它</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午5:45:12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface IFilter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 处理信息方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param rqt 输入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String doFilter(String rqt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/***</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 职责链, 面向处理节点接口编程, 和具体的处理节点没有关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午6:24:56</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class FilterChain implements IFilter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;IFilter&gt; filterChain =  new ArrayList&lt;IFilter&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String doFilter(String rqt) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(IFilter f: filterChain) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rqt = f.doFilter(rqt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rqt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 添加过滤节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param filter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public FilterChain addFilter(IFilter filter) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.filterChain.add(filter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 信息处理器, 封装了职责链, 这里相当与一个外观模式, 封装了内部细节,只提供给外部一个process()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *  完全可以省略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午6:01:33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MessageProcessor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 封装的职责链</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private FilterChain fc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MessageProcessor(FilterChain fc) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.fc = fc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String process(String rqt) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return fc.doFilter(rqt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 具体的处理节点, 将&lt;&gt;替换为[]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午6:11:58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HtmlFilter implements IFilter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String doFilter(String rqt) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String replace = rqt.replaceAll(&quot;&lt;&quot;, &quot;[&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .replaceAll(&quot;&gt;&quot;, &quot;]&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return replace;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 具体的处理节点, 敏感词过滤 将xxx换为yyy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午6:15:37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SensitiveFilter implements IFilter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String doFilter(String rqt) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rqt.replaceAll(&quot;xxx&quot;, &quot;yyy&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 简单职责链模式client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午6:17:51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String str = &quot;hhh, xxx :) &lt;script&gt;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FilterChain fc = new FilterChain().addFilter(new HtmlFilter()).addFilter(new SensitiveFilter());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MessageProcessor processor = new MessageProcessor(fc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String rst = processor.process(str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(rst);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>===================复杂（请求响应有序）责任链</p><p>类比 servlet 中的 filter</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午8:09:54</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Request {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String content;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * response</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午8:10:24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Response {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String content;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 节点接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午8:08:13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface IFilter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void doFilter(Request rqt, Response rsp, FilterChain chain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * filter chain</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午8:20:58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class FilterChain implements IFilter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 节点执行索引, 初始为0; 表示当前执行到哪个filter了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int currentFilterIndex = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 过滤节点容器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;IFilter&gt; filters = new ArrayList&lt;IFilter&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void doFilter(Request rqt, Response rsp, FilterChain chain) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 当 chain 中的 filter 被遍历执行完, 跳出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (this.filters.size() == currentFilterIndex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            IFilter filter = filters.get(currentFilterIndex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 当前节点获取到后, 马上索引移动到下一个, 不然会循环调用, 一直调用第一个filter, 直到系统崩溃</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            currentFilterIndex++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            filter.doFilter(rqt, rsp, chain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public FilterChain addFilter(IFilter filter) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.filters.add(filter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * html filter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午8:32:39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HtmlFilter implements IFilter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void doFilter(Request rqt, Response rsp, FilterChain chain) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rqt.setContent(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rqt.getContent().replace(&quot;&lt;&quot;, &quot;[&quot;).replace(&quot;&gt;&quot;, &quot;]&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;HtmlFilter: 请求过程中被处理&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        chain.doFilter(rqt, rsp, chain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;HtmlFilter: 返回过程中被处理&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * sensitive filter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午8:38:58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SensitiveFilter implements IFilter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void doFilter(Request rqt, Response rsp, FilterChain chain) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rqt.setContent(rqt.getContent().replaceAll(&quot;xxx&quot;, &quot;yyy&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;SensitiveFilter: 请求过程被处理&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        chain.doFilter(rqt, rsp, chain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;SensitiveFilter: 返回过程被处理&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月26日 下午8:43:43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String str = &quot;hhh, xxx :) &lt;script&gt;, &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Request rqt = new Request();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rqt.setContent(str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Response rsp = new Response();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rsp.setContent(&quot;response-content&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FilterChain fc = new FilterChain().addFilter(new HtmlFilter()).addFilter(new SensitiveFilter());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fc.doFilter(rqt, rsp, fc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(rsp.getContent());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>单例模式</h1><p>某个对象全局只需要一个实例时，就可以使用单例模式。它的优点也显而易见：</p><ul><li>它能够避免对象重复创建，节约空间并提升效率</li><li>避免由于操作不同实例导致的逻辑错误</li></ul><p>线程安全的实现:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 带有双重判断的单例模式 ---- 不直观, 不推荐</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月25日 下午4:48:41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SyncSingleton {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //一个静态的实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static volatile SyncSingleton instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //私有化构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private SyncSingleton() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //给出一个公共的静态方法返回一个单一实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static SyncSingleton getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (instance == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //这里第二重判断：AB两个线程同时进入第一个判断内部，此时A当先拿到锁进入第二判断，创建了对象，B拿到锁后会再次进行判断，如果此处不判断，则会创建第二个对象；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (SyncSingleton.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (instance == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    instance = new SyncSingleton();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////// 推荐这种写法: 借助 jvm 的特性帮助实现 singleton ////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 更安全, 更简单的单例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *首先来说一下，这种方式为何会避免了上面莫名的错误，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *主要是因为一个类的静态属性只会在第一次加载类时初始化，这是JVM帮我们保证的，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *所以我们无需担心并发访问的问题。所以在初始化进行一半的时候，别的线程是无法使用的，因为JVM会帮我们强行同步这个过程。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *另外由于静态变量只初始化一次，所以singleton仍然是单例的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2018年1月25日 下午5:02:23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Singleton {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Singleton(){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Singleton getInstance(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return SingletonInstance.instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //类的静态成员只加载一次，这保证了只有一个对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class SingletonInstance{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static Singleton instance = new Singleton();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>命令模式</h1><h1>门面模式</h1><h1>建造者模式</h1><h1>流水线模式</h1><p><a href="https://juejin.cn/post/7070338942184194084" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7070338942184194084</a></p><p><a href="https://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.html" target="_blank" rel="noopener noreferrer">https://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.html</a></p><p><a href="http://www.uml.org.cn/j2ee/201909271.asp" target="_blank" rel="noopener noreferrer">http://www.uml.org.cn/j2ee/201909271.asp</a></p><p><a href="https://blog.csdn.net/huzhiqiangCSDN/article/details/56846268" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/huzhiqiangCSDN/article/details/56846268</a></p><h1>状态模式 state machine</h1></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/设计模式">设计模式</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/xiaoyureed/xiaoyureed.github.io/tree/main/docs/design-pattern-note.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/data-structure-and-algorithm"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Data Structure and Algorithm</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/dev-resources"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">开发者资源</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#open-close-principle" class="table-of-contents__link toc-highlight">open close principle</a></li><li><a href="#single-responsibility-principle" class="table-of-contents__link toc-highlight">single responsibility principle</a></li><li><a href="#interface-separation-principle" class="table-of-contents__link toc-highlight">interface separation principle</a></li><li><a href="#里氏替换原则" class="table-of-contents__link toc-highlight">里氏替换原则</a></li><li><a href="#dependence-inversion-principle" class="table-of-contents__link toc-highlight">dependence inversion principle</a></li><li><a href="#least-knowledge-principle" class="table-of-contents__link toc-highlight">Least Knowledge Principle</a></li><li><a href="#设计模式总结" class="table-of-contents__link toc-highlight">设计模式总结</a></li><li><a href="#spring-中的设计模式" class="table-of-contents__link toc-highlight">spring 中的设计模式</a></li><li><a href="#不要过度使用设计模式" class="table-of-contents__link toc-highlight">不要过度使用设计模式</a></li><li><a href="#工厂方法" class="table-of-contents__link toc-highlight">工厂方法</a></li><li><a href="#抽象工厂" class="table-of-contents__link toc-highlight">抽象工厂</a></li><li><a href="#观察者模式定义" class="table-of-contents__link toc-highlight">观察者模式定义</a></li><li><a href="#jdk-中的观察者模式" class="table-of-contents__link toc-highlight">jdk 中的观察者模式</a><ul><li><a href="#jdk-中的-api" class="table-of-contents__link toc-highlight">jdk 中的 api</a></li><li><a href="#jdk-观察者模式使用示例" class="table-of-contents__link toc-highlight">jdk 观察者模式使用示例</a></li></ul></li><li><a href="#事件驱动模型" class="table-of-contents__link toc-highlight">事件驱动模型</a></li><li><a href="#静态代理" class="table-of-contents__link toc-highlight">静态代理</a></li><li><a href="#动态代理" class="table-of-contents__link toc-highlight">动态代理</a><ul><li><a href="#看一个使用示例" class="table-of-contents__link toc-highlight">看一个使用示例</a></li><li><a href="#自定义数据库连接池" class="table-of-contents__link toc-highlight">自定义数据库连接池</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.a7606eaf.js"></script>
<script src="/assets/js/main.c0bf4a94.js"></script>
</body>
</html>