<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-java-note">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Java Core 笔记 | Xiaoyureed&#x27;s 网络 Wiki </title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://xiaoyureed.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://xiaoyureed.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://xiaoyureed.github.io/docs/java-note"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java Core 笔记 | Xiaoyureed&#x27;s 网络 Wiki "><meta data-rh="true" name="description" content="https://github.com/remkop/picocli 命令行开发"><meta data-rh="true" property="og:description" content="https://github.com/remkop/picocli 命令行开发"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://xiaoyureed.github.io/docs/java-note"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/en/docs/java-note" hreflang="en"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/java-note" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/java-note" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Xiaoyureed&#39;s 网络 Wiki  RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Xiaoyureed&#39;s 网络 Wiki  Atom Feed"><link rel="stylesheet" href="/assets/css/styles.ca3abbab.css">
<link rel="preload" href="/assets/js/runtime~main.a7606eaf.js" as="script">
<link rel="preload" href="/assets/js/main.c0bf4a94.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Xiaoyureed</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/xiaoyureed" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="打开/收起侧边栏菜单「Tutorial - Basics」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="打开/收起侧边栏菜单「Tutorial - Extras」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/SpringBoot-note">Spring Boot 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/agile-development-user-story-scrum">敏捷开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/autohotkey">Autohotkey 脚本</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/chatgpt">Chatgpt Usage Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cpp">CPP and C 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cross-gfw">Cross The GFW</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cs-note">Computer Science Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/css-pre-processor">几种CSS预处理器比较选型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/data-structure-and-algorithm">Data Structure and Algorithm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design-pattern-note">Design Pattern 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev-resources">开发者资源</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/distributed-system">Distributed System 分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/docker-note-virtual-dev-env">Docker Note &amp; Other Virtual Develop Environment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/effective-java-reading-note">Effective Java 阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/how-to-test-java-app">How to Test Java App</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/html-note">HTML 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/idea-note">InteliJ idea tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/interview-system-design">经典的系统设计思路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/java-code-clean">Java Clean Code Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/java-note">Java Core 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/linux-note">鸟哥的 Linux 私房菜阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/mybatis-note">MyBatis Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-audio-video">Audio and Video development Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-big-data-introduce">大数据开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-computational-ad">计算广告 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-crawler-spider">网络爬虫 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-desktop-develop">桌面应用开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-http">HTTP protocol Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-reactive-programming">响应式编程 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-rpc">RPC Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-rule-engine-note">规则引擎 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/quant-money">量化交易</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/saas-paas-iaas-as-a-service">SaaS Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/spring-note">Spring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/springmvc-note">Spring MVC</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java Core 笔记</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Java Core 笔记</h1></header><p><a href="https://github.com/remkop/picocli" target="_blank" rel="noopener noreferrer">https://github.com/remkop/picocli</a> 命令行开发</p><p> sentry grafana prometheus youtrack</p><p><a href="https://github.com/akullpp/awesome-java" target="_blank" rel="noopener noreferrer">https://github.com/akullpp/awesome-java</a>
<a href="https://github.com/CodingDocs/awesome-java" target="_blank" rel="noopener noreferrer">https://github.com/CodingDocs/awesome-java</a> 中文版</p><p>Java core note.
<a href="https://docs.oracle.com/javase/tutorial/" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/tutorial/</a>
jdk 8u192 是最后的免费版本, 之后的都要收费了</p><p><a href="https://www.jianshu.com/p/a06aa86c6b27" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/a06aa86c6b27</a> (Jodconvert , 是一个 java 的文档转换器, 利用 openoffice 或 libreOffice 来进行文档格式转换.)</p><p><a href="https://godbolt.org/" target="_blank" rel="noopener noreferrer">https://godbolt.org/</a> - 在线机器码转换</p><p><a href="https://github.com/qiurunze123" target="_blank" rel="noopener noreferrer">https://github.com/qiurunze123</a> - 高并发</p><p><a href="https://github.com/Snailclimb/awesome-java#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener noreferrer">https://github.com/Snailclimb/awesome-java#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F</a> awesome java</p><ul><li><a href="#1-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC">1. 各个版本</a></li><li><a href="#2-%E6%B3%A8%E9%87%8A">2. 注释</a></li><li><a href="#3-%E5%8F%8D%E5%B0%84reflect">3. 反射reflect</a><ul><li><a href="#31-%E5%8F%8D%E5%B0%84%E7%9A%84-api">3.1. 反射的 api</a></li><li><a href="#32-%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6">3.2. 实现事件驱动机制</a></li></ul></li><li><a href="#4-java-%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B">4. java 并发-多线程</a></li><li><a href="#5-%E9%9B%86%E5%90%88">5. 集合</a><ul><li><a href="#51-%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%93%E7%B3%BB">5.1. 集合的体系</a></li><li><a href="#52-%E8%AF%BB%E6%BA%90%E7%A0%81">5.2. 读源码</a><ul><li><a href="#521-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%8C%BA%E5%88%AB">5.2.1. 数组和链表区别</a></li><li><a href="#522-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%8C%BA%E5%88%AB">5.2.2. 单链表和双链表区别</a></li><li><a href="#523-hashmap">5.2.3. HashMap</a></li><li><a href="#524-hashset">5.2.4. HashSet</a></li><li><a href="#525-hashtable">5.2.5. HashTable</a></li><li><a href="#526-linkedhashmap">5.2.6. LinkedHashMap</a></li><li><a href="#527-treemap">5.2.7. TreeMap</a></li><li><a href="#528-lindedhashset">5.2.8. LindedHashSet</a></li><li><a href="#529-arraylist-%E5%92%8C-vector">5.2.9. ArrayList 和 Vector</a></li><li><a href="#5210-linkedlist">5.2.10. LinkedList</a></li><li><a href="#5211-concurrenthashmap">5.2.11. ConcurrentHashMap</a></li></ul></li><li><a href="#53-collections-%E5%92%8C-arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB">5.3. Collections 和 Arrays 工具类</a></li><li><a href="#54-%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F">5.4. 集合排序</a></li></ul></li><li><a href="#6-%E6%B3%9B%E5%9E%8B">6. 泛型</a><ul><li><a href="#61-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95-%E6%B3%9B%E5%9E%8B%E7%B1%BB-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">6.1. 泛型方法-泛型类-泛型接口</a></li><li><a href="#62-%E6%B3%9B%E5%9E%8B%E5%8F%8D%E5%B0%84">6.2. 泛型反射</a><ul><li><a href="#621-%E6%B3%9B%E5%9E%8B%E5%8F%8D%E5%B0%84-api">6.2.1. 泛型反射 api</a></li><li><a href="#622-%E6%A1%88%E4%BE%8B-%E4%BC%98%E5%8C%96-basedao">6.2.2. 案例-优化 BaseDao</a></li></ul></li></ul></li><li><a href="#7-%E6%B3%A8%E8%A7%A3">7. 注解</a><ul><li><a href="#71-%E8%AF%AD%E6%B3%95">7.1. 语法</a></li><li><a href="#72-%E5%85%83%E6%B3%A8%E8%A7%A3">7.2. 元注解</a></li><li><a href="#73-%E6%B3%A8%E8%A7%A3%E5%8F%8D%E5%B0%84">7.3. 注解反射</a></li><li><a href="#74-%E7%9C%8B%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%BC%98%E5%8C%96-dao-%E8%A7%A3%E5%86%B3%E5%AD%97%E6%AE%B5%E5%92%8C%E5%B1%9E%E6%80%A7%E4%B8%8D%E4%B8%80%E8%87%B4">7.4. 看一个例子优化 dao-解决字段和属性不一致</a><ul><li><a href="#741-%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E4%BC%98%E5%8C%96-javabean">7.4.1. 通过注解优化 JavaBean</a></li><li><a href="#742-%E6%B3%9B%E5%9E%8B%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96-basedao">7.4.2. 泛型反射优化 BaseDao</a></li><li><a href="#743-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%9C%E9%9B%86-handler">7.4.3. 自定义结果集 handler</a></li></ul></li></ul></li><li><a href="#8-io">8. io</a><ul><li><a href="#81-io%E6%80%BB%E7%BB%93">8.1. io总结</a></li><li><a href="#82-socket-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">8.2. socket 网络编程</a></li><li><a href="#83-%E9%98%BB%E5%A1%9E-io">8.3. 阻塞 io</a><ul><li><a href="#831-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E-io">8.3.1. 什么是阻塞 io</a></li><li><a href="#832-io-%E4%BD%93%E7%B3%BB%E7%9A%84%E6%95%B4%E4%B8%AA%E6%A6%82%E8%A7%88">8.3.2. io 体系的整个概览</a></li><li><a href="#833-paths-%E5%92%8C-files-%E7%9B%B8%E5%85%B3-api">8.3.3. Paths 和 Files 相关 api</a><ul><li><a href="#8331-paths-%E7%9A%84%E8%8E%B7%E5%8F%96%E8%BD%AC%E5%8C%96">8.3.3.1. Paths 的获取转化</a></li><li><a href="#8332-%E9%80%9A%E8%BF%87-files-paths-%E8%AF%BB%E5%8F%96%E5%86%99%E5%85%A5">8.3.3.2. 通过 Files Paths 读取写入</a></li><li><a href="#8333-%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9">8.3.3.3. 遍历文件夹</a></li><li><a href="#8334-%E9%80%9A%E8%BF%87-files-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">8.3.3.4. 通过 files 获取文件属性</a></li></ul></li><li><a href="#834-bio-tcp-%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1">8.3.4. bio tcp 实现通信</a></li></ul></li><li><a href="#84-%E9%9D%9E%E9%98%BB%E5%A1%9E-io">8.4. 非阻塞 io</a><ul><li><a href="#841-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E9%98%BB%E5%A1%9E-io">8.4.1. 什么是非阻塞 io</a></li><li><a href="#842-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E">8.4.2. 同步异步和阻塞非阻塞</a><ul><li><a href="#8421-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5">8.4.2.1. 同步与异步</a></li><li><a href="#8422-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E">8.4.2.2. 阻塞与非阻塞</a></li><li><a href="#8423-%E5%9B%9B%E7%A7%8D%E7%BB%84%E5%90%88">8.4.2.3. 四种组合</a></li></ul></li></ul></li><li><a href="#85-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-io-%E5%8D%B3-java-nio">8.5. 多路复用 IO 即 java nio</a><ul><li><a href="#851-%E8%A7%A3%E9%87%8A%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">8.5.1. 解释多路复用</a></li><li><a href="#852-nio-%E5%92%8C-io-%E5%8C%BA%E5%88%AB">8.5.2. nio 和 io 区别</a></li><li><a href="#853-linux-%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%94%AF%E6%8C%81">8.5.3. Linux 中的多路复用支持</a></li><li><a href="#854-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">8.5.4. 核心组件</a><ul><li><a href="#8541-%E7%90%86%E8%A7%A3">8.5.4.1. 理解</a></li><li><a href="#8542-channels">8.5.4.2. Channels</a></li><li><a href="#8543-buffers">8.5.4.3. Buffers</a></li><li><a href="#8544-selectors">8.5.4.4. Selectors</a></li></ul></li><li><a href="#855-nio-%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1">8.5.5. nio 实现网络通信</a></li></ul></li><li><a href="#86-java-aio">8.6. java aio</a></li><li><a href="#87-%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0">8.7. 断点续传</a></li></ul></li><li><a href="#9-%E4%BB%A3%E7%90%86">9. 代理</a></li><li><a href="#10-java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">10. Java 内存模型</a></li><li><a href="#11-java8">11. java8</a><ul><li><a href="#111-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5fp">11.1. 函数式编程的概念FP</a></li><li><a href="#112-java8-%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">11.2. Java8 添加的新特性</a><ul><li><a href="#1121-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95">11.2.1. 接口默认方法</a></li><li><a href="#1122-functionalinterface-%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3">11.2.2. @FunctionalInterface-函数接口</a></li><li><a href="#1123-%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8">11.2.3. 方法的引用</a></li><li><a href="#1124-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">11.2.4. Lambda 表达式</a><ul><li><a href="#11241-lambda-%E4%BB%8B%E7%BB%8D">11.2.4.1. lambda 介绍</a></li><li><a href="#11242-lambda-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98">11.2.4.2. Lambda 作用域问题</a><ul><li><a href="#112421-%E8%AE%BF%E9%97%AE%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">11.2.4.2.1. 访问局部变量</a></li><li><a href="#112422-%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">11.2.4.2.2. 访问成员变量</a></li><li><a href="#112423-%E8%AE%BF%E9%97%AE%E9%BB%98%E8%AE%A4%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95">11.2.4.2.3. 访问默认接口方法</a></li></ul></li></ul></li></ul></li><li><a href="#113-java8-%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%B5%81">11.3. java8 中的并行流</a><ul><li><a href="#1131-%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE">11.3.1. 使用并行过滤数据</a></li><li><a href="#1132-%E4%BB%8E%E9%9B%86%E5%90%88%E5%BE%97%E5%88%B0%E5%B9%B6%E8%A1%8C%E6%B5%81">11.3.2. 从集合得到并行流</a></li><li><a href="#1133-%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F-%E7%BB%99%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC">11.3.3. 并行排序-给数组赋值</a></li></ul></li><li><a href="#114-completablefuture-%E6%8E%A5%E5%8F%A3-%E5%A2%9E%E5%BC%BA%E7%9A%84-future">11.4. CompletableFuture 接口-增强的 Future</a><ul><li><a href="#1141-java-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">11.4.1. java 异步编程</a></li><li><a href="#1142-%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">11.4.2. 原理介绍</a></li><li><a href="#1143-completablefuture-api">11.4.3. completablefuture api</a></li><li><a href="#1144-%E5%AE%8C%E6%88%90%E4%BA%86%E5%B0%B1%E9%80%9A%E7%9F%A5%E6%88%91-%E6%89%8B%E5%8A%A8%E5%A1%AB%E5%85%85%E7%BB%93%E6%9E%9C">11.4.4. 完成了就通知我-手动填充结果</a></li><li><a href="#1145-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1">11.4.5. 异步执行任务</a></li><li><a href="#1146-%E6%B5%81%E5%BC%8F%E8%B0%83%E7%94%A8%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA-function-%E5%92%8C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">11.4.6. 流式调用组合多个 function 和 异常处理</a></li><li><a href="#1147-%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA-completablefuture">11.4.7. 组合多个 CompletableFuture</a></li></ul></li><li><a href="#115-stampedlock-%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E6%94%B9%E8%BF%9B">11.5. StampedLock-读写锁的改进</a></li><li><a href="#116-longadder-%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E5%A2%9E%E5%BC%BA">11.6. LongAdder-原子类的增强</a></li><li><a href="#117-java8-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">11.7. java8 内置函数式接口</a><ul><li><a href="#1171-predicates%E8%B0%93%E8%AF%8D-%E6%96%AD%E5%AE%9A">11.7.1. Predicates谓词, 断定</a></li><li><a href="#1172-functions%E5%87%BD%E6%95%B0">11.7.2. Functions函数</a></li><li><a href="#1173-suppliers%E7%94%9F%E4%BA%A7%E8%80%85">11.7.3. Suppliers生产者</a></li><li><a href="#1174-consumers%E6%B6%88%E8%B4%B9%E8%80%85">11.7.4. Consumers消费者</a></li><li><a href="#1175-comparators%E6%AF%94%E8%BE%83%E5%99%A8">11.7.5. Comparators比较器</a></li><li><a href="#1176-optional">11.7.6. Optional</a></li></ul></li><li><a href="#118-streams%E7%AE%A1%E9%81%93">11.8. Streams管道</a><ul><li><a href="#1181-stream-%E4%BB%8B%E7%BB%8D">11.8.1. stream 介绍</a></li><li><a href="#1182-%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8-stream">11.8.2. 重复使用 stream</a></li><li><a href="#1183-map-%E5%92%8C-flatmap">11.8.3. map 和 flatMap</a></li><li><a href="#1184-%E5%8E%BB%E9%87%8D">11.8.4. 去重</a></li><li><a href="#1185-collect%E6%96%B9%E6%B3%95-%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E5%85%83%E7%B4%A0-%E5%88%86%E7%BB%84-%E5%8E%BB%E9%87%8D">11.8.5. collect方法 如何收集处理后的元素 分组 去重</a></li><li><a href="#1186-stream-%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">11.8.6. stream 中异常处理</a></li></ul></li><li><a href="#119-date-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E6%96%B0%E7%9A%84-api">11.9. date 时间日期新的 api</a><ul><li><a href="#1191-%E4%BB%8B%E7%BB%8D-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8">11.9.1. 介绍-为什么使用</a></li><li><a href="#1192-%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%84%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F-api">11.9.2. 使用新的时间日期 api</a></li><li><a href="#1193-%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6">11.9.3. 统计代码耗时</a></li></ul></li><li><a href="#1110-%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84-annotations">11.10. 可重复的 Annotations</a></li><li><a href="#1111-base64-%E7%BC%96%E7%A0%81">11.11. base64 编码</a></li><li><a href="#1112-map-%E6%98%A0%E5%B0%84%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95">11.12. map 映射的新方法</a></li></ul></li><li><a href="#12-java11">12. java11</a><ul><li><a href="#121-java-module">12.1. java module</a></li><li><a href="#122-jshell">12.2. jshell</a></li><li><a href="#123-var-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">12.3. var 类型推断</a></li><li><a href="#124-jdk-api-enhencement">12.4. jdk api enhencement</a></li><li><a href="#125-%E6%94%B9%E8%BF%9B-java-%E7%A8%8B%E5%BA%8F%E5%9C%A8-docker-%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0">12.5. 改进 java 程序在 docker 中的表现</a></li><li><a href="#126-%E6%96%B0%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8">12.6. 新的垃圾回收器</a></li></ul></li><li><a href="#13-classloader-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">13. classloader 类加载器</a><ul><li><a href="#131-classloader-%E7%9A%84%E6%A6%82%E5%BF%B5">13.1. classloader 的概念</a></li><li><a href="#132-%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84">13.2. 层级结构</a></li><li><a href="#133-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B-and-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F">13.3. 工作过程 and 双亲委派模式</a></li><li><a href="#134-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E6%89%93%E4%B9%B1%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84">13.4. 线程上下文类加载器-打乱层级结构</a></li><li><a href="#135-%E5%80%9F%E5%8A%A9-classloader-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E9%9A%94%E7%A6%BB">13.5. 借助 classloader 实现类隔离</a></li><li><a href="#136-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BC%82%E5%B8%B8">13.6. 类加载相关的异常</a></li><li><a href="#137-%E8%87%AA%E5%AE%9A%E4%B9%89-classloader%E5%8A%A0%E8%BD%BD%E7%BD%91%E7%BB%9C%E4%B8%8A%E7%9A%84-class">13.7. 自定义 classloader加载网络上的 class</a></li></ul></li><li><a href="#14-%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">14. 路径问题</a><ul><li><a href="#141-%E8%8E%B7%E5%8F%96-classpath-%E5%92%8C-%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">14.1. 获取 classpath 和 系统属性 环境变量</a></li></ul></li><li><a href="#15-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">15. 数据类型</a><ul><li><a href="#151-%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8C%83%E5%9B%B4">15.1. 各个数据类型的范围</a></li><li><a href="#152-double-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4">15.2. double 类型的加减乘除</a></li></ul></li><li><a href="#16-%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%91%BD%E4%BB%A4">16. 控制台命令</a><ul><li><a href="#161-%E6%89%93-jar-%E5%8C%85">16.1. 打 jar 包</a></li><li><a href="#162-%E7%94%9F%E6%88%90%E6%B3%A8%E9%87%8A%E6%96%87%E6%A1%A3-javadoc">16.2. 生成注释文档 javadoc</a></li><li><a href="#163-%E7%BC%96%E8%AF%91%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91">16.3. 编译和反编译</a></li></ul></li><li><a href="#17-%E9%87%8D%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1">17. 重要的对象</a><ul><li><a href="#171-object">17.1. Object</a></li><li><a href="#172-string">17.2. String</a></li></ul></li><li><a href="#18-%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E8%BE%91%E6%8A%80%E6%9C%AF">18. 字节码编辑技术</a><ul><li><a href="#181-javassist">18.1. javassist</a></li></ul></li><li><a href="#19-%E5%89%8D%E6%B2%BF">19. 前沿</a><ul><li><a href="#191-graalvm">19.1. graalvm</a></li><li><a href="#192-vertx">19.2. vertx</a></li><li><a href="#193-micronaut">19.3. Micronaut</a></li><li><a href="#194-quarkus">19.4. Quarkus</a></li></ul></li><li><a href="#20-%E6%8B%BE%E9%81%97">20. 拾遗</a><ul><li><a href="#201-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-regex">20.1. 正则表达式 regex</a></li><li><a href="#202-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A">20.2. 静态绑定和动态绑定</a></li><li><a href="#203-%E9%87%8D%E8%BD%BD-and-%E9%87%8D%E5%86%99">20.3. 重载 and 重写</a></li><li><a href="#204-java-%E5%80%BC%E4%BC%A0%E9%80%92-or-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92">20.4. java 值传递 or 引用传递</a></li><li><a href="#205-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-public-protect-default-private">20.5. 访问修饰符 public-protect-default-private</a></li><li><a href="#206-getcontextclassloadergetclassloader-%E5%8C%BA%E5%88%AB">20.6. getcontextclassloader&amp;getclassloader 区别</a></li><li><a href="#207-getter-%E5%92%8C-setter-%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89">20.7. getter 和 setter 存在的意义</a></li><li><a href="#208-%E4%B8%BA%E4%BB%80%E4%B9%88-service-%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E4%B9%9F%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3">20.8. 为什么 service 只有一个实现也需要一个接口</a></li><li><a href="#209-static-%E5%85%B3%E9%94%AE%E5%AD%97">20.9. static 关键字</a></li><li><a href="#2010-%E5%86%85%E9%83%A8%E7%B1%BB-or-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">20.10. 内部类 or 静态内部类</a><ul><li><a href="#20101-%E5%86%85%E9%83%A8%E7%B1%BB">20.10.1. 内部类</a></li><li><a href="#20102-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">20.10.2. 静态内部类</a></li></ul></li><li><a href="#2011-java-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F">20.11. Java 类初始化顺序</a></li><li><a href="#2012-random-%E9%9A%8F%E6%9C%BA%E6%95%B0">20.12. Random-随机数</a></li><li><a href="#2013-%E4%BD%8D%E8%BF%90%E7%AE%97">20.13. 位运算</a></li><li><a href="#2014-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%85%E5%90%8D%E9%83%BD%E5%B0%8F%E5%86%99">20.14. 为什么包名都小写</a></li><li><a href="#2015-%E5%A4%84%E7%90%86-unicode-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98">20.15. 处理 unicode 编码问题</a></li><li><a href="#2016-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%86%8D%E6%AC%A1%E8%B5%8B%E5%80%BC%E7%BB%99%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">20.16. 为什么成员变量再次赋值给局部变量</a></li><li><a href="#2017-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8D%E7%94%A8%E8%B5%8B%E5%80%BC%E8%80%8C%E5%AE%9A%E4%B9%89%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E8%B5%8B%E5%80%BC">20.17. 为什么定义成员变量不用赋值而定义局部变量必须赋值</a></li></ul></li><li><a href="#21-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE">21. 开源项目</a><ul><li><a href="#211-%E5%8D%9A%E5%AE%A2-cms-%E7%B3%BB%E7%BB%9F">21.1. 博客 cms 系统</a></li></ul></li></ul><h1>1. 各个版本</h1><ul><li><p>jdk5: 自动装箱/拆箱, 枚举, 静态导入(不实用), 可变长参数(&quot;String... params&quot;), 泛型, for-each 循环, 并发库(Concurrent)</p></li><li><p>jdk6: compiler api(动态编译运行文本形式的 Java 代码), console 增强(编写命令行程序, 不实用), Desktop 类(打开浏览器, 文件等等方法)和 SystemTray 类, Http server api, script engine</p></li><li><p>jdk7: switch 对 String 支持(枚举也支持), 创建泛型时的类型推断(从定义的变量推断构造函数中的泛型), 捕获多种异常(... catch (IOException | SQLException e) ...), 数值类型支持&quot;<!-- -->_<!-- -->&quot;(如定义 10s, 但是单位是毫秒: int mills = 10_000), try_auto_close_resource</p></li><li><p>jdk8: lambda express/函数式接口(@FunctionalInterface), 接口默认方法, 接口静态方法, base64 增强, Datetime 增强, Optional(防 null), Stream,</p></li></ul><p>long-term support: jdk8, 11, 17</p><h1>2. 注释</h1><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 下面这行会被执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // \u000d sysout(&quot;hehe&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>3. 反射(reflect)</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="31-反射的-api">3.1. 反射的 api<a href="#31-反射的-api" class="hash-link" aria-label="3.1. 反射的 api的直接链接" title="3.1. 反射的 api的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Class clazz1 = Class.forName(&quot;cn.itcast.reflect.Person&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Class clazz2 = Person.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Class clazz3 = new Person(110,&quot;狗娃&quot;).getClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Constructor[] constructors = clazz.getConstructors();// 获取公开的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Constructor[] constructors =  clazz.getDeclaredConstructors(); // 获取所有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Constructor constructor = clazz.getConstructor(int.class,String.class);// 指定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constructor.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Person p = (Person) constructor.newInstance(999,&quot;xiaoyu&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Method[] methods = clazz.getMethods();//公开的方法，但是不包含父类的方法, 没方法, 则返回一个长度为 0 的数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Method m =clazz.getDeclaredMethod(&quot;sleep&quot;,int.class);// 所有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Method m = clazz.getMethod(&quot;eat&quot;, int.class);//获取指定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m.invoke(null, 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Method m = clazz.getMethod(&quot;sum&quot;, int[].class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m.invoke(p,new int[]{12,5,9});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Field[] fields = clazz.getDeclaredFields();// 所有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Field field = clazz.getDeclaredField(&quot;id&quot;);// 指定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">field.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">field.set(p, 110);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">getDeclaredAnnotation //getDeclaredAnnotation（s）：返回直接存在于此元素上的所有注释, 忽略继承的注释</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">getAnnotation（s）：返回此元素上存在的所有注释</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="32-实现事件驱动机制">3.2. 实现事件驱动机制<a href="#32-实现事件驱动机制" class="hash-link" aria-label="3.2. 实现事件驱动机制的直接链接" title="3.2. 实现事件驱动机制的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*事件处理类*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class EventHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //事件源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Object sender;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //事件处理函数名称（用于反射）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String callback;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public EventHandler(Object sender, String callback){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.sender = sender;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.callback = callback;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //事件触发</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void emit(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class senderType = this.sender.getClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取并调用事件源sender的事件处理函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method method = senderType.getMethod(this.callback);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        method.invoke(this.sender);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e2.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*事件源*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Button(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*可以在此设置Button类的相关属性，比如名字等*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //事件处理函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onClick(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;you just clicked me!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*实现事件驱动机制*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Button b = new Button();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if(/*收到按钮点击信号*/){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EventHandler e = new EventHandler(b, &quot;onClick&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    e.emit();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>还有一种方式: 观察者模式</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/*事件类*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Event {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //与事件相关的事件处理函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ArrayList&lt;Callback&gt; callbackList;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //事件触发函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void emit(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(Callback cb : callbackList){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cb.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //注册事件处理函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public registerCallback(Callback cb){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        callbackList.add(cb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*事件处理函数类*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Callback {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public OnClick implements Callback {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;you just clicked me!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*实现事件驱动*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Event e = new Event();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//将OnClick事件处理函数注册到事件中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e.registerCallback(new OnClick()); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//触发事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e.emit();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>4. java 并发-多线程</h1><p>{% post_link java-concurrent 📚 java-concurrent-reading-note %}</p><p>(见 java-concurrent)</p><h1>5. 集合</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="51-集合的体系">5.1. 集合的体系<a href="#51-集合的体系" class="hash-link" aria-label="5.1. 集合的体系的直接链接" title="5.1. 集合的体系的直接链接">​</a></h2><p>(注: 集合和数组中存放的都是对象的引用而非对象本身;; 从集合中取出元素是作为 Object 取出, 除非泛型指定了类型)</p><ul><li><p>Collection 单列集合的根接口</p><ul><li><p>List 如果是实现了 List 接口的集合类， 具备的特点：有序，重复。</p><ul><li><p>ArraryList 底层 是使用了 Object 数组实现的，特点： 查询速度快，增删慢。(因为增删时候会涉及到数组扩容, 拷贝元素所以增删慢; 数组可以按照 index 查找元素, 所以查找快)</p></li><li><p>LinkedList 底层是使用了双向链表数据结构实现的， 特点： 查询速度慢，增删快。(增删只需要改变某一个元素的 next 引用使其指向下一个元素, 所以增删快; 查询时候需要一个个遍历, 所以查询慢)</p></li><li><p>Vector 实现与 ArrayList 是一致，但是是线程安全 的，操作效率低。</p></li></ul></li><li><p>Set 如果是实现了 Set 接口的集合类，具备的特点：无序，不可重复。</p><ul><li><p>HashSet 底层是基于 HashMap 实现 (哈希表)， 特点：存取速度快。【<!-- -->*<!-- -->】添加元素原理: 调用元素的 hashcode() 得到哈希码, 进而运算得到哈希表中的位置. <!-- -->[两种情况]<!-- --> 如果该位置还没有存任何元素, 那么直接存储; 如果该位置有元素了则调用元素的 equals() 和目标元素比对, <!-- -->[又分为两种情况]<!-- -->: 如果相同, 不允许存储; 如果不同, 就可以存储</p><ul><li>LinkedHashSet 内部使用 LindedHashMap, 有序, 不和重复</li></ul></li><li><p>TreeSet 底层是使用了红黑树（二叉树）数据结构实现的。 特点： 对集合中的元素进行排序存储. 元素必须是可比较的, 如果不可比较, 需要实现 Comparable 接口(另一种方法是在创建 Treeset 对象的时候传入比较器(自定义一个类实现 COmparator 接口), 推荐, 因为这种方式可以复用)</p></li></ul></li><li><p>Queue FIFO-先进先出</p><p>常用方法:</p><p>📌 add 增加一个元索 如果队列已满，则抛出一个 IIIegaISlabEepeplian 异常
📌 remove 移除并返回队列头部的元素 如果队列为空，则抛出一个 NoSuchElementException 异常
📌 element 返回队列头部的元素 如果队列为空，则抛出一个 NoSuchElementException 异</p><p>📌 offer 将元素追加到队列末尾并返回 true 如果队列已满，则返回 false
📌 poll 删除并返问队列头部的元素 如果队列为空，则返回 null
📌 peek 返回队列头部的元素不删除 如果队列为空，则返回 nul</p><p>📌 put 添加一个元素 如果队列满，则阻塞
📌 take 移除并返回队列头部的元素 如果队列为空，则阻塞</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  - Deque 双向队列, 子接口, 头尾都可以poll, offer; 如果将Deque限制为只能从一端入队和出队，则可实现栈的数据结构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - BlockingQueue 阻塞队列; 进出两端的thread会通过阻塞来实现平衡, 减少两边的处理速度差距</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul></li><li><p>Map key 唯一不可重复, value 可重复</p><ul><li><p>HashMap 📌 底层是一个 Entry 数组, 每个 entry 是一个链表, 存储时, 会根据 hashCode() 来决定在数组中的 index, 根据 equals() 决定 在该位置上链表中的位置; 📌 线程不同步, 解决方案有 Hashtable 或者 Collections.synchronizedMap(hashMap)，这两种方式基本都是对整个 hash 表结构做锁定操作的，这样在锁表的期间，别的线程就需要等待了，无疑性能不高。; 📌 Key 和 value 可以为 null;</p><ul><li>LinkedHashMap 基于哈希表但是内部也维持了一个双向链表,可以保持顺序(保留了插入顺序, 所以输出顺序和输入顺序相同)</li></ul></li><li><p>TreeMap 底层使用二叉树实现 可以根据键排序(默认升序) 【<!-- -->*<!-- -->】</p></li><li><p>HashTable 存储的内容是键值对(key-value)映射。它是线程安全的。它的 key、value 都不可以为 null</p><ul><li>Properties 键值对 String--String 如果使用了中文, 只能使用字符流, 不能使用字节流(因为字节流使用 iso8859-1 编码)</li></ul></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="52-读源码">5.2. 读源码<a href="#52-读源码" class="hash-link" aria-label="5.2. 读源码的直接链接" title="5.2. 读源码的直接链接">​</a></h2><p>references: <a href="http://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="noopener noreferrer">http://wiki.jikexueyuan.com/project/java-collection/hashmap.html</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="521-数组和链表区别">5.2.1. 数组和链表区别<a href="#521-数组和链表区别" class="hash-link" aria-label="5.2.1. 数组和链表区别的直接链接" title="5.2.1. 数组和链表区别的直接链接">​</a></h3><p>数组静态分配内存(即, 数组一旦定义就内存不可变动, 要修改就必须涉及到数组的复制)，链表动态分配内存；</p><p>数组在内存中连续，链表不连续；</p><p>数组利用下标定位，时间复杂度为 O(1)，链表通过遍历定位, 定位元素时间复杂度 O(n)；</p><p>数组插入或删除元素的时间复杂度 O(n)，链表的时间复杂度 O(1)。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="522-单链表和双链表区别">5.2.2. 单链表和双链表区别<a href="#522-单链表和双链表区别" class="hash-link" aria-label="5.2.2. 单链表和双链表区别的直接链接" title="5.2.2. 单链表和双链表区别的直接链接">​</a></h3><ul><li><p>为什么目前市场应用上单链表的应用要比双链表的应用要广泛的多呢？ 双链表节点需要多维护一个指针</p></li><li><p>存储效率: 单链表是 &quot;时间换空间&quot;, 双链表&quot;空间换时间&quot;, 比如: 考虑链表的 delete 操作:</p><ul><li><p>对于单链表, 先定位待删除 node, 得到待删除 node 的 pre_node, 修改 pre_node 的 next 指针;</p></li><li><p>而得到 pre_node y 有两种方法: 📌 定位 node_to_delete 时候一路保存它的前一个 node; 📌 定位到 node_to_delete 后重新遍历链表找到 这个 pre_node; 实际上 这两种方法的效率是一样的，指针的总的移动操作都会有 2<!-- -->*<!-- -->i 次。而如果用双向链表，则不需要定位 pre_node。因此指针总的移动操作为 i 次</p></li></ul></li><li><p>再考虑 find 操作: 可以借用二分法的思路，从 head（首节点）向后查找操作和 last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="523-hashmap">5.2.3. HashMap<a href="#523-hashmap" class="hash-link" aria-label="5.2.3. HashMap的直接链接" title="5.2.3. HashMap的直接链接">​</a></h3><p>HashMap对象的key、value值均可为null。 HahTable对象的key、value值均不可为null。</p><p>线程不安全体现在哪里? <a href="https://www.zhihu.com/question/28516433" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/28516433</a></p><p>TODO</p><p>jdk1.7 示意图: (<a href="https://www.draw.io/?lightbox=1&amp;highlight=0000ff&amp;edit=_blank&amp;layers=1&amp;nav=1&amp;title=Untitled%20Diagram.xml#R3Vrfb9s2EP5rCGwPDURRkqlHyVbWhxUo0AHbngbFYm2tsmjIdOL0r98df1hSJMdOaztZgCAmT8fj3XffHUUnhE1Xu9%2BafL38JAtREd8rdoTNiO%2FTwI%2FgAyWPRsKpZwSLpiysUiv4Un4XVujUtmUhNj1FJWWlynVfOJd1LeaqJ8ubRj701b7Kqr%2FrOl%2BIgeDLPK%2BG0j%2FLQi1tFP6klX8U5WLpdqZRbJ6scqdsI9ks80I%2BdEQsI2zaSKnMaLWbigrBc7iYdbcHnu4da0StTlngMnGfV1sbnHVMPbpoH5alEl%2FW%2BRznD5BRwtKlWlUwozCEENb4ZLVbYLZv7vJNOb%2BZV3Jb%2FAOQwaeye4hGid1BR%2Bk%2BfOCNkCuhmkdQsQtCLzRLLGUYswg%2BtAmIrWjZwT6ystymfLG33KICAwvMAZDCq4DE0pW8z%2B%2B0RVzTiE35vTuXKledOVSV6M5FUXanlvwdyRnSALDf9BNBPTZIBPXjYSYmwRkycTwRjdzWhUB9D0I%2BkpYzIEIdER0x%2BZCY1L8QM2kwiF8U0KrsVDZqKReyzquslaZ9hDpoiF2p%2FkIxpNjM%2FrZK%2FwqlHm0fzrdKgqi1%2FbuU6x6e6MLzaILHctvMrZYlkMqbhXBabBz0RlS5Ku%2F75n8GQfb2GAW97vUYFbw9PNjkNSvMOw7IT5TcZQuLDwsrvlJd8ZfwiF6nU%2Ft9HvmTIY%2F4CI3Cc9DohJPrzdIoHunPB6A%2BO4%2Fi%2FwGPvCvyiL59PGhwRTxOuL%2B82bqiYy8%2B4ZUKi77ozec6TPInP9ahWXgGPE645L06Hid2mrPgMey8WY02wpSEswE0EKTqx9%2B9vmJZrWVZK%2B2QscBSrKiNKS5ckFflooZxJb6iKUSuhLtxYsUKqy3dAN5lvfhDl96H4Dw4h4z1cGZBNMA5HMHZP0MHm5zQwOoiwW%2BtYDav8s2mnD%2B5t2FezMUtYtwJ8O5GbzzfzT%2BLpgTvRGPzcXrP6vYnPg7kEaCc7OQuZnf4jJzpnDSHbgLOhOmudpXf%2BdrrmCH2xJAJeWBIJ3Mf9mlfWQxP7Bpr5V0VEA1oH89w2KiCCxWQK5h3DbDPj3eoiwE8fFO4286%2FiXcG8b6ZuNdYf8jhSx0Co6dAVCECRXkPw4XSQRoRhF872cd8s%2FwErx7gRRaSNCFxqAeUcJ9kMeET%2FMkmJA5IwkkWkJQTiNQMkgQW9o51eBKhjdTDRWlKeKAlM5KEetEtjmGHZEZijo94rO2BzhTHuFWCq3zvm3j8YCIy3iW3JAUF%2BA2aU%2B0mGGHoJq4FHfAIDNKO%2FRDjeNbxnm2OkSdUuwPuR%2B1uFjvIRBe%2BjngE6CPYa1%2BmGC46nul9JziArTG4jPBwGIrYe91D6olkCXl12TDYw%2FKIpEwbzPSmIdrHGEPEL%2BFjqTNozVrT%2BAio4GsPp6jvTx2GkSYNGMnQIAZ169I%2BI1wbgQHsbsymSb0FGqMfnMQm9SlaR1Zk1umneexk%2F8l%2Bl8oQ1653Pd5HDFABX7BMqFYK0W%2BA%2BbnQ90DGyF1IMioD6fgvpiv%2B2poHS7g0QmNQf8hOMM%2BeIQe%2BkWl%2BjJADsuxrJnvDvUcSfcjSgWxfBH1DCK7LYobdoYXGMMYUfGQ148gpDDOil6SjoevWk6QuofoR9ineSb9zoN0aiklXCUoSknidLQYGXwbOezoVqdc%2FFYNo5FRkI8fiD3z5DtP2L9%2FmVbv9%2FwGW%2FQc%3D" target="_blank" rel="noopener noreferrer">online</a>)</p><p>当 Hash 碰撞严重时，在 bucket 上形成的链表会变的越来越长，这样在查询时的效率就会越来越低；时间复杂度为 O(N), 1.8 将 bucket 由原来的单纯 LinkedList 加入了 红黑树 的实现</p><p>jdk1.8 示意图:</p><p>初始容量</p><p>加载因子(Float loadFactor): 给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 <!-- -->*<!-- --> 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能</p><p>Fail-Fast 机制</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体; HashMap 底层就是一个数组结构，数组中的每一项又是一个链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会计算待存储entry 的 key 的 hash 来决定其在数组中的索引, 如果该位置为null则直接存储，如果不为null, 就遍历该位置的链表(bucket), 再比较待存储 entry的 key 和 链表中的 entry的 key(通过 equals 方法), 如果相等, 则覆盖, 遍历到链表末尾还不等则添加到末尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 扩容: 当 HashMap 中的元素个数超过数组大小 *loadFactor(默认0.75)时，就会进行数组扩容; int threshold = (int)(capacity * loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 默认情况下，数组大小为 16，那么当 HashMap 中元素个数超过 16*0.75=12 的时候，就把数组的大小扩展为 2*16=32，即扩大一倍; 所以创建 HashMap 最好指定容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 负载因子 loadFactor 衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表(即数组)的装填程度越高</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- fail-fast 机制是 java 集合(Collection)中的一种错误机制。 当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast 事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 例如：当某一个线程 A 通过 iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 原理: 这一策略在源码中的实现是通过 modCount 域(`transient int modCount;`) 在迭代器初始化过程中会将这个值赋给迭代器的 expectedModCount; 在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示已经有其他线程修改了 Map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public HashMap(int initialCapacity, float loadFactor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (initialCapacity &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            initialCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initialCapacity = MAXIMUM_CAPACITY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Find a power of 2 &gt;= initialCapacity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int capacity = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (capacity &lt; initialCapacity)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        capacity &lt;&lt;= 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.loadFactor = loadFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table = new Entry[capacity]; // 创建一个 Entry 数组; 每个 Entry 其实就是一个 key-value 对，它持有一个指向下一个元素的引用，这就构成了链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    init();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 存储</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //其允许存放 null 的 key 和 null 的 value，当其 key 为 null 时，调用putForNullKey方法，放入到table[0]的这个位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (key == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return putForNullKey(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //得到key的 hashcode ，其目的是为了尽可能的让键值对可以分布到不同的桶中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //根据上一步骤中求出的hash得到在数组中是索引i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = indexFor(hash, table.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果i处的Entry不为null，则通过其next指针不断遍历e元素的下一个元素。, 如果找到一个 entry, 他的 hash 匹配, key 也相同(equals), 替换 oldValue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { // 如果 key 存在了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            V oldValue = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.value = value; // 新的value替代 oldValue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.recordAccess(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 i 处的 entry==null, 或者 bucket遍历完了也没有找到相同 key 的 entry, 直接添加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modCount++; // 这个变量记录 map 修改次数, 实现 fail-fast 机制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addEntry(hash, key, value, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void addEntry(int hash, K key, V value, int bucketIndex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里完全没有考虑 Entry 中的 value，仅仅只是根据 key 来计算并决定每个 Entry 的存储位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当系统决定了 key 的存储位置之后，value 随之保存在那里即可。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resize(2 * table.length);  // 扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hash = (null != key) ? hash(key) : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bucketIndex = indexFor(hash, table.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    createEntry(hash, key, value, bucketIndex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void createEntry(int hash, K key, V value, int bucketIndex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取指定 bucketIndex 索引处的 Entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (key == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return getForNullKey();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null == entry ? null : entry.getValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final Entry&lt;K,V&gt; getEntry(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = (key == null) ? 0 : hash(key); // calculate hashCode according to key.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; // find element, traverse the bucket.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e != null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="524-hashset">5.2.4. HashSet<a href="#524-hashset" class="hash-link" aria-label="5.2.4. HashSet的直接链接" title="5.2.4. HashSet的直接链接">​</a></h3><p>几乎全部借助于 HashMap 来实现</p><p>所以也要重写 hashCode(), equals() 以确保元素唯一性</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- HashSet内部的数据结构就是一个 HashMap，其方法的内部几乎就是在调用 HashMap 的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////// field</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private transient HashMap&lt;E,Object&gt; map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 所有写入 map 的 value 值, key 则是 Hashset 中存储的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static final Object PRESENT = new Object();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////// 构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 默认的无参构造器，构造一个空的HashSet。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public HashSet() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map = new HashMap&lt;E,Object&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public HashSet(int initialCapacity, float loadFactor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 构造一个包含指定 collection 中的元素的新set。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 实际底层使用默认的加载因子0.75和足以包含指定 collection 中所有元素的初始容量来创建一个H ashMap。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param c 其中的元素将存放在此 set 中的collection。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public HashSet(Collection&lt;? extends E&gt; c) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addAll(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 以指定的initialCapacity 和 loadFactor 构造一个空的 HashSet。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 实际底层以相应的参数构造一个空的HashMap。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param initialCapacity 初始容量。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param loadFactor 加载因子。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public HashSet(int initialCapacity, float loadFactor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 以指定的 initialCapacity 构造一个空的 HashSet。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param initialCapacity 初始容量。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public HashSet(int initialCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map = new HashMap&lt;E,Object&gt;(initialCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。此构造函数为包访问权限，不对外公开，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 实际只是是对LinkedHashSet的支持。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param initialCapacity 初始容量。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param loadFactor 加载因子。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param dummy 标记。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HashSet(int initialCapacity, float loadFactor, boolean dummy) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////// 添加方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">由于 HashMap 的 put() 方法添加 key-value 对时，当新放入 HashMap 的 key 与原有 key 相同（hashCode()返回值相等，通过 equals 比较也返回 true），新添加的 Entry 的 value 将覆盖原来 Entry 的 value（也就是 HashSet 中的 value , 都是PRESENT），但 key 不会有任何改变，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">因此如果向 HashSet 中添加一个已经存在的元素时，新添加的集合元素将不会被放入 HashMap中，原来的元素也不会有任何改变，这也就满足了 Set 中元素不重复的特性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @param e 将添加到此set中的元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @return 如果此set尚未包含指定元素，则返回true。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public boolean add(E e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //将存放的对象当做了 HashMap 的健，value 都是相同的 PRESENT 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //由于 HashMap 的 key 是不能重复的，所以每当有重复的值写入到 HashSet 时, 也就是 hashmap 中的 key 重复了，那么 value 会被覆盖，但 key 不会受到影响，这样就保证了 HashSet 中只能存放不重复的元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return map.put(e, PRESENT)==null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="525-hashtable">5.2.5. HashTable<a href="#525-hashtable" class="hash-link" aria-label="5.2.5. HashTable的直接链接" title="5.2.5. HashTable的直接链接">​</a></h3><p>同步的 hashmap, key, value 不允许为 null</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 和 HashMap 一样，Hashtable 也是一个散列表，它存储的内容是键值对</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Hashtable 与 HashMap 的简单比较</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -(Dictionary 是任何可将键映射到相应值的类的抽象父类, 过时了)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - HashMap 的 key 和 value 都允许为 null，而 Hashtable 的 key 和 value 都不允许为 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - Hashtable 方法是同步，而HashMap则不是</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 成员变量 和 HashMap 类似 table, count, threshold, loadFactor, modCount。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 构造方法大同小异, 默认构造函数，容量为 11，加载因子为 0.75</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 添加 线程安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">整个过程:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 判断 value 是否为空，为空则抛出异常；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 计算 key 的 hash 值，并根据 hash 值获得 key 在 table 数组中的位置 index，如果 table[index] 元素不为空，则进行迭代，如果遇到相同的 key，则直接替换，并返回旧 value；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- table[index] 为空，我们可以将其插入到 table[index] 位置。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Make sure the value is not null确保value不为null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Makes sure the key is not already in the hashtable.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //确保key不在hashtable中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //首先，通过hash方法计算key的哈希值，并计算得出index值，确定其在table[]中的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //其次，迭代index索引位置的链表，如果该位置处的链表存在相同的key，则替换value，返回旧的value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry tab[] = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            V old = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return old;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (count &gt;= threshold) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Rehash the table if the threshold is exceeded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果超过阀值，就进行rehash操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rehash();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hash = hash(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Creates the new entry.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //将值插入，返回的为null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry&lt;K,V&gt; e = tab[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建新的Entry节点，并将新的Entry插入Hashtable的index位置，并设置e为新的Entry的下一个元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// get 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry tab[] = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key); // calculate hashCode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index = (hash &amp; 0x7FFFFFFF) % tab.length; //calculate index</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) { //遍历链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="526-linkedhashmap">5.2.6. LinkedHashMap<a href="#526-linkedhashmap" class="hash-link" aria-label="5.2.6. LinkedHashMap的直接链接" title="5.2.6. LinkedHashMap的直接链接">​</a></h3><p>可以排序的 hashmap</p><p>由一个双向链表所构成, 保证了有序 (在 hashmap 内部的 entry 基础上添加了 &quot;Entry&lt;K,V&gt; before, after;&quot; 构成了双向链表, )</p><p>排序模式: 通过 <code>accessOrder</code> 控制</p><ul><li><p>根据写入顺序排序(默认)</p></li><li><p>根据访问顺序排序 - 每次 get 都会将访问的值移动到链表末尾，这样重复操作就能得到一个按照访问顺序排序的链表。可以利用这个特性, 用 LinkedHashMap 构建 LRU 缓存</p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- LinkedHashMap 是 HashMap 的一个子类，它保留插入的顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 允许使用 null 值和 null 键</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- LinkedHashMap 实现与 HashMap 的不同之处在于，LinkedHashMap 维护着一个双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序(即调用 get() 后，会将这次访问的元素移至链表 尾部，不断访问可以形成按访问顺序排序的链表。)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 成员变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final boolean accessOrder; //如果为true，则按照访问顺序；如果为false，则按照插入顺序。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private transient Entry&lt;K,V&gt; header;// the head(eldest) of the doubly linked list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private transient Entry&lt;K,V&gt; tail;// the tail(youngest) of the doubly linked list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* LinkedHashMap的Entry元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。新版本有变化了, 继承 Node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry&lt;K,V&gt; before, after;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ……</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 初始化/构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public LinkedHashMap(int initialCapacity, float loadFactor,boolean accessOrder) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    super(initialCapacity, loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.accessOrder = accessOrder;//默认为 false，代表按照插入顺序进行迭代；当然可以显式设置为 true，代表以访问顺序进行迭代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 存储方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LinkedHashMap 并未重写父类 HashMap 的 put 方法，而是重写了父类 HashMap 的 put 方法调用的子方法void recordAccess(HashMap m) ，void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)，提供了自己特有的双向链接列表的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// get 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LinkedHashMap 重写了父类 HashMap 的 get 方法，实际在调用父类 getEntry() 方法取得查找的元素后，再判断当排序模式 accessOrder 为 true 时，记录访问顺序，将最新访问的元素添加到双向链表的表头，并从原来的位置删除。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// LRU 是 Least Recently Used 的缩写, 最近最少使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// LinkedHashMap 本身已经实现了按照访问顺序的存储，也就是说，最近读取的会放在最前面，最最不常读取的会放在最后;LinkedHashMap 本身有一个方法用于判断是否需要移除最不常读取的数，但是，原始方法默认不需要移除（这是，LinkedHashMap 相当于一个linkedlist），所以，我们需要 override 这样一个方法，使得当缓存里存放的数据个数超过规定个数后，就把最不常用的移除掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * An LRU cache, based on &lt;code&gt;LinkedHashMap&lt;/code&gt;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * &lt;p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * This cache has a fixed maximum number of elements (&lt;code&gt;cacheSize&lt;/code&gt;).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * If the cache is full and another entry is added, the LRU (least recently</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * used) entry is dropped.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * &lt;p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * This class is thread-safe. All methods of this class are synchronized.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * &lt;p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Author: Christian d&#x27;Heureuse, Inventec Informatik AG, Zurich, Switzerland&lt;br&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Multi-licensed: EPL / LGPL / GPL / AL / BSD.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class LRUCache&lt;K, V&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final float hashTableLoadFactor = 0.75f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private LinkedHashMap&lt;K, V&gt; map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int cacheSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Creates a new LRU cache. 在该方法中，new LinkedHashMap&lt;K,V&gt;(hashTableCapacity,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * hashTableLoadFactor, true)中，true代表使用访问顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param cacheSize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *            the maximum number of entries that will be kept in this cache.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public LRUCache(int cacheSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.cacheSize = cacheSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int hashTableCapacity = (int) Math</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .ceil(cacheSize / hashTableLoadFactor) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map = new LinkedHashMap&lt;K, V&gt;(hashTableCapacity, hashTableLoadFactor,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // (an anonymous inner class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            private static final long serialVersionUID = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return size() &gt; LRUCache.this.cacheSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Retrieves an entry from the cache.&lt;br&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The retrieved entry becomes the MRU (most recently used) entry.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *            the key whose associated value is to be returned.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the value associated to this key, or null if no value with this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *         key exists in the cache.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized V get(K key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return map.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Adds an entry to this cache. The new entry becomes the MRU (most recently</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * used) entry. If an entry with the specified key already exists in the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * cache, it is replaced by the new entry. If the cache is full, the LRU</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * (least recently used) entry is removed from the cache.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *            the key with which the specified value is to be associated.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *            a value to be associated with the specified key.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.put(key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Clears the cache.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void clear() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Returns the number of used entries in the cache.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the number of entries currently in the cache.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized int usedEntries() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return map.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Returns a &lt;code&gt;Collection&lt;/code&gt; that contains a copy of all cache</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * entries.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return a &lt;code&gt;Collection&lt;/code&gt; with a copy of the cache content.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized Collection&lt;Map.Entry&lt;K, V&gt;&gt; getAll() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ArrayList&lt;Map.Entry&lt;K, V&gt;&gt;(map.entrySet());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Test routine for the LRUCache class.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LRUCache&lt;String, String&gt; c = new LRUCache&lt;String, String&gt;(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c.put(&quot;1&quot;, &quot;one&quot;); // 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c.put(&quot;2&quot;, &quot;two&quot;); // 2 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c.put(&quot;3&quot;, &quot;three&quot;); // 3 2 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c.put(&quot;4&quot;, &quot;four&quot;); // 4 3 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (c.get(&quot;2&quot;) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Error(); // 2 4 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c.put(&quot;5&quot;, &quot;five&quot;); // 5 2 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c.put(&quot;4&quot;, &quot;second four&quot;); // 4 5 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Verify cache content.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (c.usedEntries() != 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Error();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!c.get(&quot;4&quot;).equals(&quot;second four&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Error();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!c.get(&quot;5&quot;).equals(&quot;five&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Error();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!c.get(&quot;2&quot;).equals(&quot;two&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Error();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // List cache content.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Map.Entry&lt;String, String&gt; e : c.getAll())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(e.getKey() + &quot; : &quot; + e.getValue());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="527-treemap">5.2.7. TreeMap<a href="#527-treemap" class="hash-link" aria-label="5.2.7. TreeMap的直接链接" title="5.2.7. TreeMap的直接链接">​</a></h3><p>基于红黑树的可排序 hashmap</p><p>遍历和增加删除的的效率都是O(logN)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="528-lindedhashset">5.2.8. LindedHashSet<a href="#528-lindedhashset" class="hash-link" aria-label="5.2.8. LindedHashSet的直接链接" title="5.2.8. LindedHashSet的直接链接">​</a></h3><p>有序的 hashset</p><p>继承 HashSet、又基于 LinkedHashMap 来实现的</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 与HashSet 的不同之处在于，LinkedHashSet 维护着一个双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="529-arraylist-和-vector">5.2.9. ArrayList 和 Vector<a href="#529-arraylist-和-vector" class="hash-link" aria-label="5.2.9. ArrayList 和 Vector的直接链接" title="5.2.9. ArrayList 和 Vector的直接链接">​</a></h3><p>最重要的两个属性分别是: <code>elementData</code> 数组，以及 <code>size</code> 大小, 添加元素时候 首先进行 <code>扩容校验</code>, 如果容量不够了, 会进行数组的复制. 另外在添加元素到指定位置时也有数组的复制. 所以<code>使用时最好是指定大小</code>, <code>减少在指定位置插入数据的操作</code></p><p>实现于下面 2 个接口</p><ul><li><p>List 接口</p></li><li><p>RandomAccess 接口: 标记接口, 表示可以快速随机访问(通过元素的序号快速获取元素对象)</p></li></ul><p>Fail-Fast 机制: 多个线程竞争访问会报错</p><p>由于 ArrayList 是基于数组实现的，所以<code>并不是所有的空间都被使用</code>。因此使用了 transient 修饰，可以防止被自动序列化, 因此 <code>ArrayList 自定义了序列化与反序列化</code></p><p>Vector 底层数据结构和 ArrayList 类似,也是一个动态数组存放数据。不过是在 add() 方法的时候使用 synchronized 进行同步写数据，但是开销较大，所以 Vector 是一个同步容器并不是一个并发容器。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 它实现 List 接口、底层使用数组保存所有元素。其操作基本上是对数组的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 成员变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private transient Object[] elementData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 添加 有多种方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public E set(int index, E element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rangeCheck(index);//检查是否超出数组范围, 如果超出, 抛异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    E oldValue = elementData(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    elementData[index] = element;// replace</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void rangeCheck(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (index &gt;= size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * Appends the specified element to the end of the list.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @param e element to be appended to this list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public boolean add(E e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //扩容校验。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    elementData[size++] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void ensureCapacityInternal(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // overflow-conscious code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (minCapacity - elementData.length &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        grow(minCapacity); //当容量不足时，会调用 grow 方法增长容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void grow(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // overflow-conscious code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldCapacity = elementData.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (newCapacity - minCapacity &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newCapacity = minCapacity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newCapacity = hugeCapacity(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // minCapacity is usually close to size, so this is a win:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 数组复制,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> public void add(int index, E element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rangeCheckForAdd(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //复制，向后移动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.arraycopy(elementData, index, elementData, index + 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        size - index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    elementData[index] = element;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public E get(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rangeCheck(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (E) elementData[index];// returns the element at the specified position of the list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void rangeCheck(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (index &gt;= size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 调整数组容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">开发者可以通过一个 public 的方法ensureCapacity(int minCapacity)来增加 ArrayList 的容量，而在存储元素等操作过程中，如果遇到容量不足，会调用priavte方法private void ensureCapacityInternal(int minCapacity)实现。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> public void ensureCapacity(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (minCapacity &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ensureCapacityInternal(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void ensureCapacityInternal(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // overflow-conscious code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (minCapacity - elementData.length &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        grow(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * Increases the capacity to ensure that it can hold at least the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * number of elements specified by the minimum capacity argument.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @param minCapacity the desired minimum capacity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void grow(int minCapacity) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // overflow-conscious code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldCapacity = elementData.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //每次数组容量的增长大约是其原容量的 1.5 倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (newCapacity - minCapacity &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newCapacity = minCapacity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newCapacity = hugeCapacity(minCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // minCapacity is usually close to size, so this is a win:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5210-linkedlist">5.2.10. LinkedList<a href="#5210-linkedlist" class="hash-link" aria-label="5.2.10. LinkedList的直接链接" title="5.2.10. LinkedList的直接链接">​</a></h3><p>单向链表</p><p>LinkedList 插入，删除都是移动指针效率很高。</p><p>查找需要进行遍历查询，效率较低, 特别是当 index 越接近 size 的中间值时尤其低</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- LinkedList 是基于链表实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 成员变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">transient int size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">transient Node&lt;E&gt; first; //链表的头指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">transient Node&lt;E&gt; last; //尾指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//存储对象的结构 Node, LinkedList的内部类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static class Node&lt;E&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    E item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;E&gt; next; // 指向下一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;E&gt; prev; //指向上一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.item = element;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.next = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.prev = prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 核心方法 linkBefore、linkLast</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 添加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public boolean add(E e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    linkLast(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* Links e as last element.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void linkLast(E e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Node&lt;E&gt; l = last;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    last = newNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (l == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        first = newNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        l.next = newNode; // 仅仅是指针的移动, 添加效率高</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 查询</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public E get(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    checkElementIndex(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return node(index).item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Node&lt;E&gt; node(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // assert isElementIndex(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果小于 size的一半, 就从节点头部遍历, 否则就从节点尾部开始遍历。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (index &lt; (size &gt;&gt; 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; x = first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; index; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            x = x.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;E&gt; x = last;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = size - 1; i &gt; index; i--)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            x = x.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5211-concurrenthashmap">5.2.11. ConcurrentHashMap<a href="#5211-concurrenthashmap" class="hash-link" aria-label="5.2.11. ConcurrentHashMap的直接链接" title="5.2.11. ConcurrentHashMap的直接链接">​</a></h3><p>ref: <a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener noreferrer">https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/</a></p><p><a href="https://github.com/ben-manes/concurrentlinkedhashmap" target="_blank" rel="noopener noreferrer">一个 concurrentlinkedhashmap 实现</a></p><p>面试套路:</p><ul><li>谈谈你理解的 HashMap，讲讲其中的 get put 过程。</li><li>1.8 做了什么优化？</li><li>是线程安全的嘛？</li><li>不安全会导致哪些问题？</li><li>如何解决？有没有线程安全的并发容器？</li><li>ConcurrentHashMap 是如何实现的？ 1.7、1.8 实现有何不同？为什么这么做？
替换了锁的实现吧, 使用了 synchronized 和 cas 操作吧, 因为 新版本 synchronize 做了很多优化, 性能已经不输reentrantLock</li></ul><p>针对并发场景的 hashmap, 比 hashtable 并发效率更高</p><p>修改操作: 锁定的 Segment 而不是整个 ConcurrentHashMap, 更新操作只是在这个 Segment 中完成，所以并不需要对整个 ConcurrentHashMap 加锁, 此时，其他的线程也可以对另外的 Segment 进行 put 操作
读操作就更没什么影响了</p><p>Segment 数据结构</p><p>整个 ConcurrentHashMap 数据结构</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 数据结构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 成员变量中，包含了一个 Segment 的数组（final Segment&lt;K,V&gt;[] segments;），而 Segment 是 ConcurrentHashMap 的内部类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 在 Segment 这个类中，包含了一个 HashEntry 的数组（transient volatile HashEntry&lt;K,V&gt;[] table;）。而 HashEntry 也是 ConcurrentHashMap 的内部类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - HashEntry 中，包含了 key 和 value 以及 next 指针（类似于 HashMap 中 Entry），所以 HashEntry 可以构成一个链表。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- ConcurrentHashMap 和 HashTable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 相比于 HashTable 和用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在前两者中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- ConcurrentHashMap 的高并发性主要来自于三个方面: (由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 用分离锁实现多个线程间的更深层次的共享访问。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 用 HashEntery 对象的不变性(final修饰)来降低执行读操作的线程在遍历链表期间对加锁的需求。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// HashEntry 存储键值对的过程中，散列的时候如果发生“碰撞”，将把碰撞的 HashEntry 对象链接成一个链表。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final class HashEntry&lt;K,V&gt; {//类比着 HashMap 中的 Entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final int hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final K key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile V value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile HashEntry&lt;K,V&gt; next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.hash = hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.key = key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.next = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Segment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 继承于 ReentrantLock 类，从而使得 Segment 对象可以充当锁的角色</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Segment 数据结构类似于 HashMap了，都是包含了一个数组，而数组中的元素可以是一个链表。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * Segments are specialized versions of hash tables.  This</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * subclasses from ReentrantLock opportunistically, just to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * simplify some locking and avoid separate construction.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * The per-segment table. Elements are accessed via</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * entryAt/setEntryAt providing volatile semantics.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transient volatile HashEntry&lt;K,V&gt;[] table;//Segment 中包含HashEntry 的数组; 使得 segment 可以可以守护其包含的若干个桶（HashEntry数组中的每个Hashentry元素即为一个 桶）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * The number of elements. Accessed only either within locks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * or among other volatile reads that maintain visibility.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transient int count;//count 变量是计算器，表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 的链表); 之所以在每个Segment对象中包含一个 count 计数器，而不在 ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响并发性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transient int modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 装载因子</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final float loadFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 并发写操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * Maps the specified key to the specified value in this table.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * Neither the key nor the value can be null.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * with a key that is equal to the original key.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @param key key with which the specified value is to be associated</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @param value value to be associated with the specified key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @throws NullPointerException if the specified key or value is null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Segment&lt;K,V&gt; s;//首先有一个 Segment 的引用 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = hash(key);//hash() 方法对 key 进行计算</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s = ensureSegment(j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return s.put(key, hash, value, false);//调用 Segment 的 put(K key, int hash, V value, boolean onlyIfAbsent)方法进行存储操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Segment 的 put 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final V put(K key, int hash, V value, boolean onlyIfAbsent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //加锁，这里是锁定的Segment而不是整个ConcurrentHashMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //因为 put 操作只是在这个 Segment 中完成，所以并不需要对整个 ConcurrentHashMap 加锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //所以，此时，其他的线程也可以对另外的 Segment 进行 put 操作，因为虽然该 Segment 被锁住了，但其他的 Segment 并没有加锁。同时，读线程并不会因为本线程的加锁而阻塞。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashEntry&lt;K,V&gt; node = tryLock() ? null :scanAndLockForPut(key, hash, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    V oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt;[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //得到hash对应的table中的索引index</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = (tab.length - 1) &amp; hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //找到hash对应的是具体的哪个桶，也就是哪个HashEntry链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (HashEntry&lt;K,V&gt; e = first;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((k = e.key) == key ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (e.hash == hash &amp;&amp; key.equals(k))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    oldValue = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (!onlyIfAbsent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (node != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    node.setNext(first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int c = count + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rehash(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setEntryAt(tab, index, node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ++modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count = c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                oldValue = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //解锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="53-collections-和-arrays-工具类">5.3. Collections 和 Arrays 工具类<a href="#53-collections-和-arrays-工具类" class="hash-link" aria-label="5.3. Collections 和 Arrays 工具类的直接链接" title="5.3. Collections 和 Arrays 工具类的直接链接">​</a></h2><p>Collections 方法:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1，对list进行二分查找：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">前提该集合一定要有序。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int binarySearch(list,key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int binarySearch(list,key,Comparator);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2，对list集合进行排序。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sort(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sort(list,comaprator);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//按照指定比较器进行排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3，对集合取最大值或者最小值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max(Collection)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max(Collection,comparator)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">min(Collection)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">min(Collection,comparator)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4，对list集合进行反转。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reverse(list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8，可以将不同步的集合变成同步的集合。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Set synchronizedSet(Set&lt;T&gt; s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map synchronizedMap(Map&lt;K,V&gt; m)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List synchronizedList(List&lt;T&gt; list)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9.如果想要将集合变数组：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">可以使用Collection 中的toArray 方法。注意：是Collection不是Collections工具类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">传入指定的类型数组即可，该数组的长度最好为集合的size。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10. 返回 空集合 节省内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过java.util.Collections.emptyList()方法的相关源码可以得知它实际上就是返回了一个空的List，但是这个List和我们平时常用的那个List是不一样的。这个方法返回的List是Collections类的一个静态内部类，它继承AbstractList后并没有实现add()、remove()等方法，因此这个返回值List并不能增加删除元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">既然这个List不能进行增删操作，那么它有何意义呢？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这个方法主要目的就是返回一个不可变的列表，使用这个方法作为返回值就不需要再创建一个新对象，可以减少内存开销。并且返回一个size为0的List，调用者不需要校验返回值是否为null，所以建议使用这个方法返回可能为空的List。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">emptySet()、emptyMap()方法同理。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Arrays 方法:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1，二分查找,数组需要有序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">binarySearch(int[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">binarySearch(double[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2，数组排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sort(int[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sort(char[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 复制数组。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">copyOf(oldArray，newLength);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 复制部分数组。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">copyOfRange(oldArray，startIndex，endIndex)    这里不包括endIndex对应值；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4，比较两个数组对应位置的元素是否一致。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">equals(int[],int[]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5，将数组变成集合。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List asList(T[]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这样可以通过集合的操作来操作数组中元素，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但是不可以使用增删方法，add，remove。因为数组长度是固定的，会出现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UnsupportOperationExcetion。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">可以使用的方法：contains，indexOf。。。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果数组中存入的基本数据类型，那么asList会将数组实体作为集合中的元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果数组中的存入的引用数据类型，那么asList会将数组中的元素作为集合中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">的元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6. 将数组变成字符串。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">toString(int[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="54-集合排序">5.4. 集合排序<a href="#54-集合排序" class="hash-link" aria-label="5.4. 集合排序的直接链接" title="5.4. 集合排序的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         List&lt;Boolean&gt; arr = Arrays.asList(true, false, false, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr.sort((o1, o2) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((o1 &amp;&amp; o2) || (!o1 &amp;&amp; !o2)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return o2 ? 1 : -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // return o1 ? -1 : 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // if (onLine1 ^ onLine2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //     return onLine1 ? -1 : 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Arrays.toString(arr.toArray())); // true 在前, false 在后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>6. 泛型</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="61-泛型方法-泛型类-泛型接口">6.1. 泛型方法-泛型类-泛型接口<a href="#61-泛型方法-泛型类-泛型接口" class="hash-link" aria-label="6.1. 泛型方法-泛型类-泛型接口的直接链接" title="6.1. 泛型方法-泛型类-泛型接口的直接链接">​</a></h2><ul><li><p>泛型方法中 的自定义泛型的具体数据类型是在<code>调用该函数的时候传入实参时</code>确定的</p></li><li><p>泛型类上的自定义泛型是在<code>使用该类创建对象的时候</code> 确定具体的数据类型的</p></li><li><p>泛型接口上的自定义泛型是在<code>实现该接口的时候</code>指定具体数据类型的 - 如果需要<code>延迟确定接口泛型</code>的具体类型, 在创建接口实现类对象的时候才指定接口上自定义泛型，那么需要以下格式：<code>class&lt;T&gt; 类名 implements 接口&lt;T&gt;</code></p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="62-泛型反射">6.2. 泛型反射<a href="#62-泛型反射" class="hash-link" aria-label="6.2. 泛型反射的直接链接" title="6.2. 泛型反射的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="621-泛型反射-api">6.2.1. 泛型反射 api<a href="#621-泛型反射-api" class="hash-link" aria-label="6.2.1. 泛型反射 api的直接链接" title="6.2.1. 泛型反射 api的直接链接">​</a></h3><p>ParameterizedType 参数化类型, 比如: <code>ArrayList&lt;String&gt;</code>;</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// baseDao类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class BaseDao&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前运行类的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Class&lt;T&gt; clazz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 表名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String tableName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 主键</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String id_primary;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 拿到当前运行类的参数化类型中实际的类型  ( BaseDao&lt;Admin&gt; ,  Admin.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BaseDao(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //**获取parent的参数化类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Type type = this.getClass().getGenericSuperclass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ParameterizedType pt = (ParameterizedType) type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Type[] types = pt.getActualTypeArguments();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        clazz = (Class&lt;T&gt;) types[0];//到此, 已经拿到：  Admin.class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*******1. 获取表名*******/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Table table = clazz.getAnnotation(Table.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tableName = table.tableName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*******2. 获取主键字段*******/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取当前运行类的所有字段、遍历、获取每一个字段上的id注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Field[] fs = clazz.getDeclaredFields();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Field f : fs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 设置强制访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            f.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取每一个字段上的id注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Id anno_id = f.getAnnotation(Id.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (anno_id != null) {// 不为null, 证明时主键字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Column column = f.getAnnotation(Column.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                id_primary = column.columnName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 跳出循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;表：&quot; + tableName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;主键：&quot; + id_primary);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T findById(int id){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String sql = &quot;select * from &quot; + tableName + &quot; where &quot; + id_primary +&quot;=?&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * DbUtils的已经封装好的工具类：BeanHandler?   属性=字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return JdbcUtils.getQueryRunner().query(sql, new BeanHandler&lt;T&gt;(clazz), id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;T&gt; getAll(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String sql = &quot;select * from &quot; + tableName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return JdbcUtils.getQuerrRunner().query(sql, new BeanListHandler&lt;T&gt;(clazz));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="622-案例-优化-basedao">6.2.2. 案例-优化 BaseDao<a href="#622-案例-优化-basedao" class="hash-link" aria-label="6.2.2. 案例-优化 BaseDao的直接链接" title="6.2.2. 案例-优化 BaseDao的直接链接">​</a></h3><p>见 <a href="#%E7%9C%8B%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%BC%98%E5%8C%96dao-%E8%A7%A3%E5%86%B3%E5%AD%97%E6%AE%B5%E5%92%8C%E5%B1%9E%E6%80%A7%E4%B8%8D%E4%B8%80%E8%87%B4">注解反射</a></p><h1>7. 注解</h1><p><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/briblue/article/details/73824058</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="71-语法">7.1. 语法<a href="#71-语法" class="hash-link" aria-label="7.1. 语法的直接链接" title="7.1. 语法的直接链接">​</a></h2><p>注解成员属性类型:</p><ul><li><p>所有基本类型</p></li><li><p>String</p></li><li><p>Class</p></li><li><p>Enum</p></li><li><p>Annotation</p></li><li><p>以上类型的数组</p></li></ul><p>注解本身不支持继承, 但是注解的属性可以是另外一个注解(注解数组), 而且注解有一个 一个元注解 @Inherited</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 定义一个最普通的注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Author {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 注解属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *       1. 修饰为默认或public效果一样</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String name();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int age();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Author(name = &quot;Jet&quot;, age = 30)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void save() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          带默认值的注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Author {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String name();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int age() default 30;   // 带默认值的注解;  使用的时候就可以不写此属性值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 注解的所有元素必须有确定的值，要想表示元素null的状态，可以这么做：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int age() default -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      默认名称的注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Author {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果注解名称为value,使用时候可以省略名称，直接给值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // (且注解只有一个属性时候才可以省略名称)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String value();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Author(&quot;Jet&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 等价于</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Author(value = &quot;Jet&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Author {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String[] value() default {&quot;test1&quot;,&quot;test2&quot;};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Author（{“”，“”}）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void save() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="72-元注解">7.2. 元注解<a href="#72-元注解" class="hash-link" aria-label="7.2. 元注解的直接链接" title="7.2. 元注解的直接链接">​</a></h2><p>表示注解上的注解，</p><p>一般可以这样使用 导入自动配置</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Target(ElementType.TYPE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Import(RabbitBootstrapConfiguration.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface EnableRabbit {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除了普通注解， 还支持下面几个特殊的</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      指定注解的可用范围 @Target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">指定注解在什么地方用，例如用于一个方法，一个域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TYPE,     类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FIELD,     字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">METHOD,  方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PARAMETER,   参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONSTRUCTOR, 构造器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> LOCAL_VARIABLE  局部变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//     指定注解的可用声明周期 @Retention</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 指定注解在哪一个级别可用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.SOURCE)    //注解只在源码级别有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.CLASS)      //注解在字节码级别有效(编译成字节码后还保留注解信息)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    // 默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)   注解在运行时期有效(所以我们可以通过反射去获取注解信息, 常用)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      注解包含进javadoc中 @Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      允许子类继承父类中的注解 @Inherited</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于被标注的注解，允许子类继承父类中的该注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Inherited</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      拓展: @Constraint(validatedBy = {XXXXValidator.class})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对注解标注的字段进行校验</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="73-注解反射">7.3. 注解反射<a href="#73-注解反射" class="hash-link" aria-label="7.3. 注解反射的直接链接" title="7.3. 注解反射的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 注解反射要设置注解在运行时有效，即：在创建注解时加上： @Retention(RetentionPolicy.RUNTIME)   注解在运行时期有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Author(remark = &quot;保存信息！！！&quot;, age = 19)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void save() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取注解信息： name/age/remark</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 先获取代表方法的Method类型;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class clazz = App_2.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Method m = clazz.getMethod(&quot;save&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2. 再获取方法上的注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Author author = m.getAnnotation(Author.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取输出注解信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(author.authorName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(author.age());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(author.remark());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="74-看一个例子优化-dao-解决字段和属性不一致">7.4. 看一个例子(优化 dao-解决字段和属性不一致)<a href="#74-看一个例子优化-dao-解决字段和属性不一致" class="hash-link" aria-label="7.4. 看一个例子(优化 dao-解决字段和属性不一致)的直接链接" title="7.4. 看一个例子(优化 dao-解决字段和属性不一致)的直接链接">​</a></h2><p>解决优化的问题：</p><ul><li><ol><li>当数据库表名与类名不一致、</li></ol></li><li><ol start="2"><li>字段与属性不一样、</li></ol></li><li><ol start="3"><li>主键不叫 id</li></ol></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="741-通过注解优化-javabean">7.4.1. 通过注解优化 JavaBean<a href="#741-通过注解优化-javabean" class="hash-link" aria-label="7.4.1. 通过注解优化 JavaBean的直接链接" title="7.4.1. 通过注解优化 JavaBean的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//admin类，经过注解优化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Admin=a_admin表名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Table(tableName=&quot;a_admin&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Admin {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Id//主键</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Column(columnName = &quot;a_id&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Column(columnName = &quot;a_userName&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String userName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Column(columnName = &quot;a_pwd&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String pwd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   getter&amp;setter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String toString() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;Admin [id=&quot; + id + &quot;, pwd=&quot; + pwd + &quot;, userName=&quot; + userName</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                + &quot;]&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="742-泛型反射优化-basedao">7.4.2. 泛型反射优化 BaseDao<a href="#742-泛型反射优化-basedao" class="hash-link" aria-label="7.4.2. 泛型反射优化 BaseDao的直接链接" title="7.4.2. 泛型反射优化 BaseDao的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// baseDao类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class BaseDao&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前运行类的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Class&lt;T&gt; clazz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 表名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String tableName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 主键</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String id_primary;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 拿到当前运行类的参数化类型中实际的类型  ( BaseDao&lt;Admin&gt; ,  Admin.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BaseDao(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //**获取parent的参数化类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Type type = this.getClass().getGenericSuperclass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ParameterizedType pt = (ParameterizedType) type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Type[] types = pt.getActualTypeArguments();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        clazz = (Class&lt;T&gt;) types[0];//到此, 已经拿到：  Admin.class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*******1. 获取表名*******/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Table table = clazz.getAnnotation(Table.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tableName = table.tableName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*******2. 获取主键字段*******/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取当前运行类的所有字段、遍历、获取每一个字段上的id注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Field[] fs = clazz.getDeclaredFields();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Field f : fs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 设置强制访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            f.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取每一个字段上的id注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Id anno_id = f.getAnnotation(Id.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (anno_id != null) {// 不为null, 证明时主键字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Column column = f.getAnnotation(Column.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                id_primary = column.columnName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 跳出循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;表：&quot; + tableName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;主键：&quot; + id_primary);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T findById(int id){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String sql = &quot;select * from &quot; + tableName + &quot; where &quot; + id_primary +&quot;=?&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * DbUtils的已经封装好的工具类：BeanHandler?   属性=字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return JdbcUtils.getQueryRunner().query(sql, new BeanHandler&lt;T&gt;(clazz), id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;T&gt; getAll(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String sql = &quot;select * from &quot; + tableName;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return JdbcUtils.getQuerrRunner().query(sql, new BeanListHandler&lt;T&gt;(clazz));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="743-自定义结果集-handler">7.4.3. 自定义结果集 handler<a href="#743-自定义结果集-handler" class="hash-link" aria-label="7.4.3. 自定义结果集 handler的直接链接" title="7.4.3. 自定义结果集 handler的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 自定义结果集：封装单个Bean对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class BeanHandler&lt;T&gt; implements ResultSetHandler&lt;T&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 保存传入的要封装的类的字节码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Class&lt;T&gt; clazz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BeanHandler(Class&lt;T&gt; clazz) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.clazz = clazz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 封装结果集的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T handle(ResultSet rs) throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建要封装的对象  ‘1’</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            T t = clazz.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 向下读一行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (rs.next()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // a. 获取类的所有的Field字段数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Field[] fs = clazz.getDeclaredFields();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // b. 遍历， 得到每一个字段类型：Field</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (Field f : fs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // c. 获取”属性名称“，attention: 不是注解里的字段名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    String fieldName = f.getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // e. 获取Field字段上注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Column column =  f.getAnnotation(Column.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 // 数据库中字段 a_userName</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    String columnName = column.columnName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // g. 字段值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Object columnValue = rs.getObject(columnName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 设置（BeanUtils组件）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BeanUtils.copyProperty(t, fieldName, columnValue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 自定义结果集：封装多个Bean对象到List集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class BeanListHandler&lt;T&gt; implements ResultSetHandler&lt;List&lt;T&gt;&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 要封装的单个对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Class&lt;T&gt; clazz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BeanListHandler(Class&lt;T&gt; clazz){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.clazz = clazz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 把从数据库查询到的没一行记录，封装为一个对象，再提交到list集合， 返回List&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;T&gt; handle(ResultSet rs) throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;T&gt; list = new ArrayList&lt;T&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 向下读一行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (rs.next()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 创建要封装的对象  ‘1’</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                T t = clazz.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // a. 获取类的所有的Field字段数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Field[] fs = clazz.getDeclaredFields();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // b. 遍历， 得到每一个字段类型：Field</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (Field f : fs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // c. 获取”属性名称“</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    String fieldName = f.getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // e. 获取Field字段上注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Column column =  f.getAnnotation(Column.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // f. ”字段名“</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    String columnName = column.columnName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // g. 字段值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Object columnValue = rs.getObject(columnName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 设置（BeanUtils组件）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BeanUtils.copyProperty(t, fieldName, columnValue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 对象添加到集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                list.add(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>8. io</h1><p>操作 io 字节序列化库: <a href="https://github.com/EsotericSoftware/kryo" target="_blank" rel="noopener noreferrer">https://github.com/EsotericSoftware/kryo</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="81-io总结">8.1. io总结<a href="#81-io总结" class="hash-link" aria-label="8.1. io总结的直接链接" title="8.1. io总结的直接链接">​</a></h2><p>io 有这几种用法:</p><ul><li><p>只有一个线程，接受一个连接，读取数据，处理业务，写回结果，再接受下一个连接，这是同步阻塞。这种用法几乎没有。</p></li><li><p>一个线程和一个线程池，线程运行selector，将所有 channel 注册到多路复用选择器上，如果channel 中有数据了, 就从线程池中拿到一个线程处理, 也就是多路复用，这是同步非阻塞。也就是 java nio 的原理</p></li><li><p>一个线程和一个线程池，线程注册一个accept回调，系统帮我们接受好连接后，才触发回调在线程池中执行，执行时再注册read回调，系统帮我们接受好数据后，才触发回调在线程池中执行，就是AIO，这是异步非阻塞</p></li></ul><p>redis也是多路复用，但它只有一个线程在执行select操作，处理就绪的连接，整个是串行化的，所以天然不存在并发问题。只能把它归为同步阻塞了。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="82-socket-网络编程">8.2. socket 网络编程<a href="#82-socket-网络编程" class="hash-link" aria-label="8.2. socket 网络编程的直接链接" title="8.2. socket 网络编程的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 系统间进行通信， 需要两个步骤：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * - 数据传输.  - 借助 tcp/ip （可靠， 性能较差）, 或 udp/ip 协议 （数据丢失， 乱序， 但是性能更好）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * - 数据处理（读取or 写入） - 同步io 或者 异步io</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      - 同步io分为 bio, nio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          bio - 某个 thread 当发起io操作, 为阻塞方式 （cpu 一直空闲等待），直到读取到 流 or 将 流写入到操作系统才会释放资源， 期间独占资源， 其他需要使用共享资源的thread均等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          nio - 基于&quot;事件驱动&quot; 思想， 通过 Reactor模式 实现 。 某个 thread 进行 读 or 写操作 均为 非阻塞的 （cpu 去处理其他任务）。 当 socket 有 stream 可读 或 有 stream 待被 写入 socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          时, 发出事件(如 连接建立事件, 流读取事件, 流写入事件), 由操作系统通知 app来处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      - 异步io 分为 aio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          aio - 同样基于事件驱动, 通过 Proactor模式实现;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          和nio对比, 1. 简化编程, io操作由操作系统完成, app只要调用api即可; 2. 省略了 nio中需要遍历 事件通知队列(Selector)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 这样组合的话, 有四种通信方式: tcp/ip + bio, tcp/ip  + nio, udp/ip + bio, udp/ip + nio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * *************************************************************************************************</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 下面是 bio + tcp 方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private String url = &quot;127.0.0.1&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private int port = 9527;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Socket socket;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BufferedReader readerOnServer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private PrintWriter printerOnServer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BufferedReader readerOnCli;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void init(String url, int port) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket = new Socket(url, port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readerOnServer = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printerOnServer = new PrintWriter(socket.getOutputStream(), true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readerOnCli   = new BufferedReader(new InputStreamReader(System.in));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String line = readerOnCli.readLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // exit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (testExit(line)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; send to server: &quot; + line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // send to server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printerOnServer.println(line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // receive from server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String respLine = readerOnServer.readLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; receive from server: &quot; + respLine);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean testExit(String test) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isBlank(test) || &quot;exit&quot;.equalsIgnoreCase(test)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printerOnServer.write(&quot;exit&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; client exit.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void close() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printerOnServer.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readerOnCli.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readerOnServer.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Client client = new Client();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        client.init(&quot;127.0.0.1&quot;, 9527);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        client.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 这个 server 只支持 单个 client 连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 多个 client 连接 server怎么办? 首先要 pass 掉 &quot;在 server 中 创建多个 socket&quot;的想法, 因为 生成 socket 是非常重的操作, 占</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 用server资源非常多</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通常用采用 &quot;连接池&quot;, 好处是 🐶 能够限制创建的 socket个数; 🐶 避免重复创建 socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 但是这种方式还是有问题: 连接池中 socket 总是有限的总有不够用的时候; server 需要设置超时时间, 防</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 止 server 连带 client挂掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 如果要支持多个 client 连接， 可采用 线程池， 每个 socket 新开一个 thread。 这么做有缺点： 无论是否是有效请求， server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 都要耗费一个 thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 味了避免 过多的 thread 耗尽 server的资源， 线程池必须是限定大小的。 &lt;=&gt; 采用 bio 方式的 server 支撑的连接数是有限的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private ServerSocket serverSocket;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private BufferedReader readerFromClient;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private PrintWriter writerToClient;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //public void initBlock(int port) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    this.serverSocket = new ServerSocket(port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    this.readerFromClient = new BufferedReader(new InputStreamReader(serverSocket.accept().getInputStream()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException, InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int port = 9527;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ServerSocket socketServer = new ServerSocket(port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socketServer.setSoTimeout(60 * 1000); // unit : milliseconds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;&gt;&gt;&gt; server listen on port: &quot; + port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Socket socketClient = socketServer.accept(); // start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedReader readerFromClient = new BufferedReader(new InputStreamReader(socketClient.getInputStream()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //BufferedWriter writerToClient   = new BufferedWriter(new OutputStreamWriter(socketClient.getOutputStream()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PrintWriter writerToClient = new PrintWriter(socketClient.getOutputStream(), true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String line = readerFromClient.readLine(); // start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (StringUtils.isBlank(line)) {// read nothing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (&quot;exit&quot;.equalsIgnoreCase(line)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // close</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                readerFromClient.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                writerToClient.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                socketServer.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;&gt;&gt;&gt; server exit&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; msg from client: &quot; + line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            writerToClient.println(line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; msg to client: &quot; + line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.exit(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 基于消息的方式实现通信;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据传输: tcp/ip</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据处理: nio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private Selector selector;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //public void init(String ip, int port) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    SocketChannel socketChannel = SocketChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    socketChannel.configureBlocking(false); // configure channel as non blocking</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    socketChannel.connect(new InetSocketAddress(ip, port));// 对于 non blocking io, 立即返回 false, 表示连接建立中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                                            // 用channel.finishConnect();才能完成连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    Selector selector = Selector.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //public void listen() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String ip = &quot;127.0.0.1&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int port = 9527;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SocketChannel socketChannel = SocketChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socketChannel.configureBlocking(false); // configure channel as non blocking</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 会立即返回 false, 表示连接建立中; 调用channel.finishConnect()才能完成连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socketChannel.connect(new InetSocketAddress(ip, port));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // register socket channel with selector, 并指定只对 连接 感兴趣</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Selector selector = Selector.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedReader readerOnCli = new BufferedReader(new InputStreamReader(System.in));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (socketChannel.isConnected()) {// connection is established; send msg to server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String line = readerOnCli.readLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                socketChannel.write(StandardCharsets.UTF_8.encode(line));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (&quot;exit&quot;.equalsIgnoreCase(line)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // exit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    readerOnCli.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    socketChannel.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    selector.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;&gt;&gt;&gt; client exit.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // receive from server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            selector.select(60 * 1000);// timeout = 60 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (it.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectionKey key = it.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                it.remove();// remove current key from key set to avoid repetition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (key.isConnectable()) {// event: 连接事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SocketChannel sc = (SocketChannel) key.channel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sc.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // - 这时, sc 对 read 事件也感兴趣了;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // - 一般不会直接注册 write 事件 因为在 buffer 未满时一直是可写的, 因此如果在注册了 write 事件而又不使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //   它时 cpu 消耗可能会100%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sc.register(selector, SelectionKey.OP_READ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (sc.isConnectionPending()) {// 如果连接还没完成，则完成连接的建立</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        sc.finishConnect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (key.isReadable()) {// reading event</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SocketChannel sc = (SocketChannel) key.channel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ByteBuffer    buffer = ByteBuffer.allocate(1024);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int numRead = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        int tmp = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // read 操作是 block 的， 读取到末尾， 返回 -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            while ((tmp = sc.read(buffer)) &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                numRead += tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            buffer.flip();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (numRead &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;&gt;&gt;&gt; msg from server: &quot; + StandardCharsets.UTF_8.decode(buffer).toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            buffer = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (buffer != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            buffer.clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * tcp + nio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int                 port              = 9527;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InetSocketAddress   inetSocketAddress = new InetSocketAddress(port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ServerSocketChannel ssc               = ServerSocketChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ssc.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ssc.socket().bind(inetSocketAddress);// retrieve server socket and bind to port</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // - register server socket channel with selector;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      - `selector.select()` will return directly instead of blocking if `OP_ACCEPT` occurred;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      - OP_ACCEPT means the type of the registration; in this case, selector merely reports that a client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //          attempts a connection to the server; (Other possible options are: OP_CONNECT, which will be used by the client; OP_READ; and OP_WRITE.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Selector selector = Selector.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;&gt;&gt;&gt; server listen on port: &quot; + port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        outLoop:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            selector.select(60 * 1000); // block, wait for events recorded on the selector; timeout: 60s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // work on selected keys</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (it.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectionKey key = it.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                it.remove();// prevent the same key coming up again</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!key.isValid()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (key.isAcceptable()) {// event: the associated client request a connection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // retrieve server socket channel from selector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // create a socket channel which accepts the connection, creates a standard java socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    socketChannel.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;&gt;&gt;&gt; connected to: &quot; + socketChannel.socket().getRemoteSocketAddress());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // register socket channel with selector, 这个 channel只对 read 感兴趣</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (key.isReadable()) {// event: the server can read</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SocketChannel sc     = (SocketChannel) key.channel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ByteBuffer    buffer = ByteBuffer.allocate(1024);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int readBytes = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        int tmp =  0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            while ((tmp = sc.read(buffer)) &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                readBytes += tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            buffer.flip();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (readBytes &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            String data = StandardCharsets.UTF_8.decode(buffer).toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;&gt;&gt;&gt; receive from client: &quot; + data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (&quot;exit&quot;.equalsIgnoreCase(data)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                sc.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                selector.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                System.out.println(&quot;&gt;&gt;&gt; server closed&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                break outLoop;  // 搬到这里就ok了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            sc.write(StandardCharsets.UTF_8.encode(data));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;&gt;&gt;&gt; send to client: &quot; + data );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (buffer != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            buffer.clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //byte[] data = new byte[numRead];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //System.arraycopy(buffer, 0, data, 0, numRead);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //java.lang.String data = new java.lang.String(buffer.array());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //System.out.println(&quot;&gt;&gt;&gt; receive from client: &quot; + data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //if (&quot;exit&quot;.equalsIgnoreCase(data)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //    sc.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //    selector.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //    System.out.println(&quot;&gt;&gt;&gt; server closed&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //    break outLoop;  // 存疑 使用这种方式 client 发送 exit， 这里后面的代码仍旧会执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // send msg to client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //sc.write(StandardCharsets.UTF_8.encode(data));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //System.out.println(&quot;&gt;&gt;&gt; send to client: &quot; + data );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * udp 通信无需建立连接， 所以无法双向通信， 如需双向通信， 两端都必须是 server, 也就是 client 也要有监听端口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int            remotePort          = 9527;// 远程 server 端口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int            listenPort         = 9528;// 本地监听端口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramSocket listenSocket  = new DatagramSocket(listenPort);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[]         buffer        = new byte[65507];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramPacket receivePacket = new DatagramPacket(buffer, buffer.length);// 接收数据流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramSocket socket   = new DatagramSocket();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InetAddress    remoteAddr   = InetAddress.getByName(&quot;localhost&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedReader systemIn = new BufferedReader(new InputStreamReader(System.in));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;&gt;&gt;&gt; client listen on port : &quot; + listenPort);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String         line      = systemIn.readLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            byte[]         lineBytes = line.getBytes(StandardCharsets.UTF_8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            DatagramPacket packetToRemote    = new DatagramPacket(lineBytes, lineBytes.length, remoteAddr, remotePort);// 传送数据流对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            socket.send(packetToRemote);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; send to server: &quot; + line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (&quot;exit&quot;.equalsIgnoreCase(line.trim())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;&gt;&gt;&gt; Client quit!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                socket.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                listenSocket.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            listenSocket.receive(receivePacket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String receiveResponse = new String(receivePacket.getData(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    0, receivePacket.getLength(), StandardCharsets.UTF_8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; receive from server: &quot; + receiveResponse);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int            listenPort          =9527;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int            remotePort         =9528;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramSocket server        =new DatagramSocket(listenPort);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramSocket client        =new DatagramSocket();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InetAddress    serverAddress =InetAddress.getByName(&quot;localhost&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[]         buffer        =new byte[65507];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramPacket packet        =new DatagramPacket(buffer,buffer.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;&gt;&gt;&gt; server listen on port : &quot; + listenPort);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(true){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            server.receive(packet);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String line=new String(packet.getData(),0,packet.getLength(), StandardCharsets.UTF_8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(&quot;exit&quot;.equalsIgnoreCase(line.trim())){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                server.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                client.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.exit(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;&gt;&gt;&gt; Message from client: &quot;+ line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                packet.setLength(buffer.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                byte[] lineBytes=line.getBytes(StandardCharsets.UTF_8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                DatagramPacket responsePacket=new DatagramPacket(lineBytes,lineBytes.length,serverAddress,remotePort);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                client.send(responsePacket);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;&gt;&gt;&gt; send to client: &quot; + line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * DatagramChannel 负责监听端口and读写; ByteBuffer 数据传输</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int listenPort=9528;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int remotePort=9527;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramChannel receiveChannel=DatagramChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        receiveChannel.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        receiveChannel.socket().bind(new InetSocketAddress(listenPort));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Selector selector= Selector.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        receiveChannel.register(selector, SelectionKey.OP_READ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramChannel sendChannel =DatagramChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sendChannel.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sendChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,remotePort));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedReader systemIn =new BufferedReader(new InputStreamReader(System.in));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(true){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String command=systemIn.readLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sendChannel.write(Charset.forName(&quot;UTF-8&quot;).encode(command));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(&quot;quit&quot;.equalsIgnoreCase(command.trim())){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                systemIn.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sendChannel.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                selector.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Client quit!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.exit(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int nKeys=selector.select(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(nKeys&gt;0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (SelectionKey key : selector.selectedKeys()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(key.isReadable()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ByteBuffer buffer= ByteBuffer.allocate(1024);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        DatagramChannel dc=(DatagramChannel) key.channel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        dc.receive(buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        buffer.flip();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        System.out.println(Charset.forName(&quot;UTF-8&quot;).decode(buffer).toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                selector.selectedKeys().clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int rport=9527;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int sport=9528;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramChannel sendChannel=DatagramChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sendChannel.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SocketAddress target =new InetSocketAddress(&quot;127.0.0.1&quot;,sport);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sendChannel.connect(target);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramChannel receiveChannel =DatagramChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DatagramSocket  serverSocket   =receiveChannel.socket();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        serverSocket.bind(new InetSocketAddress(rport));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Data receive listen on port: &quot;+rport);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        receiveChannel.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Selector selector= Selector.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        receiveChannel.register(selector, SelectionKey.OP_READ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(true){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int nKeys=selector.select(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(nKeys&gt;0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (SelectionKey key : selector.selectedKeys()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(key.isReadable()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ByteBuffer buffer= ByteBuffer.allocate(1024);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        DatagramChannel dc=(DatagramChannel) key.channel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        dc.receive(buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        buffer.flip();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        String message= Charset.forName(&quot;UTF-8&quot;).decode(buffer).toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        System.out.println(&quot;Message from client: &quot;+ message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if(&quot;quit&quot;.equalsIgnoreCase(message.trim())){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            dc.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            selector.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            sendChannel.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;Server has been shutdown!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.exit(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        String outMessage=&quot;Server response：&quot;+message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        sendChannel.write(Charset.forName(&quot;UTF-8&quot;).encode(outMessage));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                selector.selectedKeys().clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="83-阻塞-io">8.3. 阻塞 io<a href="#83-阻塞-io" class="hash-link" aria-label="8.3. 阻塞 io的直接链接" title="8.3. 阻塞 io的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="831-什么是阻塞-io">8.3.1. 什么是阻塞 io<a href="#831-什么是阻塞-io" class="hash-link" aria-label="8.3.1. 什么是阻塞 io的直接链接" title="8.3.1. 什么是阻塞 io的直接链接">​</a></h3><p>IO : 指的就是应用程序读入/写出数据的过程，和程序等待读入/写出数据的过程。一旦拿到数据后就变成了数据操作了，就不是 IO 了</p><p>阻塞io: 拿网络 IO 来说，等待的过程就是数据从网络到网卡再到内核空间。读写的过程就是内核空间和用户空间的相互拷贝. 应用程序都是运行在用户空间的，所以它们能操作的数据也都在用户空间。只要数据没有到达用户空间，用户线程就操作不了. 如果此时用户线程已经参与，那它一定会被阻塞在 IO 上。这就是常说的阻塞 IO。用户线程被阻塞在等待数据上或拷贝数据上.</p><p>非阻塞 IO : 就是用户线程不参与以上两个过程(数据传输, 数据拷贝)，即数据已经拷贝到用户空间后，才去通知用户线程，一上来就可以直接操作数据了</p><p>阻塞io 和非阻塞io区别就是用户线程会不会阻塞在等待数据或者数据拷贝上</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="832-io-体系的整个概览">8.3.2. io 体系的整个概览<a href="#832-io-体系的整个概览" class="hash-link" aria-label="8.3.2. io 体系的整个概览的直接链接" title="8.3.2. io 体系的整个概览的直接链接">​</a></h3><p>基于字节操作的 I/O 接口：InputStream 和 OutputStream</p><p>基于字符操作的 I/O 接口：Writer 和 Reader</p><p>字节字符转换流</p><p>基于磁盘操作的 I/O 接口：File</p><p>基于网络操作的 I/O 接口：Socket</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. 字节流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1.1 字节读取：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">InputStream 所有输入字节流的基类  抽象类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FileInputStream 读取文件数据的输入字节流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BufferedInputStream  缓冲输入字符流       该类出现的目的是为了提高读取文件 数据的效率。 这个类其实只不过是在内部维护了一个8kb的字节数组而已。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1.2 字节输出：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">OutputStream 所有输出字节流的基类。  抽象类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FileOutputStream 向文件输出数据的输出字节流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BufferedOutputStream 缓冲输出字节流   该类出现的目的也是为了提高向文件写数据的效率。 这个类的也只不过是在内部维护了一个8kb的字节数组而已。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 字符流 : 字符流 = 字节流 + 编码（解码）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.1 字符读取:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Reader 所有输入字符流的基类。 抽象类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FileReader 读取文件数据的输入字符流。    内部维护一个1024字符的字符数组, 调用flush或者是close方法或者是填满了内部的字符数组才会真正写数据到硬盘</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BufferedReader 缓冲输入字符流           该类出现的目的是为了提高读取文件数据的效率与拓展FileReader的(readLine)功能。 这个类的也只不过是在内部维护了一个8kb的字符数组而已。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.2 字符输出:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Writer 所有输出字符流的基类。  抽象类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FileWriter 向文件输出数据的输出字符流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BufferedWriter 缓冲输出字符流 , 手动 flush, 手动 newLine()       该类出现的目的是为了提高写文件数据的效率与拓展FileWriter的(newLine)功能.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PrintWriter 打印输出流, 字符字节均可, 可设置自动flush, 自动换行 , 可代替 bufferwriter; (https://blog.csdn.net/lyhkmm/article/details/78260207)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 转换流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">InputStreamReader   输入字节流的转换流 ; 作用：InputStream--------------------&gt; Reader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">OutputStreamWriter  输出字节流的转换流 ; 作用：OutputStream --------------------&gt; Writer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">转换流的作用：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 可以把字节流转换成字符流使用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - FileReader与FileWriter都是固定是gbk码表进行读写数据的，而转换流可以指定码表进行读写文件的数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4. File</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">File 并不代表一个真实存在的文件对象, 而且就算存在还可能式文件or目录;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">为何要这样设计？因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Properties(配置文件类)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">体系：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> -------| Map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ------------| HashTable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ----------------| Properties 配置文件类、</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> store() 用于生成一个配置文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> load() 加载一个配置文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">attention ：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 如果配置文件存在着中文，那么生成配置文件的时候要使用字符流，否则会出现乱码。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 如果需要修改配置文件的内容，应该先加载原本配置文件，然后再生成一个配置文件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="833-paths-和-files-相关-api">8.3.3. Paths 和 Files 相关 api<a href="#833-paths-和-files-相关-api" class="hash-link" aria-label="8.3.3. Paths 和 Files 相关 api的直接链接" title="8.3.3. Paths 和 Files 相关 api的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8331-paths-的获取转化">8.3.3.1. Paths 的获取转化<a href="#8331-paths-的获取转化" class="hash-link" aria-label="8.3.3.1. Paths 的获取转化的直接链接" title="8.3.3.1. Paths 的获取转化的直接链接">​</a></h4><p>jdk 1.7 提供</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Paths.get(&quot;C:/&quot;, &quot;Xmp&quot;); 和 Paths.get(&quot;C:/Xmp&quot;); 等同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Path pathRoot = Paths.get(&quot;/&quot;);// 表示磁盘根路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(pathRoot.toAbsolutePath());// D:\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FileSystems.getDefault().getPath(&quot;C:/&quot;, &quot;aa.log&quot;) // 从操作系统获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Paths.get(URI.create(&quot;file:///C:/Xmp/dd&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">new File(&quot;C:/aa.log&quot;).toPath()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 表示当前项目根路径, 等同 System.getProperty(&quot;user.dir&quot;), 等同 new File(&quot;&quot;).getAbsoblutePath</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 注意: system.getProperty(&quot;user.home&quot;)  表示操作系统 用户家目录, 而不是当前项目目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Path pathA  = Paths.get(&quot;.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Path pathB = pathA.toAbsolutePath();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(pathB);// D:\repo\repo_github\shared_already\xiaoyu-recipes\samples\java8-demo\.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Path path1 = Paths.get(this.getClass().getResource(&quot;.&quot;).toURI());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(path1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//D:\repo\repo_github\shared_already\starter-demo\target\classes\io\github\xiaoyureed\starterdemo\util</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Path path2 = Paths.get(this.getClass().getClassLoader().getResource(&quot;.&quot;).toURI());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(path2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//D:\repo\repo_github\shared_already\starter-demo\target\classes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 获取 class path 推荐这种方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Path path3 = Paths.get(Thread.currentThread().getContextClassLoader().getResource(&quot;.&quot;).toURI());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(path3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//D:\repo\repo_github\shared_already\starter-demo\target\classes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8332-通过-files-paths-读取写入">8.3.3.2. 通过 Files Paths 读取写入<a href="#8332-通过-files-paths-读取写入" class="hash-link" aria-label="8.3.3.2. 通过 Files Paths 读取写入的直接链接" title="8.3.3.2. 通过 Files Paths 读取写入的直接链接">​</a></h4><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private Path createFile(String dir, String file) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Path dirPath = Paths.get(dir);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Files.notExists(dirPath)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Files.createDirectories(dirPath);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Path filePath = Paths.get(dir, file);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Files.notExists(filePath)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Files.createFile(filePath);// cannot create directory, only for file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return filePath;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * create a file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * write sth to the file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * read from the file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void testPaths_2() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString(&quot;rw-rw-rw-&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; attrs = PosixFilePermissions.asFileAttribute(perms);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Path file = this.createFile(&quot;d:/_test&quot;, &quot;aa.log&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 也能直接 files.newbufferreader/writer(Paths.get(&quot;xxx.json&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // reader.lines().collect(toList)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try (BufferedWriter bufferedWriter = Files.newBufferedWriter(file, StandardCharsets.UTF_8)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bufferedWriter.write(&quot;test writing file&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bufferedWriter.flush();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try (BufferedReader bufferedReader = Files.newBufferedReader(file, StandardCharsets.UTF_8);) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String s = bufferedReader.readLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (s == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8333-遍历文件夹">8.3.3.3. 遍历文件夹<a href="#8333-遍历文件夹" class="hash-link" aria-label="8.3.3.3. 遍历文件夹的直接链接" title="8.3.3.3. 遍历文件夹的直接链接">​</a></h4><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 没有递归的遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 只会遍历第一层目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void testTraverse() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Path path = Paths.get(&quot;d:/_learn/&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DirectoryStream&lt;Path&gt; dirStream = Files.newDirectoryStream(path);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!Files.isDirectory(path)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;path is not a dir, path = &quot; + path.toAbsolutePath().toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dirStream.forEach(p -&gt; System.out.println(p.getFileName()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 等价</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void testTraverse_1() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Path path = Paths.get(&quot;d:/_learn&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Stream&lt;Path&gt; dirStream = Files.list(path);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Iterator&lt;Path&gt; it = dirStream.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (it.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Path next = it.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(next.getFileName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 递归遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void testTraverse_2() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Path path = Paths.get(&quot;d:/_learn&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;Path&gt; result = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (file.toString().endsWith(&quot;.php&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    result.add(file);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return super.visitFile(file, attrs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result.forEach(System.out::println);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 递归遍历, 等价上面</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void testTraverse_3() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Path path = Paths.get(&quot;d:/_learn&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Stream&lt;Path&gt; stream = Files.walk(path);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Path&gt; result = stream.map(p -&gt; p.toString().endsWith(&quot;.php&quot;) ? p : null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .distinct()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .collect(Collectors.toList());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result.forEach(System.out::println);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8334-通过-files-获取文件属性">8.3.3.4. 通过 files 获取文件属性<a href="#8334-通过-files-获取文件属性" class="hash-link" aria-label="8.3.3.4. 通过 files 获取文件属性的直接链接" title="8.3.3.4. 通过 files 获取文件属性的直接链接">​</a></h4><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 文件属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void testFileProperty() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Path zip = Paths.get(&quot;d:/_test/aa.log&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Files.getLastModifiedTime(zip));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Files.size(zip));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Files.isSymbolicLink(zip));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Files.isDirectory(zip));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Files.readAttributes(zip, &quot;*&quot;));// map, 所有属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2019-05-22T14:34:24.320402Z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // {lastAccessTime=2019-05-22T14:21:24.821534Z, lastModifiedTime=2019-05-22T14:34:24.320402Z, size=17, creationTime=2019-05-22T14:21:24.821534Z, isSymbolicLink=false, isRegularFile=true, fileKey=null, isOther=false, isDirectory=false}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="834-bio-tcp-实现通信">8.3.4. bio tcp 实现通信<a href="#834-bio-tcp-实现通信" class="hash-link" aria-label="8.3.4. bio tcp 实现通信的直接链接" title="8.3.4. bio tcp 实现通信的直接链接">​</a></h3><p>(更多见这里 distributed-System#怎么实现子系统间的通信)</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 系统间进行通信， 需要两个步骤：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * - 数据传输.  - 借助 tcp/ip, 或 udp/ip 协议</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * - 数据处理（读取or 写入） - 同步io 或者 异步io</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      - 同步io分为 bio, nio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          bio - 当发起io操作, 线程间为阻塞关系, 当前 thread 只有将流读取/写入完毕才会释放资源给其他等待的 thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          nio - 基于&quot;事件驱动&quot; 通过 Reactor模式 实现   thread 间非阻塞, 当 socket 有 stream 可读 或 有 stream 待被 socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          写入时, 发出事件(如 连接建立事件, 流读取事件, 流写入事件), 由操作系统通知 app来处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *      - 异步io 分为 aio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          aio - 同样基于事件驱动, 通过 Proactor模式实现;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          和nio对比, 1. 简化编程, io操作由操作系统完成, app只要调用api即可; 2. 省略了 nio中需要遍历 事件通知队列(Selector)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *          的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 这样组合的话, 有四种通信方式: tcp/ip + bio, tcp/ip  + nio, udp/ip + bio, udp/ip + nio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * *************************************************************************************************</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 下面是 bio + tcp 方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private String url = &quot;127.0.0.1&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private int port = 9527;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Socket socket;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BufferedReader readerOnServer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private PrintWriter printerOnServer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BufferedReader readerOnCli;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void init(String url, int port) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket = new Socket(url, port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readerOnServer = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printerOnServer = new PrintWriter(socket.getOutputStream(), true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readerOnCli   = new BufferedReader(new InputStreamReader(System.in));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String line = readerOnCli.readLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // exit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (testExit(line)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; send to server: &quot; + line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // send to server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printerOnServer.println(line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // receive from server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String respLine = readerOnServer.readLine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; receive from server: &quot; + respLine);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean testExit(String test) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isBlank(test) || &quot;exit&quot;.equalsIgnoreCase(test)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            printerOnServer.write(&quot;exit&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; client exit.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void close() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printerOnServer.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readerOnCli.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readerOnServer.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Client client = new Client();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        client.init(&quot;127.0.0.1&quot;, 9527);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        client.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 这个 server 只支持 单个 client 连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 多个 client 连接 server怎么办? 首先要 pass 掉 &quot;在 server 中 创建多个 socket&quot;的想法, 因为 生成 socket 是非常重的操作, 占</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 用server资源非常多</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通常用采用 &quot;连接池&quot;, 好处是 🐶 能够限制创建的 socket个数; 🐶 避免重复创建 socket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 但是这种方式还是有问题: 连接池中 socket 总是有限的总有不够用的时候; server 需要设置超时时间, 防</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 止 server 连带 client挂掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 如果要支持多个 client 连接， 可采用 线程池， 每个 socket 新开一个 thread。 这么做有缺点： 无论是否是有效请求， server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 都要耗费一个 thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 味了避免 过多的 thread 耗尽 server的资源， 线程池必须是限定大小的。 &lt;=&gt; 采用 bio 方式的 server 支撑的连接数是有限的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Server {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private ServerSocket serverSocket;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private BufferedReader readerFromClient;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private PrintWriter writerToClient;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //public void initBlock(int port) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    this.serverSocket = new ServerSocket(port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    this.readerFromClient = new BufferedReader(new InputStreamReader(serverSocket.accept().getInputStream()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException, InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int port = 9527;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ServerSocket socketServer = new ServerSocket(port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socketServer.setSoTimeout(60 * 1000); // unit : milliseconds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;&gt;&gt;&gt; server listen on port: &quot; + port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Socket socketClient = socketServer.accept(); // start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedReader readerFromClient = new BufferedReader(new InputStreamReader(socketClient.getInputStream()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //BufferedWriter writerToClient   = new BufferedWriter(new OutputStreamWriter(socketClient.getOutputStream()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PrintWriter writerToClient = new PrintWriter(socketClient.getOutputStream(), true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String line = readerFromClient.readLine(); // start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (StringUtils.isBlank(line)) {// read nothing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (&quot;exit&quot;.equalsIgnoreCase(line)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // close</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                readerFromClient.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                writerToClient.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                socketServer.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;&gt;&gt;&gt; server exit&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; msg from client: &quot; + line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            writerToClient.println(line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;&gt;&gt;&gt; msg to client: &quot; + line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.exit(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="84-非阻塞-io">8.4. 非阻塞 io<a href="#84-非阻塞-io" class="hash-link" aria-label="8.4. 非阻塞 io的直接链接" title="8.4. 非阻塞 io的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="841-什么是非阻塞-io">8.4.1. 什么是非阻塞 io<a href="#841-什么是非阻塞-io" class="hash-link" aria-label="8.4.1. 什么是非阻塞 io的直接链接" title="8.4.1. 什么是非阻塞 io的直接链接">​</a></h3><p>用户线程没有因为 IO 的事情出现阻塞，这就是常说的非阻塞 IO, 即数据已经拷贝到用户空间后，才去通知用户线程，一上来就可以直接操作数据了。</p><p>传统 io(block io) 不管是磁盘 I/O 还是网络 I/O，数据在写入 OutputStream 或者从 InputStream 读取时用户线程都有可能会阻塞, 一旦有线程阻塞将会失去 CPU 的使用权</p><p>nio 使得 server 使用 一个 thread 可以处理多个 client 的请求</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="842-同步异步和阻塞非阻塞">8.4.2. 同步异步和阻塞非阻塞<a href="#842-同步异步和阻塞非阻塞" class="hash-link" aria-label="8.4.2. 同步异步和阻塞非阻塞的直接链接" title="8.4.2. 同步异步和阻塞非阻塞的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8421-同步与异步">8.4.2.1. 同步与异步<a href="#8421-同步与异步" class="hash-link" aria-label="8.4.2.1. 同步与异步的直接链接" title="8.4.2.1. 同步与异步的直接链接">​</a></h4><p>形容多个事物之间的运行关系, 可以形容 方法, 线程, cpu 指令...</p><p>同步就是多个事物不能同时开工，异步就是多个事物可以同时开工</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8422-阻塞与非阻塞">8.4.2.2. 阻塞与非阻塞<a href="#8422-阻塞与非阻塞" class="hash-link" aria-label="8.4.2.2. 阻塞与非阻塞的直接链接" title="8.4.2.2. 阻塞与非阻塞的直接链接">​</a></h4><p>形容一种事物状态</p><p>线程阻塞了, 表明线程被挂起, 不能动了, 让出了 CPU</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8423-四种组合">8.4.2.3. 四种组合<a href="#8423-四种组合" class="hash-link" aria-label="8.4.2.3. 四种组合的直接链接" title="8.4.2.3. 四种组合的直接链接">​</a></h4><ul><li><p>同步阻塞, 相当于一个线程在等待</p><p>例如 java bio, I/O 性能一般很差，CPU 大部分在空闲状态。</p></li><li><p>同步非阻塞, 相当于一个线程在正常运行</p><p>java nio</p></li><li><p>异步非阻塞 - 用户线程的继续执行，和操作系统准备 IO 数据的过程是同时进行的，因此才叫做异步 IO</p><p>java aio</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="85-多路复用-io-即-java-nio">8.5. 多路复用 IO 即 java nio<a href="#85-多路复用-io-即-java-nio" class="hash-link" aria-label="8.5. 多路复用 IO 即 java nio的直接链接" title="8.5. 多路复用 IO 即 java nio的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="851-解释多路复用">8.5.1. 解释多路复用<a href="#851-解释多路复用" class="hash-link" aria-label="8.5.1. 解释多路复用的直接链接" title="8.5.1. 解释多路复用的直接链接">​</a></h3><p>多种数据信号混合在一起, 通过一条通路传输, 最终通过各自特定的处理器处理</p><p>比如 网络 io, 服务器端的工作线程不会把时间花在“等待数据”上, 但是会花在等待“读取数据”这个过程上</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="852-nio-和-io-区别">8.5.2. nio 和 io 区别<a href="#852-nio-和-io-区别" class="hash-link" aria-label="8.5.2. nio 和 io 区别的直接链接" title="8.5.2. nio 和 io 区别的直接链接">​</a></h3><p>1)IO 是面向流的，NIO 是面向缓冲区的；</p><p>2)IO 流是阻塞的，NIO 流是不阻塞的;</p><p>3)NIO 有选择器，而 IO 没有。</p><p>阻塞io: 拿网络 IO 来说，等待的过程就是数据从网络到网卡再到内核空间。读写的过程就是内核空间和用户空间的相互拷贝. 应用程序都是运行在用户空间的，所以它们能操作的数据也都在用户空间。只要数据没有到达用户空间，用户线程就操作不了. 如果此时用户线程已经参与，那它一定会被阻塞在 IO 上。这就是常说的阻塞 IO。用户线程被阻塞在等待数据上或拷贝数据上.</p><p>非阻塞 IO : 就是用户线程不参与以上两个过程(数据传输, 数据拷贝)，即数据已经拷贝到用户空间后，才去通知用户线程，一上来就可以直接操作数据了</p><p>阻塞io 和非阻塞io区别就是用户线程会不会阻塞在等待数据或者数据拷贝上</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="853-linux-中的多路复用支持">8.5.3. Linux 中的多路复用支持<a href="#853-linux-中的多路复用支持" class="hash-link" aria-label="8.5.3. Linux 中的多路复用支持的直接链接" title="8.5.3. Linux 中的多路复用支持的直接链接">​</a></h3><p>Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达</p><p>这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="854-核心组件">8.5.4. 核心组件<a href="#854-核心组件" class="hash-link" aria-label="8.5.4. 核心组件的直接链接" title="8.5.4. 核心组件的直接链接">​</a></h3><p>java nio 就是 多路复用思想的实现</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8541-理解">8.5.4.1. 理解<a href="#8541-理解" class="hash-link" aria-label="8.5.4.1. 理解的直接链接" title="8.5.4.1. 理解的直接链接">​</a></h4><p>Selector 可以同时监听一组通信信道（Channel）上的 I/O 状态</p><p>selectionKeys 表示 各个 client 的请求</p><p>另外 , 参考这里: <a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/nio.html</a></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8542-channels">8.5.4.2. Channels<a href="#8542-channels" class="hash-link" aria-label="8.5.4.2. Channels的直接链接" title="8.5.4.2. Channels的直接链接">​</a></h4><p>NIO Channel 通道和流的区别:</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8543-buffers">8.5.4.3. Buffers<a href="#8543-buffers" class="hash-link" aria-label="8.5.4.3. Buffers的直接链接" title="8.5.4.3. Buffers的直接链接">​</a></h4><p>和 channel 交互</p><ul><li><p>从 Channel 中读取数据到 buffers 里，从 Buffer 把数据写入到 Channels；</p></li><li><p>Buffer 本质上就是一块内存区</p></li><li><p>capacity 容量、position 位置、limit 限制。</p></li></ul><p>api:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ByteBuffer buf = ByteBuffer.allocate(28);//以ByteBuffer为例子</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int bytesRead = inChannel.read(buf); //read into buffer.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">buf.put(127);// put data into buf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="8544-selectors">8.5.4.4. Selectors<a href="#8544-selectors" class="hash-link" aria-label="8.5.4.4. Selectors的直接链接" title="8.5.4.4. Selectors的直接链接">​</a></h4><p>其实对于选择器的个数、选择器运行在哪个线程里、是否使用新的线程来处理请求都没有要求，要根据实际情况来定。</p><p>比如说 redis，和处理请求相关的就一个线程，选择器运行在里面，处理请求的程序也运行在里面，所以这个线程既是 I/O 线程，也是 Worker 线程。</p><p>当然，也可以使用两个选择器，一个处理 OP_ACCEPT，一个处理 OP_READ，让它们分别运行在两个单独的 I/O 线程里。对于能快速完成的操作可以直接在 I/O 线程里做了，对于非常耗时的操作一定要使用 Worker 线程池来处理。</p><p>这种处理模式就是被称为的多路复用 I/O，多路指的是多个 Socket 通道，复用指的是只用一个线程来管理它们。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="855-nio-实现网络通信">8.5.5. nio 实现网络通信<a href="#855-nio-实现网络通信" class="hash-link" aria-label="8.5.5. nio 实现网络通信的直接链接" title="8.5.5. nio 实现网络通信的直接链接">​</a></h3><p>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</p><p>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</p><p>看个例子 - nio + tcp 实现通信 (<a href="https://examples.javacodegeeks.com/core-java/nio/java-nio-socket-example/" target="_blank" rel="noopener noreferrer">https://examples.javacodegeeks.com/core-java/nio/java-nio-socket-example/</a>)</p><p>见 distributed-System#怎么实现子系统间的通信</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nio 实现网络通信</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class NioServer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static int clientCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static AtomicInteger counter = new AtomicInteger(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Selector selector = Selector.open(); // 定义一个选择器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 定义一个服务器端套接字通道</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 配置为非阻塞</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ServerSocketChannel ssc = ServerSocketChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ssc.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 注册 ssc 到 选择器, 指定 ssc 关注的事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ssc.bind(new InetSocketAddress(&quot;localhost&quot;, 8080));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //进入死循环, // 轮询, 选择器不时的进行选择</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        selector.select();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (iterator.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          SelectionKey key = iterator.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          iterator.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (key.isAcceptable()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              //选择器终于选择出了通道</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ServerSocketChannel ssc1 = (ServerSocketChannel)key.channel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SocketChannel sc = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while ((sc = ssc1.accept()) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //把新接受的通道配置为非阻塞的，并把它也注册到了选择器上，该通道感兴趣的操作为OP_READ。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              sc.configureBlocking(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              sc.register(selector, SelectionKey.OP_READ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              InetSocketAddress rsa = (InetSocketAddress)sc.socket().getRemoteSocketAddress();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              System.out.println(time() + &quot;-&gt;&quot; + rsa.getHostName() + &quot;:&quot; + rsa.getPort() + &quot;-&gt;&quot; + Thread.currentThread().getId() + &quot;:&quot; + (++clientCount));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //选择器终于又选择出了通道，这次发现通道是需要Readable的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          else if (key.isReadable()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //先将“读”从感兴趣操作移出，待把数据从通道中读完后，再把“读”添加到感兴趣操作中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //否则，该通道会一直被选出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            key.interestOps(key.interestOps() &amp; (~ SelectionKey.OP_READ));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 把这个通道交给了一个新的工作线程去处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            processWithNewThread((SocketChannel)key.channel(), key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void processWithNewThread(SocketChannel sc, SelectionKey key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Runnable run = () -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      counter.incrementAndGet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String result = readBytes(sc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //把“读”加进去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        key.interestOps(key.interestOps() | SelectionKey.OP_READ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(time() + &quot;-&gt;&quot; + result + &quot;-&gt;&quot; + Thread.currentThread().getId() + &quot;:&quot; + counter.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sc.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      counter.decrementAndGet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new Thread(run).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static String readBytes(SocketChannel sc) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long start = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int total = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ByteBuffer bb = ByteBuffer.allocate(1024);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //开始读数据的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long begin = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while ((count = sc.read(bb)) &gt; -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (start &lt; 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //第一次读到数据的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        start = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      total += count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      bb.clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //读完数据的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long end = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return &quot;wait=&quot; + (start - begin) + &quot;ms,read=&quot; + (end - start) + &quot;ms,total=&quot; + total + &quot;bs&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static String time() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return sdf.format(new Date());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="86-java-aio">8.6. java aio<a href="#86-java-aio" class="hash-link" aria-label="8.6. java aio的直接链接" title="8.6. java aio的直接链接">​</a></h2><p>没有阻塞点，当工作线程启动时，数据已经（被系统）准备好可以直接用了。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AioServer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static int clientCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static AtomicInteger counter = new AtomicInteger(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      AsynchronousServerSocketChannel assc = AsynchronousServerSocketChannel.open();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assc.bind(new InetSocketAddress(&quot;localhost&quot;, 8080));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //非阻塞方法，其实就是注册了个回调，而且只能接受一个连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assc.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void completed(AsynchronousSocketChannel asc, Object attachment) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //再次注册，接受下一个连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          assc.accept(null, this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            InetSocketAddress rsa = (InetSocketAddress)asc.getRemoteAddress();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(time() + &quot;-&gt;&quot; + rsa.getHostName() + &quot;:&quot; + rsa.getPort() + &quot;-&gt;&quot; + Thread.currentThread().getId() + &quot;:&quot; + (++clientCount));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          readFromChannelAsync(asc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void failed(Throwable exc, Object attachment) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //不让主线程退出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      synchronized (AioServer.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        AioServer.class.wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void readFromChannelAsync(AsynchronousSocketChannel asc) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //会把数据读入到该buffer之后，再触发工作线程来执行回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ByteBuffer bb = ByteBuffer.allocate(1024*1024*1 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long begin = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //非阻塞方法，其实就是注册了个回调，而且只能接受一次读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asc.read(bb, null, new CompletionHandler&lt;Integer, Object&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //从该连接上一共读到的字节数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      int total = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       * @param count 表示本次读取到的字节数，-1表示数据已读完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      public void completed(Integer count, Object attachment) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        counter.incrementAndGet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (count &gt; -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          total += count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int size = bb.position();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(time() + &quot;-&gt;count=&quot; + count + &quot;,total=&quot; + total + &quot;bs,buffer=&quot; + size + &quot;bs-&gt;&quot; + Thread.currentThread().getId() + &quot;:&quot; + counter.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (count &gt; -1) {//数据还没有读完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          //再次注册回调，接受下一次读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          asc.read(bb, null, this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {//数据已读完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            asc.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        counter.decrementAndGet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      public void failed(Throwable exc, Object attachment) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long end = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(time() + &quot;-&gt;exe read req,use=&quot; + (end -begin) + &quot;ms&quot; + &quot;-&gt;&quot; + Thread.currentThread().getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static String time() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return sdf.format(new Date());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="87-断点续传">8.7. 断点续传<a href="#87-断点续传" class="hash-link" aria-label="8.7. 断点续传的直接链接" title="8.7. 断点续传的直接链接">​</a></h2><p><a href="https://github.com/ryanlijianchang/ResumeBrokenDownloads" target="_blank" rel="noopener noreferrer">https://github.com/ryanlijianchang/ResumeBrokenDownloads</a></p><h1>9. 代理</h1><ul><li><p>静态代理</p><ul><li><p>代理类实现目标接口, 内部维护一个接口类型的引用), jdk 原生实现</p></li><li><p>aspectj 框架, 在编译期增强</p></li></ul></li><li><p>动态代理:</p><ul><li><p>jdk 动态代理(只能针对接口进行代理), jdk 原生实现</p></li><li><p>cglib 动态代理(直接针对类代理, 生成子类, 所以目标类不能是 final 的 ), 依赖 asm; </p><p>Spring aop 在给某个类提供动态代理时会自动在 jdk 动态代理和 cglib 动态代理中动态的选择。</p></li><li><p>javaassist - javaassist 是使用最广泛的动态代理开源库, 无需类接口; javaassist 的 ProxyFactory 还提供了方法过滤器，它可以选择性地对特定方法进行增强。</p></li></ul></li></ul><h1>10. Java 内存模型</h1><p>java-memory-model.md</p><h1>11. java8</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="111-函数式编程的概念fp">11.1. 函数式编程的概念(FP)<a href="#111-函数式编程的概念fp" class="hash-link" aria-label="11.1. 函数式编程的概念(FP)的直接链接" title="11.1. 函数式编程的概念(FP)的直接链接">​</a></h2><p>vavr 增强库 (<a href="https://blog.csdn.net/gening4014/article/details/124326753" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/gening4014/article/details/124326753</a>)</p><ul><li><p>函数可以作为参数传递给另外的函数, 在 Java 中本质还是创建了一个匿名类</p></li><li><p>函数可以作为另外函数的返回值</p></li><li><p>函数没有副作用 - 函数和外界交互唯一途径就是 参数 和 返回值</p><p>副作用: 函数在 call 的过程中, 影响了函数的外部状态</p></li><li><p>Declaractive(申明式) 代替 Imperative(命令式)</p></li><li><p>不变的对象 -- 类似于 不变模式</p><p>声明式的操作不会改变原始对象</p></li><li><p>容易 并行化 -- 这也是 &quot;不变对象&quot;的好处</p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Declaractive vs. Imperative:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void imperative(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i : arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(i+&quot;, &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void declaractive(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // jdk1.8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.stream(arr).forEach(System.out::println);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="112-java8-添加的新特性">11.2. Java8 添加的新特性<a href="#112-java8-添加的新特性" class="hash-link" aria-label="11.2. Java8 添加的新特性的直接链接" title="11.2. Java8 添加的新特性的直接链接">​</a></h2><ul><li>default methods for interface 接口内允许默认实现, 实现 fluent api</li><li>Lambda expression<ul><li>lambda scope<ul><li>accessing local variables - final 可以不加, 最好加上, 必须保证变量只读</li><li>accessing fields and static variables - 可读可写</li><li>accessing default interface methods - lambda 中无法使用接口默认方法</li></ul></li></ul></li><li>method/constructor reference<ul><li>静态方法引用 -- ClassName:methodName</li><li>实例方法引用<ul><li>通过类型对实例方法引用 -- ClassName::methodName</li><li>通过实例对实例方法引用 -- instance::methodName</li></ul></li><li>超类上的方法引用 -- super::methodName</li><li>构造方法引用 -- ClassName::new</li><li>数组构造方法引用 -- TypeName[]::new</li></ul></li><li>functional interface<ul><li>built-in functional interface<ul><li>Predicates - accept one arg and produce a predicate (and, or, negtive, isquals), 代表一段逻辑判断</li><li>Functions - accept one arg and produce a result (andThen 一个一个接着执行, compose 从最内层开始执行), 代表一个功能<ul><li>BiFunction - 接收 两个参数</li></ul></li><li>Suppliers - do not accept any arg, produce a object of a given type, 表示一个对象工厂</li><li>Consumers - accept one arg and perform some operations on it, 消费者</li><li>Comparators - 比较器</li></ul></li></ul></li><li>optional - a container for a value, 并非 functional interface, 用于防止空指针异常</li><li>stream - represents a sequence of elements, on which some operations can be performed; stream opts are either 中间操作 and 终止操作; 流都是一次性的, 一旦 terminal opts 调用, 流就关闭了, 再用就会异常, 可通过构造一个 Suplier 来重用 stream;<ul><li>中间操作(intermediate opts) - 只有存在 terminal opts 时才会实际执行; 并且是每个 element 走完整个链条, 才会进入下一个 element(利于减少操作数, 比如对于 anyMatch 操作, 只要一个元素符合就返回最总结果 true)<ul><li>Filter - accept a predicate and return a filtered stream - 一般放在链条首位, 减少操作数</li><li>Sorted - accept a comparator or nothing and return a sorted view of stream; 只是生成视图, 并不改变原始 collection</li><li>Map - accept a function and perform on each element of the stream</li></ul></li><li>终点操作(terminal opts)<ul><li>forEach - accept a consumer to be executed for each element in the stream</li><li>Match - accept a predicate and return a boolean result; 检查这个 stream 中的每个元素是否符合 predicate<ul><li>anyMatch 任何一个符合 return true</li><li>allMatch 全都符合 return true</li><li>noneMatch 没有符合的元素 return true</li></ul></li><li>Count - return the number of element as a long value</li><li>Reduce - accept a function and return a optional representing the reducing value;</li><li>Collect - accept a collector, transfer a stream to collection<ul><li>有许多 builtin 的 collector, 如 Collectors.toList()...</li></ul></li></ul></li><li>sequential stream(串行流)<ul><li>实例方法 someList.stream()</li><li>静态方法 Arrays.stream(arr)</li><li>静态方法 Stream.of(...)</li></ul></li><li>Parallel Streams(并行流)<ul><li>someList.parallelStream()</li><li>Stream.parallel()</li></ul></li></ul></li><li>maps<ul><li><code>map.keySet().stream()</code>, <code>map.values().stream()</code> and <code>map.entrySet().stream()</code>.</li><li>putIfAbsent(key, value) - 若确实, 则存入; ---&gt;  如果 key 没有在 map 中, 存入, 如果 key 存在 map 了, 返回 oldValue; 主要是免除了 null check</li><li>merge(key,  newValue, biFunction) - 根据 key 查 value, 如果没查到, 保存, 如果查到了, 根据 biFunction 构造 newValue 保存; biFunction(oldValue, newValue) 返回计算后的值</li><li>forEach - accept a consumer</li><li>computeIfPresent(key, biFunction) - 接收一个 key, 一个 biFunction, 检查 key 是否 null, 找到这个 entry, 根据 biFunction 计算出新的 value 重新 put 进 map; biFunction(key, value) 返回计算的值</li><li>computeIfAbsent - 如果根据 key 获取不到 value, 则计算新的 value 并 put 进去</li><li>remove(key, value) - value 符合才移除 key 对应的元素</li><li>getOrDefault(key, def_value) - 没有就返回默认值</li></ul></li><li>Date api - java.time 包下, 线程安全<ul><li>Clock - 时钟, 时间统计</li><li>Timezones - 时区</li><li>LocalTime - 没有 time zone 的时间</li><li>LocalDate - 日期</li><li>LocalDateTime - 日期时间</li></ul></li><li>Annotations<ul><li>注解里面允许注解, 允许重复</li><li>注解允许放在新的地方: ElementType.TYPE_PARAMETER, ElementType.TYPE_USE</li></ul></li><li>CompletableFuture - 增强版本的 Future<ul><li>future.get() 获取最终结果, 会阻塞, 等待完成</li><li>future.complet(xxx) 任务完成</li><li>CompletableFuture.supplyAsync(xxx) 构造 future, 有返回值</li><li>CompletableFuture.runAsync(xxx) 构造 future, 无返回值</li><li>流式调用</li><li>异常处理</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1121-接口默认方法">11.2.1. 接口默认方法<a href="#1121-接口默认方法" class="hash-link" aria-label="11.2.1. 接口默认方法的直接链接" title="11.2.1. 接口默认方法的直接链接">​</a></h3><p>java8 内置的许多函数式接口用到了&quot;接口默认实现&quot;, 这使得 Java8 拥有了类似 多继承的能力: 一个对象实例, 拥有多个接口提供的实例方法</p><p>而这也使得接口默认方法会碰到 多继承一样的问题 -- 如果两个父类拥有相同名称的方法, 子类不知道以哪个的为准, 会抛异常</p><p>利用 接口默认方法, 可以实现顺畅的 fluent api</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 典型 Demo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Formula {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double calculate(int a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default double sqrt(int a) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Math.sqrt(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void intConsumerAndThenTest() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    IntConsumer println = System.out::println;// 输出到标准输出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    IntConsumer errPrintln = System.err::println;// 输出到 错误输出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.stream(arr).forEach(println.andThen(errPrintln));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// IntConsumer的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@FunctionalInterface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface IntConsumer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void accept(int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //先调用 accept, 然后after.accept()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default IntConsumer andThen(IntConsumer after) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Objects.requireNonNull(after);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (int t) -&gt; { accept(t); after.accept(t); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1122-functionalinterface-函数接口">11.2.2. @FunctionalInterface-函数接口<a href="#1122-functionalinterface-函数接口" class="hash-link" aria-label="11.2.2. @FunctionalInterface-函数接口的直接链接" title="11.2.2. @FunctionalInterface-函数接口的直接链接">​</a></h3><p>用于标注函数式接口 - 这个接口中只有一个抽象方法(attention: 允许存在其他的接口默认方法 or Object 中包含的方法); 是否添加这个注解不是强制性的, 类似 @Override, 只是为了提供编译检查</p><p>本质是延迟了函数的定义, 使用的时候再来定义函数的具体实现, 方便了 lambda 表达式</p><p>函数式接口的实例通过 &quot;方法引用&quot; 和 &quot;lambda&quot; 构造</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 定义函数式接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@FunctionalInterface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface Converter&lt;F, T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    T convert(F from);// 只包含一个抽象方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个也是一个函数式接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@FunctionalInterface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface IntHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void handl(int i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean equals(Object obj);// equals() 被 Object 实现了, 而IntHandler的实例默认继承自Object</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer converted = converter.convert(&quot;123&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(converted);    // 123</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1123-方法的引用">11.2.3. 方法的引用<a href="#1123-方法的引用" class="hash-link" aria-label="11.2.3. 方法的引用的直接链接" title="11.2.3. 方法的引用的直接链接">​</a></h3><p>用来简化 lambda 表达式</p><ul><li>静态方法引用 -- ClassName:methodName</li><li>实例方法引用<ul><li>通过类型对实例方法引用 -- ClassName::methodName</li><li>通过实例对实例方法引用 -- instance::methodName</li></ul></li><li>超类上的方法引用 -- super::methodName</li><li>构造方法引用 -- ClassName::new</li><li>数组构造方法引用 -- TypeName[]::new</li></ul><p>不要试图用在重载方法上, 编译器碰到多个相同的名称的方法会感到困惑, 抛出异常</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Logger log = LoggerFactory.getLogger(App.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main( String[] args ){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println( &quot;java 8&quot; );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * :: 普通函数的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void test3() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person person = new Person(&quot;Peter&quot;, &quot;Parker&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String ret = person::sayAndReturn;//// 编译无法通过, [String ret ] 无法接受一个函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    // person::sayAndReturn 返回的式方法引用, 而不是 方法执行的结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 编译通过, test方法符合Converter中的接口规范</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Converter&lt;String, String&gt; converter = person::test;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Demo demo = new Demo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Converter&lt;String, String&gt; converter2 = demo::startWith;// 接收一个string, 返回第一个字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                // (strtWith的输入输出要和Converter的函数式接口匹配)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String firstLetter = converter2.convert(&quot;Java&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.info(firstLetter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * :: constructor reference</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void test2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PersonFactory&lt;Person&gt; personFac =  Person::new;// Person::new表示Person的构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        // 的reference, 也是 PersonFactory 这个函数式接口的一个实例;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        // 刚好用 personFac 接收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person person = personFac.create(&quot;Peter&quot;, &quot;Parker&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @FunctionalInterface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interface PersonFactory&lt;P extends Person&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        P create(String first, String last);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1124-lambda-表达式">11.2.4. Lambda 表达式<a href="#1124-lambda-表达式" class="hash-link" aria-label="11.2.4. Lambda 表达式的直接链接" title="11.2.4. Lambda 表达式的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="11241-lambda-介绍">11.2.4.1. lambda 介绍<a href="#11241-lambda-介绍" class="hash-link" aria-label="11.2.4.1. lambda 介绍的直接链接" title="11.2.4.1. lambda 介绍的直接链接">​</a></h4><p>本质就是匿名类</p><p>lambda 表达式可以使用外部变量, 但是 lambda 一旦定义, 这个外部变量就不能改变了, 应该视为 &quot;final&quot;</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// old版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collections.sort(names, new Comparator&lt;String&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int compare(String a, String b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return b.compareTo(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Lambda表达式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collections.sort(names, (String a, String b) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return b.compareTo(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//更简单1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 更简单2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Collections.sort(names, (a, b) -&gt; b.compareTo(a));// 编译器知道参数类型，所以可以跳过它们不写</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="11242-lambda-作用域问题">11.2.4.2. Lambda 作用域问题<a href="#11242-lambda-作用域问题" class="hash-link" aria-label="11.2.4.2. Lambda 作用域问题的直接链接" title="11.2.4.2. Lambda 作用域问题的直接链接">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="112421-访问局部变量">11.2.4.2.1. 访问局部变量<a href="#112421-访问局部变量" class="hash-link" aria-label="11.2.4.2.1. 访问局部变量的直接链接" title="11.2.4.2.1. 访问局部变量的直接链接">​</a></h5><p>局部变量必须声明为: final 或者隐式 final</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//// 这样可以</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final int num = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stringConverter.convert(2);     // 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 这样可以(隐式final)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int num = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stringConverter.convert(2);     // 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这样无法编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int num = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">num = 3;// 不是final的了</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="112422-访问成员变量">11.2.4.2.2. 访问成员变量<a href="#112422-访问成员变量" class="hash-link" aria-label="11.2.4.2.2. 访问成员变量的直接链接" title="11.2.4.2.2. 访问成员变量的直接链接">​</a></h5><p>很普通, 可读可写</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Lambda4 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static int outerStaticNum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int outerNum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void testScopes() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            outerNum = 23;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return String.valueOf(from);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            outerStaticNum = 72;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return String.valueOf(from);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="112423-访问默认接口方法">11.2.4.2.3. 访问默认接口方法<a href="#112423-访问默认接口方法" class="hash-link" aria-label="11.2.4.2.3. 访问默认接口方法的直接链接" title="11.2.4.2.3. 访问默认接口方法的直接链接">​</a></h5><p>不能访问</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">interface Formula {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double calculate(int a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default double sqrt(int a) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Math.sqrt(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 编译不通过,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Formula formula = (a) -&gt; sqrt( a * 100);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="113-java8-中的并行流">11.3. java8 中的并行流<a href="#113-java8-中的并行流" class="hash-link" aria-label="11.3. java8 中的并行流的直接链接" title="11.3. java8 中的并行流的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1131-使用并行过滤数据">11.3.1. 使用并行过滤数据<a href="#1131-使用并行过滤数据" class="hash-link" aria-label="11.3.1. 使用并行过滤数据的直接链接" title="11.3.1. 使用并行过滤数据的直接链接">​</a></h3><p>parallel() - 得到并行流</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static long countPrime() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // long count = IntStream.range(1, 5).filter(Lambdda::isPrime).count();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用并行模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Lambdda::isPrime 会被多线程并发调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long count = IntStream.range(1, 10000).parallel().filter(Lambdda::isPrime).count();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 判断是否质数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 质数: 只能被 1和它本身整除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @param target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static boolean isPrime(int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (target &lt; 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 2; i &lt;= Math.sqrt(target); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (target % i == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // System.out.println(&quot;prime: &quot; + target);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1132-从集合得到并行流">11.3.2. 从集合得到并行流<a href="#1132-从集合得到并行流" class="hash-link" aria-label="11.3.2. 从集合得到并行流的直接链接" title="11.3.2. 从集合得到并行流的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static void average() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ArrayList&lt;Student&gt; stuList = new ArrayList&lt;Student&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stuList.add(new Student(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stuList.add(new Student(2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stuList.add(new Student(3));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从集合获取流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double asDouble = stuList.stream().mapToInt(stu -&gt; stu.score).average().getAsDouble();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 并行流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    double asDouble2 = stuList.stream().parallel().mapToInt(stu -&gt; stu.score).average().getAsDouble();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(asDouble);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1133-并行排序-给数组赋值">11.3.3. 并行排序-给数组赋值<a href="#1133-并行排序-给数组赋值" class="hash-link" aria-label="11.3.3. 并行排序-给数组赋值的直接链接" title="11.3.3. 并行排序-给数组赋值的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static void parallelSort() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int[] bigArr = new int[100];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.setAll(bigArr, ele -&gt; new Random().nextInt(200));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 并行赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Arrays.parallelSetAll(bigArr, ele -&gt; new Random().nextInt());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.sort(bigArr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 并行排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Arrays.parallelSort(bigArr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Arrays.stream(bigArr).forEach(System.out::println);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="114-completablefuture-接口-增强的-future">11.4. CompletableFuture 接口-增强的 Future<a href="#114-completablefuture-接口-增强的-future" class="hash-link" aria-label="11.4. CompletableFuture 接口-增强的 Future的直接链接" title="11.4. CompletableFuture 接口-增强的 Future的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1141-java-异步编程">11.4.1. java 异步编程<a href="#1141-java-异步编程" class="hash-link" aria-label="11.4.1. java 异步编程的直接链接" title="11.4.1. java 异步编程的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">异步的几种方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread 方式: 对耗时的任务新开一个线程, 主线程继续往下执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        缺点: 创建线程没有复用 (这个问题使用线程池可以解决。)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            异步任务无法获取最终的执行结果, 使用  FutureTask 可以解决</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Guava 库提供的 ListenableFuture 和 Futures 类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spring 框架提供的 @Async 等注解实现异步处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FutureTask 方式: 自 JDK 1.5 开始，引入了 Future 接口和实现 Future 接口的 FutureTask 类来表示异步计算结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    实现了 Future 接口还实现了 Runnable 接口，表示一种可生成结果的 Runnable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        缺点:使用还是比较复杂, 多个异步任务的组合比较, 依赖关系比较难表达</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CompletableFuture: 自 jdk1.8引入, 实现了 Future 和 CompletionStage 接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1142-原理介绍">11.4.2. 原理介绍<a href="#1142-原理介绍" class="hash-link" aria-label="11.4.2. 原理介绍的直接链接" title="11.4.2. 原理介绍的直接链接">​</a></h3><p>CompletableFuture 是超大型工具类, 方法巨多, 实现了 Future , CompletionStage, 主要是为了方便多线程异步任务的编排</p><p>Callable，有结果的同步行为，比如做蛋糕，产生蛋糕
Runnable，无结果的同步行为，比如喝牛奶，仅仅就是喝
Future，异步封装Callable/Runnable，比如委托给师傅（其他线程）去做糕点
CompletableFuture，封装Future，使其拥有回调功能，比如让师傅主动告诉我蛋糕做好了</p><p>创建时需要传递线程池, 不传则使用默认 pool</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1143-completablefuture-api">11.4.3. completablefuture api<a href="#1143-completablefuture-api" class="hash-link" aria-label="11.4.3. completablefuture api的直接链接" title="11.4.3. completablefuture api的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// supplyAsync方法, 关注返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//使用默认内置线程池ForkJoinPool.commonPool()，根据supplier构建执行任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//自定义线程，根据supplier构建执行任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// runAsync方法, 不支持不关注返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//使用默认内置线程池ForkJoinPool.commonPool()，根据runnable构建执行任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//自定义线程，根据runnable构建执行任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,  Executor executor)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 异步回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 做完第一个任务后，再做第二个任务。前后两个任务没有参数传递(即不关心上个任务的结果)，第二个任务(即这里的 action)也没有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public CompletableFuture&lt;Void&gt; thenRun(Runnable action);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 等效thenRun, 区别:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果你执行第一个任务的时候，传入了一个自定义线程池：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 调用thenRun方法执行第二个任务时，则第二个任务和第一个任务是共用同一个线程池。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 调用thenRunAsync执行第二个任务时，则第一个任务使用的是你自己传入的线程池，第二个任务使用的是ForkJoin线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 依赖上个任务的结果, 有传参, 无返回值 ( 第一个任务执行完成后，执行第二个回调方法任务，会将该任务的执行结果，作为入参，传递到回调方法中，但是回调方法是没有返回值的。)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thenAccept/thenAcceptAsync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 依赖上个任务结果, 有传参, 有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thenApply/thanApplyAsync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 某个任务异常, 执行的回调方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">exceptionally(e -&gt; {e.print...})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 某个任务执行完成后, 执行的回调方法   , 回调方法无返回值, 但是方法本身有返回值, 返回上个任务的结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">whenComplete((last_result, e) -&gt; {no return_value})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//某个任务执行完成后, 执行的回调方法   , 回调方法有返回值 , 方法本身返回回调方法的 result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">handle((last_result, e) -&gt; {return_value})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 多个任务组合处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// and 的关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thenCombine / thenAcceptBoth / runAfterBoth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 都表示：将两个CompletableFuture组合起来，只有这两个都正常执行完了，才会执行某个任务。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 区别在于：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// thenCombine：会将两个任务的执行结果作为方法入参，传递到指定方法中，且有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// thenAcceptBoth: 会将两个任务的执行结果作为方法入参，传递到指定方法中，且无返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// runAfterBoth 不会把执行结果当做方法入参，且没有返回值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// or 的关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">applyToEither / acceptEither / runAfterEither </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 都表示：将两个CompletableFuture组合起来，只要其中一个执行完了,就会执行某个任务 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 区别在于：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// applyToEither：会将已经执行完成的任务，作为方法入参，传递到指定方法中，且有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// acceptEither: 会将已经执行完成的任务，作为方法入参，传递到指定方法中，且无返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// runAfterEither： 不会把执行结果当做方法入参，且没有返回值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">AllOf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 所有任务都执行完成后，才执行 allOf返回的CompletableFuture。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//如果任意一个任务异常，allOf的CompletableFuture，执行get方法，会抛出异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">AnyOf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 任意一个任务执行完，就执行anyOf返回的CompletableFuture。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果执行的任务异常，anyOf的CompletableFuture，执行get方法，会抛出异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thenCompose/thenComposeAsync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在某个任务执行完成后，将该任务的执行结果,作为方法入参,去执行指定的方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 该方法会返回一个新的CompletableFuture实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 和 thenApply 区别:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// thenApply()接收的是前一个调用返回的结果，然后对该结果进行处理。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          它的功能相当于将CompletableFuture&lt;T&gt;转换成CompletableFuture&lt;U&gt;。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          转换的是泛型中的类型，是同一个CompletableFuture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// thenCompose()接收的是前一个调用的stage，返回flat之后的的CompletableFuture。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          他的功能是用来连接两个CompletableFuture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          是生成一个新的CompletableFuture</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 简单点比较，两者就像是map和flatMap的区别。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 注意:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Future需要获取返回值，才能获取异常信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// CompletableFuture代码中又使用了默认的线程池，处理的线程个数是电脑CPU核数-1。在大量请求过来的时候，处理逻辑复杂的话，响应会很慢。一般建议使用自定义线程池，优化线程池配置参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 自定义线程池时，注意饱和策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// CompletableFuture的get()方法是阻塞的，我们一般建议使用future.get(3, TimeUnit.SECONDS)。并且一般建议使用自定义线程池。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 但是如果线程池拒绝策略是DiscardPolicy或者DiscardOldestPolicy，当线程池饱和时，会直接丢弃任务，不会抛弃异常。因此建议，CompletableFuture线程池策略最好使用AbortPolicy，然后耗时的异步线程，做好线程池隔离哈</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1144-完成了就通知我-手动填充结果">11.4.4. 完成了就通知我-手动填充结果<a href="#1144-完成了就通知我-手动填充结果" class="hash-link" aria-label="11.4.4. 完成了就通知我-手动填充结果的直接链接" title="11.4.4. 完成了就通知我-手动填充结果的直接链接">​</a></h3><p>可作为函数调用的契约(真实返回值的包装)</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * CompletableFutureDemo  复杂的计算在 main thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CompletableFutureDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // block until main thread complete the complex compute, then print result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class AskTask implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private CompletableFuture&lt;Integer&gt; future;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public AskTask(CompletableFuture&lt;Integer&gt; future) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.future = future;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Integer integer = future.get();// 阻塞, CompletableFuture为 &quot;未完成&quot; 状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(integer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException | ExecutionException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CompletableFuture&lt;Integer&gt; future = new CompletableFuture&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(new AskTask(future)).start();// 启动等待线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // simulate complex compute</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 告知运算结果: 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        future.complete(100);// 此时为 &quot;完成&quot;状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1145-异步执行任务">11.4.5. 异步执行任务<a href="#1145-异步执行任务" class="hash-link" aria-label="11.4.5. 异步执行任务的直接链接" title="11.4.5. 异步执行任务的直接链接">​</a></h3><p>这个 demo 刚好和上面的 demo 相反, 负责的计算不在 main thread</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CompletableFuture&lt;Integer&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; calculate(20));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    // supplyAsync() 用于需要有返回值的场景, 可传递 pool</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    // runAsync() 用于无需返回值的场景, 可传递 pool</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // do sth else;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(supplyAsync.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static Integer calculate(Integer param) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // simulate complex calculation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return param * param;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1146-流式调用组合多个-function-和-异常处理">11.4.6. 流式调用组合多个 function 和 异常处理<a href="#1146-流式调用组合多个-function-和-异常处理" class="hash-link" aria-label="11.4.6. 流式调用组合多个 function 和 异常处理的直接链接" title="11.4.6. 流式调用组合多个 function 和 异常处理的直接链接">​</a></h3><p>线程串行化 (等待前置 任务完成后再...)</p><p>thenapply() 等待完成然后处理, 有返回值
thenrun() .... 没有返回值, 没有传入参数
thenaccept() 等待完成然后消费</p><p>带有 async 的方法则新任务是新开一个thread 执行, 不带 async 的方法则新任务是和前置任务共用 thread</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static void fluentApiDemo() throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; calculate(50))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .thenApply(i -&gt; Integer.toString(i)).thenApply(str -&gt; &quot;\&quot;&quot; + str + &quot;\&quot;&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .thenAccept(System.out::println);// 结果: &quot;2500&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//   也可以在流调用中使用 whencomplete((resp, e) -&gt; {})    异常处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//                  类似 的 handle(( resp, e) -&gt; {return ...}), 可以有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    future.get(); // 需要让 main thread 阻塞, 等待 calculate执行完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(future.get());// 阻塞 // 结果: null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static Integer calculate(Integer param) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // simulate complex calculation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return param * param;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>异常处理</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static void fluentApiDemo() throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; calculate(50))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //   也可以在流调用中使用 whencomplete((resp, e) -&gt; {})    异常处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//                  类似 的 handle(( resp, e) -&gt; {return ...}), 可以有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .exceptionally(e -&gt; {           // 对 calculate 方法的异常处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace(); // java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return 0; // 最终处理结果 : &quot;0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .thenApply(i -&gt; Integer.toString(i)).thenApply(str -&gt; &quot;\&quot;&quot; + str + &quot;\&quot;&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .thenAccept(System.out::println);// 结果: &quot;2500&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    future.get(); // 需要让 main thread 阻塞, 等待 calculate执行完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(future.get());// 阻塞 // 结果: null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static Integer calculate(Integer param) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = param/0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // simulate complex calculation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return param * param;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1147-组合多个-completablefuture">11.4.7. 组合多个 CompletableFuture<a href="#1147-组合多个-completablefuture" class="hash-link" aria-label="11.4.7. 组合多个 CompletableFuture的直接链接" title="11.4.7. 组合多个 CompletableFuture的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 顺序完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void composeCompletableFutureDemo() throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; calculate(20))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .thenCompose(i -&gt; CompletableFuture.supplyAsync(() -&gt; calculate(i)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 等待上一个future得到结果, 然后将上一个 future 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 结果传入(这俩 future 是依赖关系), 再次构造一个 future</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .thenApply(i -&gt; &quot;\&quot;&quot; + i + &quot;\&quot;&quot;).thenAccept(System.out::println);// 结果: &quot;160000&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    future.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 另一种组合的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 没有顺序, 但是都要完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void composeCompletableFutureDemo() throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CompletableFuture&lt;Void&gt; future = CompletableFuture.supplyAsync(() -&gt; calculate(20))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 首先完成前一个 future  和 跟着的 future (这俩future 没有任何关系), 然后将两者结果进行计算</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .thenCombine(CompletableFuture.supplyAsync(() -&gt; calculate(10)), (i, j) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;i=&quot; + i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;j=&quot; + j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return i + j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .thenApply(i -&gt; &quot;\&quot;&quot; + i + &quot;\&quot;&quot;).thenAccept(System.out::println);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 结果:i=400 j=100 &quot;500&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    future.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 没有顺序的组合方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CompletableFuture.allOf(f1,f2).join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 只要一个完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">applyToEither() 任一完成, 获取返回值, 处理然后又有新的返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">accepttoeither() </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">runaftereither()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="115-stampedlock-读写锁的改进">11.5. StampedLock-读写锁的改进<a href="#115-stampedlock-读写锁的改进" class="hash-link" aria-label="11.5. StampedLock-读写锁的改进的直接链接" title="11.5. StampedLock-读写锁的改进的直接链接">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="116-longadder-原子类的增强">11.6. LongAdder-原子类的增强<a href="#116-longadder-原子类的增强" class="hash-link" aria-label="11.6. LongAdder-原子类的增强的直接链接" title="11.6. LongAdder-原子类的增强的直接链接">​</a></h2><p>内部仍然使用 CAS 操作, 但是使用 &quot;热点数据分离&quot; 的思想, 类似 ConcurrentHashMap 将内部数据分离到多个 segment</p><p>LongAdder 将 AtomicInteger 内部的核心数据 value 分解为一个 数组, 每个 thread 访问就通过 hash 算法映射到数组其中一个元素进行计算, 最终的结果则是这个数组的求和累加</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="117-java8-内置函数式接口">11.7. java8 内置函数式接口<a href="#117-java8-内置函数式接口" class="hash-link" aria-label="11.7. java8 内置函数式接口的直接链接" title="11.7. java8 内置函数式接口的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1171-predicates谓词-断定">11.7.1. Predicates(谓词, 断定)<a href="#1171-predicates谓词-断定" class="hash-link" aria-label="11.7.1. Predicates(谓词, 断定)的直接链接" title="11.7.1. Predicates(谓词, 断定)的直接链接">​</a></h3><p><code>apply(T input): boolean</code> 输入一个对象，返回 true 或者 false</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Predicate&lt;String&gt; predicateStr = (str) -&gt; str.length() &gt; 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean test = predicateStr.test(&quot;ssss&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">log.info(test+&quot;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1172-functions函数">11.7.2. Functions(函数)<a href="#1172-functions函数" class="hash-link" aria-label="11.7.2. Functions(函数)的直接链接" title="11.7.2. Functions(函数)的直接链接">​</a></h3><p><code>apply(S input): T</code> Functions 接受一个参数，并产生一个结果。默认方法可以将多个函数串在一起（compse, andThen）</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">backToString.apply(&quot;123&quot;);     // &quot;123&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1173-suppliers生产者">11.7.3. Suppliers(生产者)<a href="#1173-suppliers生产者" class="hash-link" aria-label="11.7.3. Suppliers(生产者)的直接链接" title="11.7.3. Suppliers(生产者)的直接链接">​</a></h3><p>就好像一个 bean 工厂</p><p>Suppliers 产生一个给定的泛型类型的结果, 与 Functional 不同的是 Suppliers 不接受输入参数。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 由于personSupplier不接受输入参数, 则调用的是person的无参数Constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Supplier&lt;Person&gt; personSupplier = Person::new;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">personSupplier.get();   // new Person</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1174-consumers消费者">11.7.4. Consumers(消费者)<a href="#1174-consumers消费者" class="hash-link" aria-label="11.7.4. Consumers(消费者)的直接链接" title="11.7.4. Consumers(消费者)的直接链接">​</a></h3><p>Consumers 代表在一个单一的输入参数上执行操作。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1175-comparators比较器">11.7.5. Comparators(比较器)<a href="#1175-comparators比较器" class="hash-link" aria-label="11.7.5. Comparators(比较器)的直接链接" title="11.7.5. Comparators(比较器)的直接链接">​</a></h3><p>Comparators 在旧版本 Java 中是众所周知的。Java8 增加了各种默认方法的接口</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.name.compareTo(p2.name); // 升序, 若 p2.name.compareTo(p1.name) 则是降序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在 stream 中, stream.max(comparator) 取最大值, 需要 comparator 是升序排序器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 升序排序 也可以简写 Comparator.comparing(o -&gt; Long.valueOf(o.getVersion()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">comparator.compare(p1, p2);             // &gt; 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">comparator.reversed().compare(p1, p2);  // &lt; 0</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1176-optional">11.7.6. Optional<a href="#1176-optional" class="hash-link" aria-label="11.7.6. Optional的直接链接" title="11.7.6. Optional的直接链接">​</a></h3><p>可选对象, 是对 object 的一层包装</p><p>Optionals 是没有任何函数的接口，唯一作用是防止 NullPointerException 异常</p><p>Optional is a simple container for a value which may be null or non-null. Think of a method which may return a non-null result but sometimes return nothing. Instead of returning null you return an Optional in Java 8.
(Optional 是一个简单的容器，这个值可能是空的或者非空的。考虑到一个方法可能会返回一个 non-null 的值，也可能返回一个空值。为了不直接返回 null，我们在 Java 8 中就返回一个 Optional。)</p><p>常用 api:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Optional.of()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Optional.ofNullable()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Optional.empty()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public T orElse(T other)       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若内部 object 不为 null, 返回 object, 否则返回 other</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //          传入一个 method call, 则这个方法总是会执行, 无论内部 object是否为 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public T orElseGet(Supplier&lt;? extends T&gt; other)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //          method call 只会在 内部 object 为 null 时执行, 更推荐使用这个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void ifPresent(Consumer&lt;? super T&gt; consumer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类似 map(), 区别是 flatMap 返回的是一个没有包装的值, map()返回的是带包装的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* optional api 示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void test5() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Optional&lt;String&gt; opt = Optional.of(&quot;mama&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 不推荐使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(opt.isPresent()+&quot;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(opt.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(opt.orElse(&quot;elseValue&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    opt.ifPresent((s) -&gt; log.info(s.charAt(0)+&quot;&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    opt.flatMap((input) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null; // 返回的是一个Optionnal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    opt.map((input) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;// 返回的是一个Object</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return user.orElse(null);  //而不是 return user.isPresent() ? user.get() : null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return user.orElse(UNKNOWN_USER);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">eturn user.orElseGet(() -&gt; fetchAUserFromDatabase());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">user.ifPresent(System.out::println);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return user.map(u -&gt; u.getOrders()).orElse(Collections.emptyList())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 最佳实践</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> private String getName2(User_1 user_1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Optional.ofNullable(user_1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .map(user1 -&gt; user1.user_2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .map(user_2 -&gt; user_2.name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .orElseThrow(RuntimeException::new);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>optional 直接生成 stream</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Optional&lt;String&gt; optional = Optional.of(&quot;ggg&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// java 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Stream&lt;String&gt; texts = optional.map(Stream::of).orElseGet(Stream::empty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Stream&lt;String&gt; hello = Optional.of(new String[] {&quot;hello&quot;, &quot;aa&quot;, &quot;bb&quot;}).map(Stream::of).orElseGet(Stream::empty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// java 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Stream&lt;String&gt; texts = optional.stream();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="118-streams管道">11.8. Streams(管道)<a href="#118-streams管道" class="hash-link" aria-label="11.8. Streams(管道)的直接链接" title="11.8. Streams(管道)的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1181-stream-介绍">11.8.1. stream 介绍<a href="#1181-stream-介绍" class="hash-link" aria-label="11.8.1. stream 介绍的直接链接" title="11.8.1. stream 介绍的直接链接">​</a></h3><p><a href="https://github.com/biezhi/learn-java8/blob/master/java8-stream/README.md" target="_blank" rel="noopener noreferrer">https://github.com/biezhi/learn-java8/blob/master/java8-stream/README.md</a></p><ul><li><p><code>java.util.Stream</code></p></li><li><p>流是一个源产生的，例如 java.util.Collection(比如:Collection.stream()或 Collection.parallelStream())</p></li><li><p>操作的都是集合的视图, 原集合没有变化</p></li><li><p>Parallel Streams(并行管道): 通过<code>list.parallelStream()</code>获取 paralled stream, 效率极大提升</p></li><li><p>stream 只能使用一次, 重复使用需要构造一个 Supplier</p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">IntStream.range(1, 4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .forEach(System.out::println);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Arrays.stream(new int[] {1, 2, 3})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(n -&gt; 2 * n + 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .average()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .ifPresent(System.out::println);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1182-重复使用-stream">11.8.2. 重复使用 stream<a href="#1182-重复使用-stream" class="hash-link" aria-label="11.8.2. 重复使用 stream的直接链接" title="11.8.2. 重复使用 stream的直接链接">​</a></h3><p>通过 supplier: (本质就是调用 get() 时 重新生成了流, 所以, 流生成不能写在 supplier 外部)</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Supplier&lt;Stream&lt;String&gt;&gt;  supplier = () -&gt; Stream.of(&quot;hello&quot;, &quot;aa&quot;, &quot;bb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean        aa    = supplier.get().allMatch(s -&gt; s.equalsIgnoreCase(&quot;aa&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean        aa1   = supplier.get().anyMatch(s -&gt; s.equalsIgnoreCase(&quot;aa&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(aa);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(aa1);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1183-map-和-flatmap">11.8.3. map 和 flatMap<a href="#1183-map-和-flatmap" class="hash-link" aria-label="11.8.3. map 和 flatMap的直接链接" title="11.8.3. map 和 flatMap的直接链接">​</a></h3><p>map 接收一个函数, 函数返回处理后的 stream</p><p>flatmap, 接受一个函数, 函数返回 stream, 最后会将各个 stream 合并为一个 stream</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1184-去重">11.8.4. 去重<a href="#1184-去重" class="hash-link" aria-label="11.8.4. 去重的直接链接" title="11.8.4. 去重的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">stream 有 distinct()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">根据某个 object 属性去重:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">studentList = studentList.stream().collect(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      collectingAndThen(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Student::getName))), ArrayList::new)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1185-collect方法-如何收集处理后的元素-分组-去重">11.8.5. collect方法 如何收集处理后的元素 分组 去重<a href="#1185-collect方法-如何收集处理后的元素-分组-去重" class="hash-link" aria-label="11.8.5. collect方法 如何收集处理后的元素 分组 去重的直接链接" title="11.8.5. collect方法 如何收集处理后的元素 分组 去重的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// set , 去重</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;a&quot;).collect(Collectors.toSet()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 转换为特定 集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TreeSet&lt;String&gt; treeSet = Stream.of(&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;).collect(Collectors.toCollection(TreeSet::new));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//对于string列表去重</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List stringList；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stringList = stringList.stream().distinct().collect(Collectors.toList());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于实体类的去重</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//通过hashcode()和equals()方法来获取不同元素，因此需要去重的类必须实现hashcode()和equals()方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List studentList；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">studentList = studentList.stream().distinct().collect(Collectors.toList());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 根据 List 中 Object 某个属性去重(姓名去重)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List studentList;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">studentList = studentList.stream()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.collect(collectingAndThen(toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Student::getName))), ArrayList::new));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//根据List 中 Object 多个属性去重(姓名，年龄去重)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ListstudentList；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">studentList=studentList.stream()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(o -&gt; o.getName() + “;” + o.getAge()))), ArrayList::new));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//参数:  toMap(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //     keyMapper,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //     valueMapper,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //     mergeFunction // biFunction(oldVal, newVal) 表示 若 构造当前键值对时, key 对应的 value 已经存在, 则使用这个方法生成新的 value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;String, String&gt; collect = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;).collect(Collectors.toMap(x -&gt; x, x -&gt; x + x,(oldVal, newVal) -&gt; newVal)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Collectors.minBy(Integer::compare)：求最小值，相对应的当然也有maxBy方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Collectors.averagingInt(x-&gt;x)：求平均值，同时也有averagingDouble、averagingLong方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Collectors.summingInt(x -&gt; x))：求和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Collectors.summarizingDouble(x -&gt; x)：可以获取最大值、最小值、平均值、总和值、总数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DoubleSummaryStatistics summaryStatistics = Stream.of(1, 3, 4).collect(Collectors.summarizingDouble(x -&gt; x));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(summaryStatistics .getAverage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Collectors.groupingBy(x -&gt; x)：有三种方法，查看源码可以知道前两个方法最终调用第三个方法，第二个参数默认HashMap::new  第三个参数默认Collectors.toList()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;Integer, List&lt;Integer&gt;&gt; map = Stream.of(1, 3, 3, 2).collect(Collectors.groupingBy(Function.identity()));//identity()是Function类的静态方法,和 x-&gt;x 是一个意思,当仅仅需要自己返回自己时,使用identity()能更清楚的表达作者的意思.写的复杂一点,绕一点,对理解很有好处</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;Integer, Integer&gt; map1 = Stream.of(1, 3, 3, 2).collect(Collectors.groupingBy(Function.identity(), Collectors.summingInt(x -&gt; x)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HashMap&lt;Integer, List&lt;Integer&gt;&gt; hashMap = Stream.of(1, 3, 3, 2).collect(Collectors.groupingBy(Function.identity(), HashMap::new, Collectors.mapping(x -&gt; x + 1, Collectors.toList())));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Collectors.partitioningBy(x -&gt; x &gt; 2)，把数据分成两部分，key为ture/false。第一个方法也是调用第二个方法，第二个参数默认为Collectors.toList()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;Boolean, List&lt;Integer&gt;&gt; map = Stream.of(1, 3, 3, 2).collect(Collectors.partitioningBy(x -&gt; x &gt; 2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;Boolean, Long&gt; longMap = Stream.of(1, 3, 3, 2).collect(Collectors.partitioningBy(x -&gt; x &gt; 1, Collectors.counting()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Collectors.joining(&quot;,&quot;)：拼接字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(Stream.of(&quot;1&quot;, &quot;3&quot;, &quot;3&quot;, &quot;2&quot;).collect(Collectors.joining(&quot;,&quot;)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Collectors.collectingAndThen(Collectors.toList(), x -&gt; x.size())：先执行collect操作后再执行第二个参数的表达式。这里是先塞到集合，再得出集合长度。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer integer = Stream.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;).collect(Collectors.collectingAndThen(Collectors.toList(), x -&gt; x.size()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Collectors.mapping(...)：跟Stream的map操作类似，只是参数有点区别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(Stream.of(1, 3, 5).collect(Collectors.mapping(x -&gt; x + 1, Collectors.toList())));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1186-stream-中异常处理">11.8.6. stream 中异常处理<a href="#1186-stream-中异常处理" class="hash-link" aria-label="11.8.6. stream 中异常处理的直接链接" title="11.8.6. stream 中异常处理的直接链接">​</a></h3><p><a href="https://cloud.tencent.com/developer/article/1429208" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1429208</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="119-date-时间日期新的-api">11.9. date 时间日期新的 api<a href="#119-date-时间日期新的-api" class="hash-link" aria-label="11.9. date 时间日期新的 api的直接链接" title="11.9. date 时间日期新的 api的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1191-介绍-为什么使用">11.9.1. 介绍-为什么使用<a href="#1191-介绍-为什么使用" class="hash-link" aria-label="11.9.1. 介绍-为什么使用的直接链接" title="11.9.1. 介绍-为什么使用的直接链接">​</a></h3><p>吸收了 <a href="http://www.joda.org/joda-time/" target="_blank" rel="noopener noreferrer">joda date api</a> 这个开源实现</p><p>为什么使用呢:</p><ul><li><p>Java8 之前我们常用 SimpleDateFormat, Date, Calander, 繁琐, 而且线程不安全</p></li><li><p>Java8 以前使用 new Date()获取月时，从 0 开始，每次都要+1。获取本月最后一天，要分情况判断 28，29，30，31</p></li><li><p>时区处理不方便</p></li></ul><p>LocalDate，LocalTime，LocalDateTime.... , 位于 java.time 包下, final 不可继承</p><ul><li>ZoneId: 时区 ID，用来确定 Instant 和 LocalDateTime 互相转换的规则</li><li>Instant: 用来表示时间线上的一个点</li><li>LocalDate: 表示没有时区的日期, LocalDate 是不可变并且线程安全的</li><li>LocalTime: 表示没有时区的时间, LocalTime 是不可变并且线程安全的</li><li>LocalDateTime: 表示没有时区的日期时间, LocalDateTime 是不可变并且线程安全的</li><li>ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差
ZoneOffSet和ZoneId类</li><li>Clock: 用于访问当前时刻、日期、时间，用到时区</li><li>Duration: 用秒和纳秒表示时间的数量</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1192-使用新的时间日期-api">11.9.2. 使用新的时间日期 api<a href="#1192-使用新的时间日期-api" class="hash-link" aria-label="11.9.2. 使用新的时间日期 api的直接链接" title="11.9.2. 使用新的时间日期 api的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 构造</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate.now();  // 获取当前日期 format: yyyy-MM-dd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalTime.now();  // 获取当前时间 format: HH:mm:ss</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime.now();  // 获取当前日期时间 format: yyyy-MM-ddTHH:mm:ss</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate.of(2017, 07, 20);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime.of(2017, Month.JULY, 20, 15, 18);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime.parse(&quot;2017-07-20T15:18:00&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate.parse(&quot;2017-07-20&quot;); // 可传入 formatter 指定格式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalTime nowTime = LocalTime.parse(&quot;15:02&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalTime nowTime = LocalTime.of(15, 02);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 加减</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate tomorrow = LocalDate.now().plusDays(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate prevMonth = LocalDate.now().minus(1, ChronoUnit.MONTHS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 一个小时后的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalTime nextHour = LocalTime.parse(&quot;15:02&quot;).plus(1, ChronoUnit.HOURS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime tomorrow = now.plusDays(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;明天的这个时间: &quot; + tomorrow);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime minusTowHour = now.minusHours(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;两小时前: &quot; + minusTowHour);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//获取时间, 日期, 月份, 星期, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 一系列的get方法来获取特定单位:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate date = LocalDate.parse(&quot;2017-07-20&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 星期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DayOfWeek thursday = date.getDayOfWeek();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;周四: &quot; + thursday);// 周四: THURSDAY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 日期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int twenty = LocalDate.parse(&quot;2017-07-20&quot;).getDayOfMonth();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;twenty: &quot; + twenty);// twenty: 20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 月份</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int month = date.getMonthValue()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Month month = now.getMonth();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 年份</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int year = date.getYear()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 获取本月第一天</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate firstDayOfMonth = LocalDate.parse(&quot;2017-07-20&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .with(TemporalAdjusters.firstDayOfMonth());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;这个月的第一天: &quot; + firstDayOfMonth);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">firstDayOfMonth = firstDayOfMonth.withDayOfMonth(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;这个月的第一天: &quot; + firstDayOfMonth);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int hour = LocalTime.parse(&quot;15:02&quot;).getHour();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;小时: &quot; + hour);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int minute = LocalTime.parse(&quot;15:02&quot;).getMinute();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;分钟: &quot; + minute);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 每天的开始结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(LocalTime.MAX);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(LocalTime.MIN);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 23:59:59.999999999</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 00:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 比较日期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 是否相等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate date1 = LocalDate.of(2014, 01, 14);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if(date1.equals(today)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.printf(&quot;Today %s and date1 %s are same date %n&quot;, today, date1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 判断是否之前之后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean notBefore = LocalDate.parse(&quot;2017-07-20&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .isBefore(LocalDate.parse(&quot;2017-07-22&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;notBefore: &quot; + notBefore);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean isAfter = LocalDate.parse(&quot;2017-07-20&quot;).isAfter(LocalDate.parse(&quot;2017-07-22&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;isAfter: &quot; + isAfter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 判断周期性事件 (不带年份的日期)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 生日</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//判断今天是否是我的生日，例如我的生日是 2009-07-20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate birthday = LocalDate.of(2009, 07, 20);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// monthday 表示 不带年的日期, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//可以用它判断每年都会发生事件, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MonthDay today = MonthDay.from(LocalDate.now());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;今天是否是我的生日: &quot; + today.equals(birthdayMd));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 信用卡到期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// YearMonth 不带时间的年月</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">YearMonth currentYearMonth = YearMonth.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.printf(&quot;current year-month is %s, has %d days&quot;, currentYearMonth, currentYearMonth.lengthOfMonth());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">YearMonth creditCardExpiry = YearMonth.of(2018, Month.FEBRUARY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.printf(&quot;Your credit card expires on %s &quot;, creditCardExpiry);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// current year-month is 2014-01: has 31 days</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Your credit card expires on 2018-02</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 是否闰年</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean leapYear = LocalDate.now().isLeapYear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;是否闰年: &quot; + leapYear);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 间隔</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////Period类表示一段时间, 用于修改给定日期或获得的两个日期之间的间隔</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate initialDate = LocalDate.parse(&quot;2017-07-20&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate finalDate   = initialDate.plus(Period.ofDays(5));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;初始化日期: &quot; + initialDate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;加日期之后: &quot; + finalDate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDate java8Release = LocalDate.of(2014, Month.MARCH, 14);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Period periodToNextJavaRelease = Period.between(today, java8Release);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;Months left between today and Java 8 release : &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   + periodToNextJavaRelease.getMonths() );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Months left between today and Java 8 release : 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final long duration = Duration.between(LocalDateTime.now(), latestTime.toInstant()).getSeconds();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//////////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 格式化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime now = LocalDateTime.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;默认格式化: &quot; + now);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;自定义格式化: &quot; + now.format(dateTimeFormatter));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime localDateTime = LocalDateTime.parse(&quot;2017-07-20 15:27:44&quot;, dateTimeFormatter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;字符串解析 LocalDateTime: &quot; + localDateTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String dateString = dateTimeFormatter.format(LocalDate.now());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;日期转字符串: &quot; + dateString);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 与遗留代码转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Date和Instant互相转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Date date = Date.from(Instant.now());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Instant instant = date.toInstant();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Date转换为LocalDateTime</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Date startDate=new Date();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime localDateTime = startDate.toInstant()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .atZone(ZoneId.systemDefault())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .toLocalDateTime()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// LocalDateTime转Date</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Date date =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// LocalDate转Date</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Date date =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Instant timestamp = Instant.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;What is value of this instant &quot; + timestamp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// What is value of this instant 2014-01-14T08:33:33.379Z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Clock时钟类 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//用于获取当时的时间戳，或当前时区下的日期时间信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// System.currentTimeMillis()和TimeZone.getDefault()的地方都可用Clock替换。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void clock(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据系统时间返回当前时间并设置为UTC。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Clock clock = Clock.systemUTC();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;Clock : &quot; + clock);//Clock : SystemClock[Z]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据系统时钟区域返回时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Clock defaultClock = Clock.systemDefaultZone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;Clock : &quot; + clock);//Clock : SystemClock[Z]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //指定时区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LocalDate.now(clock)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 时区和时差:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//时区: 代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域/城市构成（Asia/Tokyo），在加上与格林威治或 UTC的时差。例如：东京的时差是+09:00。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//时差: OffsetDateTime类实际上组合了LocalDateTime类和ZoneOffset类。用来表示包含和格林威治或UTC时差的完整日期（年、月、日）和时间（时、分、秒、纳秒）信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// OffSetDateTime是对计算机友好的，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ZoneDateTime则对人更友好</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 处理时区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ZoneId america = ZoneId.of(&quot;America/New_York&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime localtDateAndTime = LocalDateTime.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ZonedDateTime dateAndTimeInNewYork  = ZonedDateTime.of(localtDateAndTime, america );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;Current date and time in a particular timezone : &quot; + dateAndTimeInNewYork);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Current date and time in a particular timezone : 2014-01-14T16:33:33.373-05:00[America/New_York]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 时差</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LocalDateTime datetime = LocalDateTime.of(2014, Month.JANUARY, 14, 19, 30);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ZoneOffset offset = ZoneOffset.of(&quot;+05:30&quot;);//印度与GMT或UTC标准时区相差+05:30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">OffsetDateTime date = OffsetDateTime.of(datetime, offset);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;Date and Time with timezone offset in Java : &quot; + date);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Date and Time with timezone offset in Java : 2014-01-14T19:30+05:30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1193-统计代码耗时">11.9.3. 统计代码耗时<a href="#1193-统计代码耗时" class="hash-link" aria-label="11.9.3. 统计代码耗时的直接链接" title="11.9.3. 统计代码耗时的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">与系统时间完全无关，目的也正是用来统计程序耗时的。nanoTime()记录的是从某个固定的时刻起，到现在经过了多少纳秒。但是这个固定的时刻不是Unix时间戳的1970-1-1 00:00:00，而是启动虚拟机时生成的一个固定时刻，每个虚拟机的生成的这个时间都是不同的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nanoTime()虽然精确到纳秒，但事实并不是每纳秒都跳动一格，而是可能在3纳秒之后，一下跳动3格</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long start = System.nonoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 业务逻辑代码...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long end = System.nonoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long timeElapsed = finish - end; // 单位为纳秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Instant start = Instant.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 业务逻辑代码...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Instant end = Instant.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long timeElapsed = Duration.between(start, finish).toMillis(); // 单位为毫秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;version&gt;3.7&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">StopWatch watch = new StopWatch();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">watch.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 业务逻辑代码...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">watch.stop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;Time Elapsed: &quot; + watch.getTime() + &quot;ms&quot;); // 单位为毫秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1110-可重复的-annotations">11.10. 可重复的 Annotations<a href="#1110-可重复的-annotations" class="hash-link" aria-label="11.10. 可重复的 Annotations的直接链接" title="11.10. 可重复的 Annotations的直接链接">​</a></h2><p>在 Java8 中注解是可以重复的</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@interface Hint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String value();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Target({ ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ElementType.PARAMETER })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public @interface Hints {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Hint[] value();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 效果同上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Repeatable(Hints.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@interface Hint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String value();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1111-base64-编码">11.11. base64 编码<a href="#1111-base64-编码" class="hash-link" aria-label="11.11. base64 编码的直接链接" title="11.11. base64 编码的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">final Base64.Decoder decoder = Base64.getDecoder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final Base64.Encoder encoder = Base64.getEncoder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final String text = &quot;字串文字&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//编码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final String encodedText = encoder.encodeToString(textByte);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(encodedText);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//解码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1112-map-映射的新方法">11.12. map 映射的新方法<a href="#1112-map-映射的新方法" class="hash-link" aria-label="11.12. map 映射的新方法的直接链接" title="11.12. map 映射的新方法的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// &gt;&gt;&gt; compute 对key存在的元素进行加工，并返回加工后的元素，同时map中该元素也被替换成加工后的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KeyAndValue a1 = new KeyAndValue().setName(&quot;kevin&quot;).setValue(&quot;lee&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KeyAndValue a5 = new KeyAndValue().setName(&quot;kevin2&quot;).setValue(&quot;lee5&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KeyAndValue a6 = new KeyAndValue().setName(&quot;kevin3&quot;).setValue(&quot;lee8&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;String, KeyAndValue&gt; maps = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">maps.put(&quot;a&quot;,a1); //{a=KeyAndValue(name=kevin, value=lee)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//key存在时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KeyAndValue compute1 = maps.compute(&quot;a&quot;, (k, old) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Optional.ofNullable(old).ifPresent(v -&gt; v.setValue(old.getValue().concat(&quot;__ddddd&quot;)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(compute1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// KeyAndValue(name=kevin, value=lee__ddddd)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(maps);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// {a=KeyAndValue(name=kevin, value=lee__ddddd)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// key不存在时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KeyAndValue compute = maps.compute(&quot;b&quot;, (k, v) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Optional.ofNullable(v).ifPresent(v1 -&gt; v1.setValue(v.getValue().concat(&quot;__ddddd&quot;)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(compute);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(maps);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// {a=KeyAndValue(name=kevin, value=lee__ddddd)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// &gt;&gt;&gt; 针对value不存在和存在，也有针对性的方法（computeIfAbsent和computeIfPresent）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//computeIfAbsent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// key不存在或null，则会处理，返回处理后结果，并更新value (即, key, 和 newValue 会 mapping 上)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// key存在，则不会进行处理，返回value，不更新map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//computeIfPresent ，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// key存在则处理，返回处理后结果，并更新value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// key不存在或null，则不进行处理，返回null，不更新value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;String, KeyAndValue&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KeyAndValue computeIfAbsent = map.computeIfAbsent(&quot;a&quot;, k -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(computeIfAbsent);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// KeyAndValue(name=kevin3, value=lee8)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// {a=KeyAndValue(name=kevin3, value=lee8)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// &gt;&gt;&gt;merge:对key存在的元素进行合并新元素，并返回加工后的元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;String, KeyAndValue&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">map.put(&quot;a&quot;,a1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// {a=KeyAndValue(name=kevin, value=lee)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//“a”有值，则合并</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//a6就是合进来的新值，a6和newV是同一对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//oldV是map中原有key对应的值，oldV有值则合并，无值则新增对应的k和value=newV的键值对</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KeyAndValue merge = map.merge(&quot;a&quot;, a6, (oldV, newV) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    oldV.setValue(newV.getValue()+&quot;___&quot;+oldV.getValue());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return oldV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(merge);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// KeyAndValue(name=kevin, value=lee8___lee)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// {a=KeyAndValue(name=kevin, value=lee8___lee)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//“b”无值，则新增&quot;b&quot;:newV</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KeyAndValue merge1 = map.merge(&quot;b&quot;, a5, (oldV, newV) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    oldV.setValue(oldV.getValue()+&quot;___&quot;+oldV.getValue());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return oldV;    //a5就是合进来的新值，a5和newV是同一对象，所以newV和a5可互换；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // oldV是map中原有key=“b”对应的值，oldV有值则合并，无值则新增</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(merge1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// KeyAndValue(name=kevin2, value=lee5)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// {a=KeyAndValue(name=kevin, value=lee), b=KeyAndValue(name=kevin2, value=lee5)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>12. java11</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="121-java-module">12.1. java module<a href="#121-java-module" class="hash-link" aria-label="12.1. java module的直接链接" title="12.1. java module的直接链接">​</a></h2><p>Java 模块化开发: 增加了更高级别的聚合，是Package的封装体</p><p>java9以前 ：package =&gt; class/interface。
java9以后 ：module =&gt; package =&gt; class/interface。</p><p>为什么这么做？
大家都知道JRE中有一个超级大的rt.jar(60多M)，tools.jar也有几十兆，以前运行一个hello world也需要上百兆的环境。</p><ul><li>更加容易轻量级部署</li><li>在 package 之上, 增加了一个更高层级的封装</li></ul><p><code>java --list-modules</code> 查看jdk被分拆为哪些 module</p><p>模块的是通过module-info.java进行定义，编译后打包后，就成为一个模块的实体</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// open 用来指定开放模块,开放模块的所有包都是公开的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">open module module.one {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 导入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // opens 用来指定开放的包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    opens java.logging;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //声明依赖关系, opens resuires xxx 亦可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requires java.logging;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module module.one {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> exports &lt;package&gt;;//exports用于指定模块下的哪些包可以被其他模块访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> exports &lt;package&gt; to &lt;module1&gt;, &lt;module2&gt;...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//uses语句使用服务接口的名字,当前模块就会发现它,使用java.util.ServiceLoader类进行加载,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module module.one {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> //对外提供的接口服务 ,下面指定的接口以及提供服务的impl，如果有多个实现类，用用逗号隔开</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> uses &lt;接口名&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> provides &lt;接口名&gt; with &lt;接口实现类&gt;,&lt;接口实现类&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><a href="https://www.zhihu.com/question/40413806/answer/135807272" target="_blank" rel="noopener noreferrer">为什么 Java 9 模块化使用 Jigsaw 而不是 OSGi？</a></li><li><a href="http://www.cnblogs.com/chenjianjx/archive/2012/05/24/2516620.html" target="_blank" rel="noopener noreferrer">osgi 入门</a> , <a href="https://www.cnblogs.com/zhangpan1244/p/11677705.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/zhangpan1244/p/11677705.html</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="122-jshell">12.2. jshell<a href="#122-jshell" class="hash-link" aria-label="12.2. jshell的直接链接" title="12.2. jshell的直接链接">​</a></h2><p>some classes already import into the console</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="123-var-类型推断">12.3. var 类型推断<a href="#123-var-类型推断" class="hash-link" aria-label="12.3. var 类型推断的直接链接" title="12.3. var 类型推断的直接链接">​</a></h2><p>局部类型变量推断。它会根据后面的值来推断变量的类型，所以var必须要初始化。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var a = 1; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">等于</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>var不能再哪里使用？</p><p>类成员变量类型。
方法返回值类型。
Java10中Lambda不能使用var，Java11中可以使用。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="124-jdk-api-enhencement">12.4. jdk api enhencement<a href="#124-jdk-api-enhencement" class="hash-link" aria-label="12.4. jdk api enhencement的直接链接" title="12.4. jdk api enhencement的直接链接">​</a></h2><p>string 增强: 判断是否空白, 去除空格...
集合增强: of, copyOf, create immutable collection
stream 和 option 增强: 可以相互转换, </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 判断字符串是否为空白</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot; &quot;.isBlank(); // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 去除首尾空格</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot; Hello Java11 &quot;.strip(); // &quot;Hello Java11&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 去除尾部空格 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot; Hello Java11 &quot;.stripTrailing(); // &quot; Hello Java11&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 去除首部空格 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot; Hello Java11 &quot;.stripLeading(); // &quot;Hello Java11 &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 复制字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;Java11&quot;.repeat(3); // &quot;Java11Java11Java11&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 行数统计</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;A\nB\nC&quot;.lines().count(); // 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建不可变集合。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var list = List.of(&quot;Java&quot;, &quot;Python&quot;, &quot;C&quot;); //不可变集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> var copy = List.copyOf(list); //copyOf判断是否是不可变集合类型，如果是直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> System.out.println(list == copy); // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> var list = new ArrayList&lt;String&gt;(); // 这里返回正常的集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> var copy = List.copyOf(list); // 这里返回一个不可变集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> System.out.println(list == copy); // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">以前</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Stream.of(null); //报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">现在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Stream.ofNullable(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// http client 支持同步异步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var request = HttpRequest.newBuilder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .uri(URI.create(&quot;https://www.baidu.com/&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> var client = HttpClient.newHttpClient();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> // 同步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> System.out.println(response.body());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> // 异步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; sendAsync = client.sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> //这里会阻塞</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> HttpResponse&lt;String&gt; response1 = sendAsync.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> System.out.println(response1.body());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="125-改进-java-程序在-docker-中的表现">12.5. 改进 java 程序在 docker 中的表现<a href="#125-改进-java-程序在-docker-中的表现" class="hash-link" aria-label="12.5. 改进 java 程序在 docker 中的表现的直接链接" title="12.5. 改进 java 程序在 docker 中的表现的直接链接">​</a></h2><p>JVM现在可以识别由容器控制组（cgroups）设置的约束。可以在容器中使用内存和CPU约束来直接管理Java应用程序，其中包括：</p><p>遵守容器中设置的内存限制
在容器中设置可用的CPU
在容器中设置CPU约束</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="126-新的垃圾回收器">12.6. 新的垃圾回收器<a href="#126-新的垃圾回收器" class="hash-link" aria-label="12.6. 新的垃圾回收器的直接链接" title="12.6. 新的垃圾回收器的直接链接">​</a></h2><h1>13. classloader 类加载器</h1><p><a href="https://www.cnblogs.com/doit8791/p/5820037.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/doit8791/p/5820037.html</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="131-classloader-的概念">13.1. classloader 的概念<a href="#131-classloader-的概念" class="hash-link" aria-label="13.1. classloader 的概念的直接链接" title="13.1. classloader 的概念的直接链接">​</a></h2><p>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。除此之外，ClassLoader 还负责加载 Java 应用所需的资源，如图像文件和配置文件等</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="132-层级结构">13.2. 层级结构<a href="#132-层级结构" class="hash-link" aria-label="13.2. 层级结构的直接链接" title="13.2. 层级结构的直接链接">​</a></h2><p>树状结构:</p><p>分类. <!-- -->[父 -&gt; 子 关系]<!-- -->是这样的: 引导类加载器（bootstrap class loader）-&gt; 扩展类加载器（extensions class loader） -&gt; 系统类加载器（system class loader） -&gt; user-defined classloader</p><ul><li><p>系统(jvm) 提供的 classloader</p><ul><li><p>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库 (rt.jar 中的所有 class)，由 C++编写的，它本身是虚拟机的一部分，并不是一个 JAVA 类，并不继承自 java.lang.ClassLoader, 没有 parent</p></li><li><p>扩展类加载器（extensions class loader）： <code>ExtClassLoader</code>, 它用来加载 Java 的扩展库(Java 虚拟机的实现会提供一个扩展库目录, 该类加载器在此目录里面查找并加载 Java 类)。</p></li><li><p>系统类加载器（app class loader）： <code>AppClassLoader</code>, 它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。Java 应用的类都是由它来完成加载的。可以通过 <code>ClassLoader.getSystemClassLoader()</code>来获取它。</p></li><li><p>自定义的 classloader - 通过继承 <code>java.lang.ClassLoader</code>抽象类的方式实现自己的类加载器, 可以用来<code>加载 非 classpath 中的 jar 和 目录 (比如从网络下载)</code>, <code>在加载 class 前 做其他事情, 如解密</code> , <code>实现类隔离</code> (运行多个不同版本的 jar 包, check <a href="https://blog.csdn.net/t894690230/article/details/73252331" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/t894690230/article/details/73252331</a>)</p><ul><li><p>loadClass 方法 - 加载指定名称的类, (另一种加载 class 的方法 <code>Class.forName</code> 启动这个加载过程是通过调用 <code>loadClass</code>来实现的, 称为初始加载器（initiating loader）)</p></li><li><p>findLoadedClass 方法 - 从当前 classloader 实例的缓存中寻找已经加载的类</p></li><li><p><code>findClass方法</code> - 只需要覆盖这个方法, 自定义加载逻辑, 其他方法不动;</p></li><li><p>defineClass 方法 - 将 class 字节码转换为 Class 对象 (真正完成类的加载工作是通过调用 <code>defineClass</code>来实现的, 称为一个类的定义加载器（defining loader）)</p></li><li><p>defineClass() 和 loadClass() 两种加载方式的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer 引用了类 com.example.Inner，则由类 com.example.Outer 的定义加载器负责启动类 com.example.Inner 的加载过程。</p></li></ul></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="133-工作过程-and-双亲委派模式">13.3. 工作过程 and 双亲委派模式<a href="#133-工作过程-and-双亲委派模式" class="hash-link" aria-label="13.3. 工作过程 and 双亲委派模式的直接链接" title="13.3. 工作过程 and 双亲委派模式的直接链接">​</a></h2><ol><li><p>Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。</p></li><li><p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的<code>newInstance()</code>方法就可以创建出该类的一个对象</p><ol><li><p>类加载器在尝试 自己去查找某个类的字节代码并定义它 之前, 会先尝试通过 parent classloader 加载，如果无法加载，依次类推 -- <code>classloader的双亲委派模式</code> , 由于 <!-- -->[双亲委派模式]<!-- -->, 真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个;</p></li><li><p>为什么要有 classloader 双亲委派模式的设计? ------- 为了保证 Java 核心库的类型安全 (举个例子 🌰 -&gt; 所有 Java 应用都至少需要引用 java.lang.Object 类，也就是说在运行的时候，java.lang.Object 这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object 类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。)</p></li></ol></li><li><p>类加载器在成功加载某个类之后，会把得到的 java.lang.Class 类的实例缓存起来 - 对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass 方法不会被重复调用。</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="134-线程上下文类加载器-打乱层级结构">13.4. 线程上下文类加载器-打乱层级结构<a href="#134-线程上下文类加载器-打乱层级结构" class="hash-link" aria-label="13.4. 线程上下文类加载器-打乱层级结构的直接链接" title="13.4. 线程上下文类加载器-打乱层级结构的直接链接">​</a></h2><p>线程上下文类加载器（context class loader）只是一个概念 , 类 <code>java.lang.Thread</code>中的方法 <code>getContextClassLoader()</code>和 <code>setContextClassLoader(ClassLoader cl)</code>用来获取和设置线程的上下文类加载器</p><p>主要是为了解决一个双亲委派模式的 bug , 举个例子 🌰: Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现(常见的 SPI 有 JDBC, JAXP..., ) , 这些实现由<code>app class loader</code>来加载, 而这些 SPI 的接口由 Java 核心库来提供, 是通过<code>引导类加载器 bootstrap class loader</code>来加载). 引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 app class loader ，因为 bootstrap class loader 在 app class loader 的上层, 也就是说，类加载器的双亲委派模式无法解决这个问题。</p><p>线程上下文类加载器正好解决了这个问题 <!-- -->[在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类]</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="135-借助-classloader-实现类隔离">13.5. 借助 classloader 实现类隔离<a href="#135-借助-classloader-实现类隔离" class="hash-link" aria-label="13.5. 借助 classloader 实现类隔离的直接链接" title="13.5. 借助 classloader 实现类隔离的直接链接">​</a></h2><p>不同的类加载器为各自加载的类创建了额外的名称空间, 即使各自加载的是相同名称的类。相同名称的类可以并存在 Java 虚拟机中，<code>只需要用不同的类加载器来加载它们即可</code>。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个<code>相互隔离的 Java 类空间</code>。这种技术在许多框架中都被用到</p><p>可以这么做的原理是:</p><p>Java 虚拟机是如何判定两个 Java 类是相同的? ------- 📌 类的全名是否相同 📌 加载此类的类加载器(实例对象 id)是否一样</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="136-类加载相关的异常">13.6. 类加载相关的异常<a href="#136-类加载相关的异常" class="hash-link" aria-label="13.6. 类加载相关的异常的直接链接" title="13.6. 类加载相关的异常的直接链接">​</a></h2><ul><li><p>classnotfoundException - 在当前的 classloader 中<code>加载 class 文件时没有找到</code></p><p>对于 system class loader, 只要 class path 中没有相应的 class 文件, 就抛异常;
对于 user-defined class loader 要到代码找找看, 看具体是从什么位置加载 class</p></li><li><p>NoClassDefFoundException - 加载的类引用了另外的类, 而这个&quot;另外的&quot;<code>引用类不存在or当前class loader无法加载引用的类</code></p><p>解决这个异常, 需要到异常类中找到引用到了哪些另外的类 , 然后看看这些另外的类是不是存在于能够被当前 class loader 加载到的位置</p></li><li><p>LinkageError - 加载某个 class 时, 这个 class 已经存在于当前的 class loader 中了 , 也就是 <code>重复的加载</code></p><p>自定义 class loader 中 and 并发下容易出现</p><p>这个机制也造成 jvm 无法直接更新一个已经加载过的 class, 只能创建一个新的 class loader 来加载更新后的 class, 然后将新请求转入新 class loader 来获取更新后的类 -------- 这也时动态更新的原理</p></li><li><p>ClassCastException - 转型异常</p><p>使用泛型可以规避</p><p>要注意两个同类型对象但是通过不同 class loader 加载的情况, 这种情况也会抛异常</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="137-自定义-classloader加载网络上的-class">13.7. 自定义 classloader(加载网络上的 class)<a href="#137-自定义-classloader加载网络上的-class" class="hash-link" aria-label="13.7. 自定义 classloader(加载网络上的 class)的直接链接" title="13.7. 自定义 classloader(加载网络上的 class)的直接链接">​</a></h2><p>场景: 应用通过网络来传输 Java 类的字节代码，为了保证安全性，这些字节代码经过了加密处理。这个时候就需要自己的类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出要在 Java 虚拟机中运行的类来</p><p>编写一个类继承自 ClassLoader 抽象类。
复写它的 findClass()方法。
在 findClass()方法中调用 defineClass()。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//文件系统类加载器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class FileSystemClassLoader extends ClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   private String rootDir;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public FileSystemClassLoader(String rootDir) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       this.rootDir = rootDir;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 自定义 classloader 重写 findClass 即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - java.lang.ClassLoader类的方法 loadClass()封装了前面提到的代理模式的实现。该方法会首先调用 findLoadedClass()方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 loadClass()方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 findClass()方法来查找该类。因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       byte[] classData = getClassData(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       if (classData == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           throw new ClassNotFoundException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           return defineClass(name, classData, 0, classData.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   private byte[] getClassData(String className) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       String path = classNameToPath(className);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           InputStream ins = new FileInputStream(path);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           int bufferSize = 4096;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           byte[] buffer = new byte[bufferSize];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           int bytesNumRead = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           while ((bytesNumRead = ins.read(buffer)) != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               baos.write(buffer, 0, bytesNumRead);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           return baos.toByteArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   private String classNameToPath(String className) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return rootDir + File.separatorChar</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               + className.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 网络类加载器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过网络下载 Java 类字节代码并定义出 Java 类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class NetworkClassLoader extends ClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String rootUrl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public NetworkClassLoader(String rootUrl) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.rootUrl = rootUrl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] classData = getClassData(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (classData == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new ClassNotFoundException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return defineClass(name, classData, 0, classData.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private byte[] getClassData(String className) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String path = classNameToPath(className);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            URL url = new URL(path);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            InputStream ins = url.openStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int bufferSize = 4096;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            byte[] buffer = new byte[bufferSize];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int bytesNumRead = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while ((bytesNumRead = ins.read(buffer)) != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                baos.write(buffer, 0, bytesNumRead);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return baos.toByteArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String classNameToPath(String className) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rootUrl + &quot;/&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                + className.replace(&#x27;.&#x27;, &#x27;/&#x27;) + &quot;.class&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CalculatorTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String url = &quot;http://localhost:8080/ClassloaderTest/classes&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        NetworkClassLoader ncl = new NetworkClassLoader(url);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String basicClassName = &quot;com.example.CalculatorBasic&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String advancedClassName = &quot;com.example.CalculatorAdvanced&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class&lt;?&gt; clazz = ncl.loadClass(basicClassName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ICalculator calculator = (ICalculator) clazz.newInstance();// 通过接口接收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(calculator.getVersion());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clazz = ncl.loadClass(advancedClassName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            calculator = (ICalculator) clazz.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(calculator.getVersion());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>14. 路径问题</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="141-获取-classpath-和-系统属性-环境变量">14.1. 获取 classpath 和 系统属性 环境变量<a href="#141-获取-classpath-和-系统属性-环境变量" class="hash-link" aria-label="14.1. 获取 classpath 和 系统属性 环境变量的直接链接" title="14.1. 获取 classpath 和 系统属性 环境变量的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">String str = Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;).getPath();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;-------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(str); // 我是在测试目录下, 所以结果是: /D:/repo/eclipse/etc-learn/target/test-classes/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String str1 = Thread.currentThread().getContextClassLoader().getResource(&quot;./&quot;).getPath();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(str1);// 无论是[.] 还是[./], 结果同 str</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String str2 = Thread.currentThread().getContextClassLoader().getResource(&quot;demo.properties&quot;).getPath();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(str2);// /D:/repo/eclipse/etc-learn/target/classes/demo.properties</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这种通过 .class 获取的路径, 不是 root classpath, 而是 该类所在的详细class path路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PathUtil.class.getResource(classpath).getPath()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//   /D:/repo/repo_github/shared_already/springboot-demos/groovy-demo/target/classes/io/github/xiaoyu/groovydemo/util/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>获取资源文件</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Properties props = new Properties();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">props.load(Thread.currentThread().getContextClassLoader()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里必须是 class path</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .getResourceAsStream(&quot;com/xiaoyu/learn/etc/schedule/quartz/simple/demo/quartz.properties&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过 System.getProperty(&quot;user.dir&quot;)</p><p>若是设置自定义参数, 可以在 jvm 参数中设置: <code>-Daaa=xxx</code>, 在 Tomcat 的  catalina.sh 中 配置 <code>JAVA_OPS=-Daaa=xxx</code></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.version          Java 运行时环境版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.vendor         Java 运行时环境供应商</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.vendor.url         Java 供应商的 URL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.vm.specification.version         Java 虚拟机规范版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.vm.specification.vendor         Java 虚拟机规范供应商</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.vm.specification.name         Java 虚拟机规范名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.vm.version         Java 虚拟机实现版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.vm.vendor         Java 虚拟机实现供应商</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.vm.name         Java 虚拟机实现名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.specification.version         Java 运行时环境规范版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.specification.vendor         Java 运行时环境规范供应商</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.specification.name         Java 运行时环境规范名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">os.name         操作系统的名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">os.arch         操作系统的架构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">os.version         操作系统的版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">file.separator         文件分隔符（在 UNIX 系统中是“ / ”）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path.separator         路径分隔符（在 UNIX 系统中是“ : ”）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">line.separator         行分隔符（在 UNIX 系统中是“ /n ”）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.home         Java 安装目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.class.version         Java 类格式版本号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.class.path         Java 类路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.library.path          加载库时搜索的路径列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.io.tmpdir         默认的临时文件路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.compiler         要使用的 JIT 编译器的名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.ext.dirs         一个或多个扩展目录的路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">user.name         用户的账户名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">user.home         用户的主目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">user.dir</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>15. 数据类型</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="151-各个数据类型的范围">15.1. 各个数据类型的范围<a href="#151-各个数据类型的范围" class="hash-link" aria-label="15.1. 各个数据类型的范围的直接链接" title="15.1. 各个数据类型的范围的直接链接">​</a></h2><p><a href="https://blog.csdn.net/qfikh/article/details/52832087" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qfikh/article/details/52832087</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="152-double-类型的加减乘除">15.2. double 类型的加减乘除<a href="#152-double-类型的加减乘除" class="hash-link" aria-label="15.2. double 类型的加减乘除的直接链接" title="15.2. double 类型的加减乘除的直接链接">​</a></h2><p>float : 单精度浮点数, 占 4 字节</p><p>double : 双精度浮点数 -- 编译器默认小数; 占据 8 字节</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//如果不声明，默认小数为double类型，所以如果要用float的话，必须进行强转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//例如：float  a=1.3; 会编译报错，正确的写法 float a = (float)1.3;或者float a = 1.3f;（f或F都可以不区分大小写）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DoubleArith {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int DEF_DIV_SCALE = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 两个Double数相加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return Double</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Double add(Double v1,Double v2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b1 = new BigDecimal(v1.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b2 = new BigDecimal(v2.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return b1.add(b2).doubleValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 两个Double数相减</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return Double</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Double sub(Double v1,Double v2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b1 = new BigDecimal(v1.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b2 = new BigDecimal(v2.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return b1.subtract(b2).doubleValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 两个Double数相乘</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return Double</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Double mul(Double v1,Double v2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b1 = new BigDecimal(v1.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b2 = new BigDecimal(v2.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return b1.multiply(b2).doubleValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 两个Double数相除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return Double</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Double div(Double v1,Double v2){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b1 = new BigDecimal(v1.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b2 = new BigDecimal(v2.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return b1.divide(b2,DEF_DIV_SCALE,BigDecimal.ROUND_HALF_UP).doubleValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 两个Double数相除，并保留scale位小数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param v2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param scale</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return Double</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Double div(Double v1,Double v2,int scale){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(scale&lt;0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;The scale must be a positive integer or zero&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b1 = new BigDecimal(v1.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BigDecimal b2 = new BigDecimal(v2.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return b1.divide(b2,scale,BigDecimal.ROUND_HALF_UP).doubleValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>16. 控制台命令</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="161-打-jar-包">16.1. 打 jar 包<a href="#161-打-jar-包" class="hash-link" aria-label="16.1. 打 jar 包的直接链接" title="16.1. 打 jar 包的直接链接">​</a></h2><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">jar cvf &lt;jar文件名&gt; &lt;class文件或文件夹&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>jar 包打好后，要指定入口类 即更改 manifest.mf 文件 格式：Main-Class: 包名.类名（不加.class)</li><li>jar 包双击运行只对图形界面起作用</li><li>非图形界面要用 bat 文件</li><li>如果是使用他人的 jar 包，要先设置 classpath</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="162-生成注释文档-javadoc">16.2. 生成注释文档 javadoc<a href="#162-生成注释文档-javadoc" class="hash-link" aria-label="16.2. 生成注释文档 javadoc的直接链接" title="16.2. 生成注释文档 javadoc的直接链接">​</a></h2><p><code>javadoc -d 存放文档的路径 java的源文件</code></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="163-编译和反编译">16.3. 编译和反编译<a href="#163-编译和反编译" class="hash-link" aria-label="16.3. 编译和反编译的直接链接" title="16.3. 编译和反编译的直接链接">​</a></h2><p>如果 Java 文件含有包【package】，则 <code>javac –d . Demo.java</code>-----【.】表示当前路径，即 class 文件路径
必须加【-d】，否则编译出来没有包文件夹。</p><p>运行时： <code>java com.xiaoyu.Demo</code></p><p>反编译: <code>javap -verbose class文件</code></p><h1>17. 重要的对象</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="171-object">17.1. Object<a href="#171-object" class="hash-link" aria-label="17.1. Object的直接链接" title="17.1. Object的直接链接">​</a></h2><p><a href="http://www.javacoder.cn/?p=274" target="_blank" rel="noopener noreferrer">http://www.javacoder.cn/?p=274</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="172-string">17.2. String<a href="#172-string" class="hash-link" aria-label="17.2. String的直接链接" title="17.2. String的直接链接">​</a></h2><h1>18. 字节码编辑技术</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="181-javassist">18.1. javassist<a href="#181-javassist" class="hash-link" aria-label="18.1. javassist的直接链接" title="18.1. javassist的直接链接">​</a></h2><p><a href="https://github.com/jboss-javassist/javassist" target="_blank" rel="noopener noreferrer">https://github.com/jboss-javassist/javassist</a>
<a href="https://www.cnblogs.com/rickiyang/p/11336268.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/rickiyang/p/11336268.html</a></p><h1>19. 前沿</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="191-graalvm">19.1. graalvm<a href="#191-graalvm" class="hash-link" aria-label="19.1. graalvm的直接链接" title="19.1. graalvm的直接链接">​</a></h2><p><a href="https://zhuanlan.zhihu.com/p/106555993" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/106555993</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="192-vertx">19.2. vertx<a href="#192-vertx" class="hash-link" aria-label="19.2. vertx的直接链接" title="19.2. vertx的直接链接">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="193-micronaut">19.3. Micronaut<a href="#193-micronaut" class="hash-link" aria-label="19.3. Micronaut的直接链接" title="19.3. Micronaut的直接链接">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="194-quarkus">19.4. Quarkus<a href="#194-quarkus" class="hash-link" aria-label="19.4. Quarkus的直接链接" title="19.4. Quarkus的直接链接">​</a></h2><h1>20. 拾遗</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="201-正则表达式-regex">20.1. 正则表达式 regex<a href="#201-正则表达式-regex" class="hash-link" aria-label="20.1. 正则表达式 regex的直接链接" title="20.1. 正则表达式 regex的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(&quot;v(\\d+)/&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Matcher m = VERSION_PREFIX_PATTERN.matcher(httpServletRequest.getRequestURI());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if(m.find()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Integer version = Integer.valueOf(m.group(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(version &gt;= this.apiVersion)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="202-静态绑定和动态绑定">20.2. 静态绑定和动态绑定<a href="#202-静态绑定和动态绑定" class="hash-link" aria-label="20.2. 静态绑定和动态绑定的直接链接" title="20.2. 静态绑定和动态绑定的直接链接">​</a></h2><p><a href="https://droidyue.com/blog/2014/12/28/static-biding-and-dynamic-binding-in-java/" target="_blank" rel="noopener noreferrer">https://droidyue.com/blog/2014/12/28/static-biding-and-dynamic-binding-in-java/</a></p><p>动态绑定是指编译器在编译阶段不知道要调用哪个方法，直到运行时才能确定</p><p>如果编译器可以在编译阶段就完成绑定，就叫作静态绑定</p><p>是否是静态绑定可以反编译 class 文件查看 <code>javap -c &lt;class_name&gt;</code></p><ul><li>静态绑定发生在编译时期，动态绑定发生在运行时</li><li>静态绑定使用类信息来完成，而动态绑定则需要使用对象信息来完成。</li><li>方法重载是静态绑定， 方法重写是动态绑定</li><li>使用 private 或 static 或 final 修饰的变量或者方法，使用静态绑定。而虚方法（可以被子类重写的方法）则会根据运行时的对象进行动态绑定。</li><li>重载(Overload)的方法使用静态绑定完成，而重写(Override)的方法则使用动态绑定完成。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="203-重载-and-重写">20.3. 重载 and 重写<a href="#203-重载-and-重写" class="hash-link" aria-label="20.3. 重载 and 重写的直接链接" title="20.3. 重载 and 重写的直接链接">​</a></h2><p>方法签名: 方法名称+方法参数 (不包括返回值)</p><ul><li>重载必须方法签名不同</li><li>重写必须方法签名相同</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="204-java-值传递-or-引用传递">20.4. java 值传递 or 引用传递<a href="#204-java-值传递-or-引用传递" class="hash-link" aria-label="20.4. java 值传递 or 引用传递的直接链接" title="20.4. java 值传递 or 引用传递的直接链接">​</a></h2><ul><li>基本数据类型, 是值传递 -- 相当于将参数复制了一份, 对形参的修改不会影响实参；</li><li>引用类型, 是引用传递 -- 相当于传递的是内存地址(这是为了避免复制复杂类型的内存耗费), 形参和实参指向同一个内存地址（即引用），所以对参数的修改会影响到实际的对象。</li><li>String, Integer, Double 等 immutable 的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="205-访问修饰符-public-protect-default-private">20.5. 访问修饰符 public-protect-default-private<a href="#205-访问修饰符-public-protect-default-private" class="hash-link" aria-label="20.5. 访问修饰符 public-protect-default-private的直接链接" title="20.5. 访问修饰符 public-protect-default-private的直接链接">​</a></h2><p><a href="https://blog.csdn.net/u012418131/article/details/52822381" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/u012418131/article/details/52822381</a></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">作用域有四个可访问级别: 当前类, 同包, 继承, 不同包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. public           范围最大, 都允许</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. protected        范围小一点, 不可跨包访问, 但是可以通过继承打破</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. default          范围再小一点 (package scope),不可跨包访问, 也不可通过继承访问 , 只能在同包下访问;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4. private          范围最小, 只能再类内部访问;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="206-getcontextclassloadergetclassloader-区别">20.6. getcontextclassloader&amp;getclassloader 区别<a href="#206-getcontextclassloadergetclassloader-区别" class="hash-link" aria-label="20.6. getcontextclassloader&amp;getclassloader 区别的直接链接" title="20.6. getcontextclassloader&amp;getclassloader 区别的直接链接">​</a></h2><p>如果你使用 Test.class.getClassLoader()，可能会导致和当前线程所运行的类加载器不一致, 一般只能用在 getResource</p><p>最好使用 Thread.currentThread().getContextClassLoader()</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="207-getter-和-setter-存在的意义">20.7. getter 和 setter 存在的意义<a href="#207-getter-和-setter-存在的意义" class="hash-link" aria-label="20.7. getter 和 setter 存在的意义的直接链接" title="20.7. getter 和 setter 存在的意义的直接链接">​</a></h2><p><a href="https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors</a></p><p>更好的封装性, 无法直接 access 成员变量</p><p>拓展性好, 可以在函数中添加其他功能</p><p>方便打断点 debug</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="208-为什么-service-只有一个实现也需要一个接口">20.8. 为什么 service 只有一个实现也需要一个接口<a href="#208-为什么-service-只有一个实现也需要一个接口" class="hash-link" aria-label="20.8. 为什么 service 只有一个实现也需要一个接口的直接链接" title="20.8. 为什么 service 只有一个实现也需要一个接口的直接链接">​</a></h2><p>在绝大多数情况下，一个 service 接口只有一个实现类, 为什么还要单独抽出一个接口呢? 这个接口时多余的吗?</p><ul><li><p>方便 JAVA 底层的相关特性实现，例如反射, 生成代理</p></li><li><p>面向接口开发的好处, 比如 可以把接口打进调用方开发包提供出去，而不是实现类。所以调用就是签名的调用, 接口是否实现不影响调用</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="209-static-关键字">20.9. static 关键字<a href="#209-static-关键字" class="hash-link" aria-label="20.9. static 关键字的直接链接" title="20.9. static 关键字的直接链接">​</a></h2><p><a href="https://www.cnblogs.com/dotgua/p/6354151.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener noreferrer">四个作用</a>
sos 上的一个问题: <a href="https://stackoverflow.com/questions/413898/what-does-the-static-keyword-do-in-a-class" target="_blank" rel="noopener noreferrer">What does the &#x27;static&#x27; keyword do in a class?</a></p><p><a href="https://www.cnblogs.com/hf-cherish/p/4970267.html" target="_blank" rel="noopener noreferrer">静态变量的生命周期</a></p><p>static 关键字的作用是把类的成员变成类相关，而不是实例相关</p><ul><li><p>修饰成员变量 - 内存位置变化: heap(属于对象, 对象独有) --&gt; method area(属于 class, 对象公有)</p></li><li><p>修饰成员方法 - 内存变化: 没有多大的变化, 方法本来就是存放在类的定义当中的</p><ul><li><p>最大的作用，就是可以使用&quot;类名.方法名&quot;的方式操作方法，避免了先要 new 出对象的繁琐和资源消耗.</p></li><li><p>不过它也有使用的局限，一个 static 修饰的方法中，不能使用非 static 修饰的成员变量和方法，这很好理解，因为 static 修饰的方法是属于类的，如果去直接使用对象的成员变量，它会不知所措（不知该使用哪一个对象的属性）。</p></li></ul></li><li><p>静态块 - 初始化 static 修饰的成员时，可以将他们统一放在一个以 static 开始，用花括号包裹起来的块状语句中. 静态块和静态成员变量效果等同</p><ul><li><p>加载顺序</p><p>1、（如果类还未被加载）先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。
2、（如果类还未被加载）执行子类的静态代码块和静态变量初始化。
3、执行父类的实例变量初始化
4、执行父类的构造函数
5、执行子类的实例变量初始化
6、执行子类的构造函数</p></li></ul></li><li><p>静态导包</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2010-内部类-or-静态内部类">20.10. 内部类 or 静态内部类<a href="#2010-内部类-or-静态内部类" class="hash-link" aria-label="20.10. 内部类 or 静态内部类的直接链接" title="20.10. 内部类 or 静态内部类的直接链接">​</a></h2><p><a href="https://www.cnblogs.com/Gaojiecai/p/4041663.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/Gaojiecai/p/4041663.html</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="20101-内部类">20.10.1. 内部类<a href="#20101-内部类" class="hash-link" aria-label="20.10.1. 内部类的直接链接" title="20.10.1. 内部类的直接链接">​</a></h3><ul><li><p>内部类：定义再类内部的类</p><p><code>非静态内部类对象有着指向其外部类对象的引用</code>, 所以 <code>在创建非静态内部类对象时，一定要先创建起相应的外部类对象</code></p></li><li><p>作用 - 封装性</p><ul><li><p><code>内部类成员可以直接访问外部类的私有数据</code></p></li><li><p>外部类不能访问内部类的实现细节，例如内部类的成员变量</p></li></ul></li></ul><blockquote><p>理解: 什么是内部？内部就是我是你的一部分，我了解你，我知道你的全部，没有你就没有我。（所以内部类对象是以外部类对象存在为前提的）</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="20102-静态内部类">20.10.2. 静态内部类<a href="#20102-静态内部类" class="hash-link" aria-label="20.10.2. 静态内部类的直接链接" title="20.10.2. 静态内部类的直接链接">​</a></h3><p>静态内部类(静态嵌套类)：使用 static 来修饰一个内部类</p><p><code>static InnerClass 和 OuterClass 没啥关系</code>, 就是个独立的 class, 自己可以完全独立存在, 也就没有了指向外部类的引用, 因此也就无法访问外部类的成员</p><p>外部类可以访问 static InnerClass 的成员</p><blockquote><p>理解: 比如有 A，B 两个类，B 有点特殊，虽然可以独立存在，但只被 A 使用。这时候怎么办？如果把 B 并入 A 里，复杂度提高，搞得 A 违反单一职责。如果 B 独立，又可能被其他类（比如同一个包下的 C）依赖，不符合设计的本意。所以不如将其变成 A.B，等于添加个注释，告诉其他类别使用 B 了，它只跟 A 玩。</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2011-java-类初始化顺序">20.11. Java 类初始化顺序<a href="#2011-java-类初始化顺序" class="hash-link" aria-label="20.11. Java 类初始化顺序的直接链接" title="20.11. Java 类初始化顺序的直接链接">​</a></h2><p>单独的类:</p><ol><li>静态属性</li><li>静态代码块</li><li>普通属性</li><li>普通代码块</li><li>构造方法</li></ol><p>继承关系的父子类:</p><ol><li>父类静态属性</li><li>父类静态代码块</li><li>子类静态属性</li><li>子类静态代码块</li><li>父类普通属性</li><li>父类普通代码块</li><li>父类构造方法</li><li>子类普通变量</li><li>子类普通代码块</li><li>子类构造方法</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2012-random-随机数">20.12. Random-随机数<a href="#2012-random-随机数" class="hash-link" aria-label="20.12. Random-随机数的直接链接" title="20.12. Random-随机数的直接链接">​</a></h2><p><a href="https://www.cnblogs.com/yrrAwx/p/7806444.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/yrrAwx/p/7806444.html</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2013-位运算">20.13. 位运算<a href="#2013-位运算" class="hash-link" aria-label="20.13. 位运算的直接链接" title="20.13. 位运算的直接链接">​</a></h2><p>左移: 左移 n 位就是把最高位 n 位移出，低位添加 n 个 0 的操作，左移操作相当于将该数乘以 2^n 次方。</p><p>右移: 右移 n 位就是把低位 n 位移出，高位添加 n 个 0 的操作，右移操作相当于将该数除以 2^n 次方。</p><p><a href="https://www.cnblogs.com/liaopeng/p/8436155.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/liaopeng/p/8436155.html</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2014-为什么包名都小写">20.14. 为什么包名都小写<a href="#2014-为什么包名都小写" class="hash-link" aria-label="20.14. 为什么包名都小写的直接链接" title="20.14. 为什么包名都小写的直接链接">​</a></h2><p>实际上, java 包名是大小写敏感的, 那为什么还是要求都要小写呢</p><p>是为了跨平台的考虑, Linux 中的文件名是大小写敏感的, 但是 windows 中的文件名是大小写不敏感的, 防止在 Windows 平台出错, 统一要求小写</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2015-处理-unicode-编码问题">20.15. 处理 unicode 编码问题<a href="#2015-处理-unicode-编码问题" class="hash-link" aria-label="20.15. 处理 unicode 编码问题的直接链接" title="20.15. 处理 unicode 编码问题的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 方法1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UnicodeUtils {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 字符串编码成Unicode编码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static String encode(String src) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StringBuilder str = new StringBuilder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int intAsc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String strHex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; src.length(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            c = src.charAt(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            intAsc = (int) c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            strHex = Integer.toHexString(intAsc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (intAsc &gt; 128)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                str.append(&quot;\\u&quot; + strHex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                str.append(&quot;\\u00&quot; + strHex); // 低位在前面补00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return str.toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Unicode解码成字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param src</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static String decode(String src) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int t =  src.length() / 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StringBuilder str = new StringBuilder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; t; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String s = src.substring(i * 6, (i + 1) * 6); // 每6位描述一个字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 高位需要补上00再转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String s1 = s.substring(2, 4) + &quot;00&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 低位直接转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String s2 = s.substring(4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将16进制的string转为int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int n = Integer.valueOf(s1, 16) + Integer.valueOf(s2, 16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将int转换为字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            char[] chars = Character.toChars(n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            str.append(new String(chars));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return str.toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 方法2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void te() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String te = &quot;\\u97e6\\u5c0f\\u5b9d&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final String result = unicodeDecode(te);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static String unicodeDecode(String string) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Pattern pattern = Pattern.compile(&quot;(\\\\u(\\p{XDigit}{4}))&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Matcher matcher = pattern.matcher(string);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char    ch;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (matcher.find()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ch = (char) Integer.parseInt(matcher.group(2), 16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            string = string.replace(matcher.group(1), ch + &quot;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return string;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static String unicodeEncode(String string) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char[] utfBytes = string.toCharArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String unicodeBytes = &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; utfBytes.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String hexB = Integer.toHexString(utfBytes[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (hexB.length() &lt;= 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                hexB = &quot;00&quot; + hexB;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            unicodeBytes = unicodeBytes + &quot;\\u&quot; + hexB;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return unicodeBytes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2016-为什么成员变量再次赋值给局部变量">20.16. 为什么成员变量再次赋值给局部变量<a href="#2016-为什么成员变量再次赋值给局部变量" class="hash-link" aria-label="20.16. 为什么成员变量再次赋值给局部变量的直接链接" title="20.16. 为什么成员变量再次赋值给局部变量的直接链接">​</a></h2><p><a href="https://www.oschina.net/question/2319418_2317139" target="_blank" rel="noopener noreferrer">https://www.oschina.net/question/2319418_2317139</a></p><p>大体来说，这样写是一种极端的优化，在运行时，即时编译器（JIT）将会把这种代码编译成与本地平台相关的机器码，并进行各种层次的优化，以提高性能。</p><p><a href="http://mail.openjdk.java.net/pipermail/core-libs-dev/2010-May/004165.html" target="_blank" rel="noopener noreferrer">http://mail.openjdk.java.net/pipermail/core-libs-dev/2010-May/004165.html</a>
<a href="https://stackoverflow.com/questions/2785964/in-arrayblockingqueue-why-copy-final-member-field-into-local-final-variable" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/2785964/in-arrayblockingqueue-why-copy-final-member-field-into-local-final-variable</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2017-为什么定义成员变量不用赋值而定义局部变量必须赋值">20.17. 为什么定义成员变量不用赋值而定义局部变量必须赋值<a href="#2017-为什么定义成员变量不用赋值而定义局部变量必须赋值" class="hash-link" aria-label="20.17. 为什么定义成员变量不用赋值而定义局部变量必须赋值的直接链接" title="20.17. 为什么定义成员变量不用赋值而定义局部变量必须赋值的直接链接">​</a></h2><p>任何变量在C语言中不赋值的话，会是乱码的形式，可能有安全问题。所以java修正了这点，对于局部变量强制让你赋值</p><p>为什么成员变量有自己的初始值，而不需要强制赋值，那是因为new对象的时候，构造函数帮你初始化默认值了</p><h1>21. 开源项目</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="211-博客-cms-系统">21.1. 博客 cms 系统<a href="#211-博客-cms-系统" class="hash-link" aria-label="21.1. 博客 cms 系统的直接链接" title="21.1. 博客 cms 系统的直接链接">​</a></h2><p><a href="https://github.com/halo-dev/halo" target="_blank" rel="noopener noreferrer">https://github.com/halo-dev/halo</a></p><p><a href="https://github.com/JPressProjects/jpress" target="_blank" rel="noopener noreferrer">https://github.com/JPressProjects/jpress</a> 类似 WordPress</p><p><a href="https://github.com/gentics/mesh" target="_blank" rel="noopener noreferrer">https://github.com/gentics/mesh</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/java">java</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/xiaoyureed/xiaoyureed.github.io/tree/main/docs/java-note.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/java-code-clean"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Java Clean Code Tips</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/linux-note"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">鸟哥的 Linux 私房菜阅读笔记</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#31-反射的-api" class="table-of-contents__link toc-highlight">3.1. 反射的 api</a></li><li><a href="#32-实现事件驱动机制" class="table-of-contents__link toc-highlight">3.2. 实现事件驱动机制</a></li><li><a href="#51-集合的体系" class="table-of-contents__link toc-highlight">5.1. 集合的体系</a></li><li><a href="#52-读源码" class="table-of-contents__link toc-highlight">5.2. 读源码</a><ul><li><a href="#521-数组和链表区别" class="table-of-contents__link toc-highlight">5.2.1. 数组和链表区别</a></li><li><a href="#522-单链表和双链表区别" class="table-of-contents__link toc-highlight">5.2.2. 单链表和双链表区别</a></li><li><a href="#523-hashmap" class="table-of-contents__link toc-highlight">5.2.3. HashMap</a></li><li><a href="#524-hashset" class="table-of-contents__link toc-highlight">5.2.4. HashSet</a></li><li><a href="#525-hashtable" class="table-of-contents__link toc-highlight">5.2.5. HashTable</a></li><li><a href="#526-linkedhashmap" class="table-of-contents__link toc-highlight">5.2.6. LinkedHashMap</a></li><li><a href="#527-treemap" class="table-of-contents__link toc-highlight">5.2.7. TreeMap</a></li><li><a href="#528-lindedhashset" class="table-of-contents__link toc-highlight">5.2.8. LindedHashSet</a></li><li><a href="#529-arraylist-和-vector" class="table-of-contents__link toc-highlight">5.2.9. ArrayList 和 Vector</a></li><li><a href="#5210-linkedlist" class="table-of-contents__link toc-highlight">5.2.10. LinkedList</a></li><li><a href="#5211-concurrenthashmap" class="table-of-contents__link toc-highlight">5.2.11. ConcurrentHashMap</a></li></ul></li><li><a href="#53-collections-和-arrays-工具类" class="table-of-contents__link toc-highlight">5.3. Collections 和 Arrays 工具类</a></li><li><a href="#54-集合排序" class="table-of-contents__link toc-highlight">5.4. 集合排序</a></li><li><a href="#61-泛型方法-泛型类-泛型接口" class="table-of-contents__link toc-highlight">6.1. 泛型方法-泛型类-泛型接口</a></li><li><a href="#62-泛型反射" class="table-of-contents__link toc-highlight">6.2. 泛型反射</a><ul><li><a href="#621-泛型反射-api" class="table-of-contents__link toc-highlight">6.2.1. 泛型反射 api</a></li><li><a href="#622-案例-优化-basedao" class="table-of-contents__link toc-highlight">6.2.2. 案例-优化 BaseDao</a></li></ul></li><li><a href="#71-语法" class="table-of-contents__link toc-highlight">7.1. 语法</a></li><li><a href="#72-元注解" class="table-of-contents__link toc-highlight">7.2. 元注解</a></li><li><a href="#73-注解反射" class="table-of-contents__link toc-highlight">7.3. 注解反射</a></li><li><a href="#74-看一个例子优化-dao-解决字段和属性不一致" class="table-of-contents__link toc-highlight">7.4. 看一个例子(优化 dao-解决字段和属性不一致)</a><ul><li><a href="#741-通过注解优化-javabean" class="table-of-contents__link toc-highlight">7.4.1. 通过注解优化 JavaBean</a></li><li><a href="#742-泛型反射优化-basedao" class="table-of-contents__link toc-highlight">7.4.2. 泛型反射优化 BaseDao</a></li><li><a href="#743-自定义结果集-handler" class="table-of-contents__link toc-highlight">7.4.3. 自定义结果集 handler</a></li></ul></li><li><a href="#81-io总结" class="table-of-contents__link toc-highlight">8.1. io总结</a></li><li><a href="#82-socket-网络编程" class="table-of-contents__link toc-highlight">8.2. socket 网络编程</a></li><li><a href="#83-阻塞-io" class="table-of-contents__link toc-highlight">8.3. 阻塞 io</a><ul><li><a href="#831-什么是阻塞-io" class="table-of-contents__link toc-highlight">8.3.1. 什么是阻塞 io</a></li><li><a href="#832-io-体系的整个概览" class="table-of-contents__link toc-highlight">8.3.2. io 体系的整个概览</a></li><li><a href="#833-paths-和-files-相关-api" class="table-of-contents__link toc-highlight">8.3.3. Paths 和 Files 相关 api</a><ul><li><a href="#8331-paths-的获取转化" class="table-of-contents__link toc-highlight">8.3.3.1. Paths 的获取转化</a></li><li><a href="#8332-通过-files-paths-读取写入" class="table-of-contents__link toc-highlight">8.3.3.2. 通过 Files Paths 读取写入</a></li><li><a href="#8333-遍历文件夹" class="table-of-contents__link toc-highlight">8.3.3.3. 遍历文件夹</a></li><li><a href="#8334-通过-files-获取文件属性" class="table-of-contents__link toc-highlight">8.3.3.4. 通过 files 获取文件属性</a></li></ul></li><li><a href="#834-bio-tcp-实现通信" class="table-of-contents__link toc-highlight">8.3.4. bio tcp 实现通信</a></li></ul></li><li><a href="#84-非阻塞-io" class="table-of-contents__link toc-highlight">8.4. 非阻塞 io</a><ul><li><a href="#841-什么是非阻塞-io" class="table-of-contents__link toc-highlight">8.4.1. 什么是非阻塞 io</a></li><li><a href="#842-同步异步和阻塞非阻塞" class="table-of-contents__link toc-highlight">8.4.2. 同步异步和阻塞非阻塞</a><ul><li><a href="#8421-同步与异步" class="table-of-contents__link toc-highlight">8.4.2.1. 同步与异步</a></li><li><a href="#8422-阻塞与非阻塞" class="table-of-contents__link toc-highlight">8.4.2.2. 阻塞与非阻塞</a></li><li><a href="#8423-四种组合" class="table-of-contents__link toc-highlight">8.4.2.3. 四种组合</a></li></ul></li></ul></li><li><a href="#85-多路复用-io-即-java-nio" class="table-of-contents__link toc-highlight">8.5. 多路复用 IO 即 java nio</a><ul><li><a href="#851-解释多路复用" class="table-of-contents__link toc-highlight">8.5.1. 解释多路复用</a></li><li><a href="#852-nio-和-io-区别" class="table-of-contents__link toc-highlight">8.5.2. nio 和 io 区别</a></li><li><a href="#853-linux-中的多路复用支持" class="table-of-contents__link toc-highlight">8.5.3. Linux 中的多路复用支持</a></li><li><a href="#854-核心组件" class="table-of-contents__link toc-highlight">8.5.4. 核心组件</a><ul><li><a href="#8541-理解" class="table-of-contents__link toc-highlight">8.5.4.1. 理解</a></li><li><a href="#8542-channels" class="table-of-contents__link toc-highlight">8.5.4.2. Channels</a></li><li><a href="#8543-buffers" class="table-of-contents__link toc-highlight">8.5.4.3. Buffers</a></li><li><a href="#8544-selectors" class="table-of-contents__link toc-highlight">8.5.4.4. Selectors</a></li></ul></li><li><a href="#855-nio-实现网络通信" class="table-of-contents__link toc-highlight">8.5.5. nio 实现网络通信</a></li></ul></li><li><a href="#86-java-aio" class="table-of-contents__link toc-highlight">8.6. java aio</a></li><li><a href="#87-断点续传" class="table-of-contents__link toc-highlight">8.7. 断点续传</a></li><li><a href="#111-函数式编程的概念fp" class="table-of-contents__link toc-highlight">11.1. 函数式编程的概念(FP)</a></li><li><a href="#112-java8-添加的新特性" class="table-of-contents__link toc-highlight">11.2. Java8 添加的新特性</a><ul><li><a href="#1121-接口默认方法" class="table-of-contents__link toc-highlight">11.2.1. 接口默认方法</a></li><li><a href="#1122-functionalinterface-函数接口" class="table-of-contents__link toc-highlight">11.2.2. @FunctionalInterface-函数接口</a></li><li><a href="#1123-方法的引用" class="table-of-contents__link toc-highlight">11.2.3. 方法的引用</a></li><li><a href="#1124-lambda-表达式" class="table-of-contents__link toc-highlight">11.2.4. Lambda 表达式</a><ul><li><a href="#11241-lambda-介绍" class="table-of-contents__link toc-highlight">11.2.4.1. lambda 介绍</a></li><li><a href="#11242-lambda-作用域问题" class="table-of-contents__link toc-highlight">11.2.4.2. Lambda 作用域问题</a><ul><li><a href="#112421-访问局部变量" class="table-of-contents__link toc-highlight">11.2.4.2.1. 访问局部变量</a></li><li><a href="#112422-访问成员变量" class="table-of-contents__link toc-highlight">11.2.4.2.2. 访问成员变量</a></li><li><a href="#112423-访问默认接口方法" class="table-of-contents__link toc-highlight">11.2.4.2.3. 访问默认接口方法</a></li></ul></li></ul></li></ul></li><li><a href="#113-java8-中的并行流" class="table-of-contents__link toc-highlight">11.3. java8 中的并行流</a><ul><li><a href="#1131-使用并行过滤数据" class="table-of-contents__link toc-highlight">11.3.1. 使用并行过滤数据</a></li><li><a href="#1132-从集合得到并行流" class="table-of-contents__link toc-highlight">11.3.2. 从集合得到并行流</a></li><li><a href="#1133-并行排序-给数组赋值" class="table-of-contents__link toc-highlight">11.3.3. 并行排序-给数组赋值</a></li></ul></li><li><a href="#114-completablefuture-接口-增强的-future" class="table-of-contents__link toc-highlight">11.4. CompletableFuture 接口-增强的 Future</a><ul><li><a href="#1141-java-异步编程" class="table-of-contents__link toc-highlight">11.4.1. java 异步编程</a></li><li><a href="#1142-原理介绍" class="table-of-contents__link toc-highlight">11.4.2. 原理介绍</a></li><li><a href="#1143-completablefuture-api" class="table-of-contents__link toc-highlight">11.4.3. completablefuture api</a></li><li><a href="#1144-完成了就通知我-手动填充结果" class="table-of-contents__link toc-highlight">11.4.4. 完成了就通知我-手动填充结果</a></li><li><a href="#1145-异步执行任务" class="table-of-contents__link toc-highlight">11.4.5. 异步执行任务</a></li><li><a href="#1146-流式调用组合多个-function-和-异常处理" class="table-of-contents__link toc-highlight">11.4.6. 流式调用组合多个 function 和 异常处理</a></li><li><a href="#1147-组合多个-completablefuture" class="table-of-contents__link toc-highlight">11.4.7. 组合多个 CompletableFuture</a></li></ul></li><li><a href="#115-stampedlock-读写锁的改进" class="table-of-contents__link toc-highlight">11.5. StampedLock-读写锁的改进</a></li><li><a href="#116-longadder-原子类的增强" class="table-of-contents__link toc-highlight">11.6. LongAdder-原子类的增强</a></li><li><a href="#117-java8-内置函数式接口" class="table-of-contents__link toc-highlight">11.7. java8 内置函数式接口</a><ul><li><a href="#1171-predicates谓词-断定" class="table-of-contents__link toc-highlight">11.7.1. Predicates(谓词, 断定)</a></li><li><a href="#1172-functions函数" class="table-of-contents__link toc-highlight">11.7.2. Functions(函数)</a></li><li><a href="#1173-suppliers生产者" class="table-of-contents__link toc-highlight">11.7.3. Suppliers(生产者)</a></li><li><a href="#1174-consumers消费者" class="table-of-contents__link toc-highlight">11.7.4. Consumers(消费者)</a></li><li><a href="#1175-comparators比较器" class="table-of-contents__link toc-highlight">11.7.5. Comparators(比较器)</a></li><li><a href="#1176-optional" class="table-of-contents__link toc-highlight">11.7.6. Optional</a></li></ul></li><li><a href="#118-streams管道" class="table-of-contents__link toc-highlight">11.8. Streams(管道)</a><ul><li><a href="#1181-stream-介绍" class="table-of-contents__link toc-highlight">11.8.1. stream 介绍</a></li><li><a href="#1182-重复使用-stream" class="table-of-contents__link toc-highlight">11.8.2. 重复使用 stream</a></li><li><a href="#1183-map-和-flatmap" class="table-of-contents__link toc-highlight">11.8.3. map 和 flatMap</a></li><li><a href="#1184-去重" class="table-of-contents__link toc-highlight">11.8.4. 去重</a></li><li><a href="#1185-collect方法-如何收集处理后的元素-分组-去重" class="table-of-contents__link toc-highlight">11.8.5. collect方法 如何收集处理后的元素 分组 去重</a></li><li><a href="#1186-stream-中异常处理" class="table-of-contents__link toc-highlight">11.8.6. stream 中异常处理</a></li></ul></li><li><a href="#119-date-时间日期新的-api" class="table-of-contents__link toc-highlight">11.9. date 时间日期新的 api</a><ul><li><a href="#1191-介绍-为什么使用" class="table-of-contents__link toc-highlight">11.9.1. 介绍-为什么使用</a></li><li><a href="#1192-使用新的时间日期-api" class="table-of-contents__link toc-highlight">11.9.2. 使用新的时间日期 api</a></li><li><a href="#1193-统计代码耗时" class="table-of-contents__link toc-highlight">11.9.3. 统计代码耗时</a></li></ul></li><li><a href="#1110-可重复的-annotations" class="table-of-contents__link toc-highlight">11.10. 可重复的 Annotations</a></li><li><a href="#1111-base64-编码" class="table-of-contents__link toc-highlight">11.11. base64 编码</a></li><li><a href="#1112-map-映射的新方法" class="table-of-contents__link toc-highlight">11.12. map 映射的新方法</a></li><li><a href="#121-java-module" class="table-of-contents__link toc-highlight">12.1. java module</a></li><li><a href="#122-jshell" class="table-of-contents__link toc-highlight">12.2. jshell</a></li><li><a href="#123-var-类型推断" class="table-of-contents__link toc-highlight">12.3. var 类型推断</a></li><li><a href="#124-jdk-api-enhencement" class="table-of-contents__link toc-highlight">12.4. jdk api enhencement</a></li><li><a href="#125-改进-java-程序在-docker-中的表现" class="table-of-contents__link toc-highlight">12.5. 改进 java 程序在 docker 中的表现</a></li><li><a href="#126-新的垃圾回收器" class="table-of-contents__link toc-highlight">12.6. 新的垃圾回收器</a></li><li><a href="#131-classloader-的概念" class="table-of-contents__link toc-highlight">13.1. classloader 的概念</a></li><li><a href="#132-层级结构" class="table-of-contents__link toc-highlight">13.2. 层级结构</a></li><li><a href="#133-工作过程-and-双亲委派模式" class="table-of-contents__link toc-highlight">13.3. 工作过程 and 双亲委派模式</a></li><li><a href="#134-线程上下文类加载器-打乱层级结构" class="table-of-contents__link toc-highlight">13.4. 线程上下文类加载器-打乱层级结构</a></li><li><a href="#135-借助-classloader-实现类隔离" class="table-of-contents__link toc-highlight">13.5. 借助 classloader 实现类隔离</a></li><li><a href="#136-类加载相关的异常" class="table-of-contents__link toc-highlight">13.6. 类加载相关的异常</a></li><li><a href="#137-自定义-classloader加载网络上的-class" class="table-of-contents__link toc-highlight">13.7. 自定义 classloader(加载网络上的 class)</a></li><li><a href="#141-获取-classpath-和-系统属性-环境变量" class="table-of-contents__link toc-highlight">14.1. 获取 classpath 和 系统属性 环境变量</a></li><li><a href="#151-各个数据类型的范围" class="table-of-contents__link toc-highlight">15.1. 各个数据类型的范围</a></li><li><a href="#152-double-类型的加减乘除" class="table-of-contents__link toc-highlight">15.2. double 类型的加减乘除</a></li><li><a href="#161-打-jar-包" class="table-of-contents__link toc-highlight">16.1. 打 jar 包</a></li><li><a href="#162-生成注释文档-javadoc" class="table-of-contents__link toc-highlight">16.2. 生成注释文档 javadoc</a></li><li><a href="#163-编译和反编译" class="table-of-contents__link toc-highlight">16.3. 编译和反编译</a></li><li><a href="#171-object" class="table-of-contents__link toc-highlight">17.1. Object</a></li><li><a href="#172-string" class="table-of-contents__link toc-highlight">17.2. String</a></li><li><a href="#181-javassist" class="table-of-contents__link toc-highlight">18.1. javassist</a></li><li><a href="#191-graalvm" class="table-of-contents__link toc-highlight">19.1. graalvm</a></li><li><a href="#192-vertx" class="table-of-contents__link toc-highlight">19.2. vertx</a></li><li><a href="#193-micronaut" class="table-of-contents__link toc-highlight">19.3. Micronaut</a></li><li><a href="#194-quarkus" class="table-of-contents__link toc-highlight">19.4. Quarkus</a></li><li><a href="#201-正则表达式-regex" class="table-of-contents__link toc-highlight">20.1. 正则表达式 regex</a></li><li><a href="#202-静态绑定和动态绑定" class="table-of-contents__link toc-highlight">20.2. 静态绑定和动态绑定</a></li><li><a href="#203-重载-and-重写" class="table-of-contents__link toc-highlight">20.3. 重载 and 重写</a></li><li><a href="#204-java-值传递-or-引用传递" class="table-of-contents__link toc-highlight">20.4. java 值传递 or 引用传递</a></li><li><a href="#205-访问修饰符-public-protect-default-private" class="table-of-contents__link toc-highlight">20.5. 访问修饰符 public-protect-default-private</a></li><li><a href="#206-getcontextclassloadergetclassloader-区别" class="table-of-contents__link toc-highlight">20.6. getcontextclassloader&amp;getclassloader 区别</a></li><li><a href="#207-getter-和-setter-存在的意义" class="table-of-contents__link toc-highlight">20.7. getter 和 setter 存在的意义</a></li><li><a href="#208-为什么-service-只有一个实现也需要一个接口" class="table-of-contents__link toc-highlight">20.8. 为什么 service 只有一个实现也需要一个接口</a></li><li><a href="#209-static-关键字" class="table-of-contents__link toc-highlight">20.9. static 关键字</a></li><li><a href="#2010-内部类-or-静态内部类" class="table-of-contents__link toc-highlight">20.10. 内部类 or 静态内部类</a><ul><li><a href="#20101-内部类" class="table-of-contents__link toc-highlight">20.10.1. 内部类</a></li><li><a href="#20102-静态内部类" class="table-of-contents__link toc-highlight">20.10.2. 静态内部类</a></li></ul></li><li><a href="#2011-java-类初始化顺序" class="table-of-contents__link toc-highlight">20.11. Java 类初始化顺序</a></li><li><a href="#2012-random-随机数" class="table-of-contents__link toc-highlight">20.12. Random-随机数</a></li><li><a href="#2013-位运算" class="table-of-contents__link toc-highlight">20.13. 位运算</a></li><li><a href="#2014-为什么包名都小写" class="table-of-contents__link toc-highlight">20.14. 为什么包名都小写</a></li><li><a href="#2015-处理-unicode-编码问题" class="table-of-contents__link toc-highlight">20.15. 处理 unicode 编码问题</a></li><li><a href="#2016-为什么成员变量再次赋值给局部变量" class="table-of-contents__link toc-highlight">20.16. 为什么成员变量再次赋值给局部变量</a></li><li><a href="#2017-为什么定义成员变量不用赋值而定义局部变量必须赋值" class="table-of-contents__link toc-highlight">20.17. 为什么定义成员变量不用赋值而定义局部变量必须赋值</a></li><li><a href="#211-博客-cms-系统" class="table-of-contents__link toc-highlight">21.1. 博客 cms 系统</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.a7606eaf.js"></script>
<script src="/assets/js/main.c0bf4a94.js"></script>
</body>
</html>