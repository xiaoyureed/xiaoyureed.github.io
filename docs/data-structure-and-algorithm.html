<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-data-structure-and-algorithm">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Data Structure and Algorithm | Xiaoyureed&#x27;s 网络 Wiki </title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://xiaoyureed.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://xiaoyureed.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://xiaoyureed.github.io/docs/data-structure-and-algorithm"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Data Structure and Algorithm | Xiaoyureed&#x27;s 网络 Wiki "><meta data-rh="true" name="description" content="https://github.com/afatcoder/LeetcodeTop 互联网公司算法面试"><meta data-rh="true" property="og:description" content="https://github.com/afatcoder/LeetcodeTop 互联网公司算法面试"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://xiaoyureed.github.io/docs/data-structure-and-algorithm"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/en/docs/data-structure-and-algorithm" hreflang="en"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/data-structure-and-algorithm" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/data-structure-and-algorithm" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Xiaoyureed&#39;s 网络 Wiki  RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Xiaoyureed&#39;s 网络 Wiki  Atom Feed"><link rel="stylesheet" href="/assets/css/styles.ca3abbab.css">
<link rel="preload" href="/assets/js/runtime~main.a7606eaf.js" as="script">
<link rel="preload" href="/assets/js/main.c0bf4a94.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Xiaoyureed</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/xiaoyureed" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="打开/收起侧边栏菜单「Tutorial - Basics」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="打开/收起侧边栏菜单「Tutorial - Extras」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/SpringBoot-note">Spring Boot 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/agile-development-user-story-scrum">敏捷开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/autohotkey">Autohotkey 脚本</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/chatgpt">Chatgpt Usage Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cpp">CPP and C 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cross-gfw">Cross The GFW</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/cs-note">Computer Science Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/css-pre-processor">几种CSS预处理器比较选型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/data-structure-and-algorithm">Data Structure and Algorithm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/design-pattern-note">Design Pattern 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/dev-resources">开发者资源</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/distributed-system">Distributed System 分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/docker-note-virtual-dev-env">Docker Note &amp; Other Virtual Develop Environment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/effective-java-reading-note">Effective Java 阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/how-to-test-java-app">How to Test Java App</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/html-note">HTML 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/idea-note">InteliJ idea tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/interview-system-design">经典的系统设计思路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/java-code-clean">Java Clean Code Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/java-note">Java Core 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/linux-note">鸟哥的 Linux 私房菜阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/mybatis-note">MyBatis Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-audio-video">Audio and Video development Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-big-data-introduce">大数据开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-computational-ad">计算广告 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-crawler-spider">网络爬虫 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-desktop-develop">桌面应用开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-http">HTTP protocol Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-reactive-programming">响应式编程 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-rpc">RPC Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/outline-about-rule-engine-note">规则引擎 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/quant-money">量化交易</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/saas-paas-iaas-as-a-service">SaaS Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/spring-note">Spring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/springmvc-note">Spring MVC</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Data Structure and Algorithm</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Data Structure and Algorithm</h1></header><p><a href="https://github.com/afatcoder/LeetcodeTop" target="_blank" rel="noopener noreferrer">https://github.com/afatcoder/LeetcodeTop</a> 互联网公司算法面试</p><p><a href="https://github.com/doocs/leetcode" target="_blank" rel="noopener noreferrer">https://github.com/doocs/leetcode</a></p><p><a href="https://github.com/geekxh/hello-algorithm" target="_blank" rel="noopener noreferrer">https://github.com/geekxh/hello-algorithm</a> 小浩算法
<a href="https://github.com/geekxh/hello-interview" target="_blank" rel="noopener noreferrer">https://github.com/geekxh/hello-interview</a></p><p><a href="https://github.com/apachecn/apachecn-algo-zh" target="_blank" rel="noopener noreferrer">https://github.com/apachecn/apachecn-algo-zh</a>
<a href="https://github.com/algorithm-visualizer/algorithm-visualizer" target="_blank" rel="noopener noreferrer">https://github.com/algorithm-visualizer/algorithm-visualizer</a>
<a href="https://github.com/trekhleb/javascript-algorithms" target="_blank" rel="noopener noreferrer">https://github.com/trekhleb/javascript-algorithms</a></p><p><a href="https://github.com/MisterBooo/LeetCodeAnimation" target="_blank" rel="noopener noreferrer">https://github.com/MisterBooo/LeetCodeAnimation</a> 动画算法 java</p><p>动图演示算法: <a href="https://visualgo.net/zh" target="_blank" rel="noopener noreferrer">https://visualgo.net/zh</a>
数据结构: <a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/skywang12345/p/3603935.html</a>
python 实现数据结构: <a href="https://github.com/xiaoyuside/algorithm-python" target="_blank" rel="noopener noreferrer">https://github.com/xiaoyuside/algorithm-python</a>
java 实现数据结构算法: <a href="https://github.com/buptdavid/datastructure" target="_blank" rel="noopener noreferrer">https://github.com/buptdavid/datastructure</a>
Suffix Trees - <a href="https://github.com/npgall/concurrent-trees" target="_blank" rel="noopener noreferrer">https://github.com/npgall/concurrent-trees</a>
Radix Trees</p><p><a href="https://blog.csdn.net/u012414189/article/details/83832161?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener noreferrer">面试</a></p><p><a href="https://github.com/kdn251/interviews/blob/master/README-zh-cn.md" target="_blank" rel="noopener noreferrer">https://github.com/kdn251/interviews/blob/master/README-zh-cn.md</a></p><p><a href="https://github.com/labuladong/fucking-algorithm" target="_blank" rel="noopener noreferrer">https://github.com/labuladong/fucking-algorithm</a>
<a href="https://github.com/liweiwei1419/LeetCode-Solutions-in-Good-Style" target="_blank" rel="noopener noreferrer">https://github.com/liweiwei1419/LeetCode-Solutions-in-Good-Style</a>
<a href="https://github.com/greyireland/algorithm-pattern" target="_blank" rel="noopener noreferrer">https://github.com/greyireland/algorithm-pattern</a>
<a href="https://github.com/geekxh/hello-algorithm" target="_blank" rel="noopener noreferrer">https://github.com/geekxh/hello-algorithm</a></p><p><a href="https://github.com/apachecn/apachecn-algo-zh" target="_blank" rel="noopener noreferrer">https://github.com/apachecn/apachecn-algo-zh</a></p><p><a href="https://github.com/facert/python-data-structure-cn" target="_blank" rel="noopener noreferrer">https://github.com/facert/python-data-structure-cn</a>
<a href="https://github.com/keon/algorithms" target="_blank" rel="noopener noreferrer">https://github.com/keon/algorithms</a></p><p><a href="https://github.com/xtaci/algorithms" target="_blank" rel="noopener noreferrer">https://github.com/xtaci/algorithms</a> cpp 中文</p><ul><li><a href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">1. 数据结构总结</a><ul><li><a href="#11-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">1.1. 存储方式</a></li><li><a href="#12-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">1.2. 基本操作</a></li><li><a href="#13-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">1.3. 时间复杂度</a><ul><li><a href="#131-%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95">1.3.1. 计算方法</a></li><li><a href="#132-%E5%B8%B8%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6">1.3.2. 常数复杂度</a></li><li><a href="#133-%E7%BA%BF%E6%80%A7%E5%A4%8D%E6%9D%82%E5%BA%A6">1.3.3. 线性复杂度</a></li><li><a href="#134-%E5%AF%B9%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6">1.3.4. 对数复杂度</a></li><li><a href="#135-%E5%B9%B3%E6%96%B9%E5%A4%8D%E6%9D%82%E5%BA%A6">1.3.5. 平方复杂度</a></li><li><a href="#136-%E6%8C%87%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6">1.3.6. 指数复杂度</a></li></ul></li></ul></li><li><a href="#2-%E6%95%B0%E7%BB%84">2. 数组</a></li><li><a href="#3-%E6%A0%88">3. 栈</a></li><li><a href="#4-%E9%98%9F%E5%88%97">4. 队列</a></li><li><a href="#5-%E9%93%BE%E8%A1%A8">5. 链表</a></li><li><a href="#6-%E6%A0%91">6. 树</a><ul><li><a href="#61-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5and%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84">6.1. 树的基本概念and一般结构</a></li><li><a href="#62-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">6.2. 二叉查找树</a><ul><li><a href="#621-%E9%9D%9E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">6.2.1. 非平衡二叉查找树</a><ul><li><a href="#6211-bstbinary-search-tree-%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84">6.2.1.1. BSTBinary Search Tree-查找树的一般结构</a></li><li><a href="#6212-splay-tree-%E4%BC%B8%E5%B1%95%E6%A0%91">6.2.1.2. Splay Tree 伸展树</a></li></ul></li><li><a href="#622-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">6.2.2. 平衡二叉树</a><ul><li><a href="#6221-avl%E6%A0%91">6.2.2.1. AVL树</a></li><li><a href="#6222-%E7%BA%A2%E9%BB%91%E6%A0%91">6.2.2.2. 红黑树</a></li></ul></li></ul></li><li><a href="#63-%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91">6.3. 多路平衡查找树</a><ul><li><a href="#631--3%E6%A0%91%E4%BA%8C%E4%B8%89%E6%A0%91">6.3.1. -3树二三树</a></li><li><a href="#632-b%E6%A0%91b-tree">6.3.2. B树B-tree</a><ul><li><a href="#6321-b%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5">6.3.2.1. b树的概念</a></li><li><a href="#6322-b%E6%A0%91%E7%9A%84%E7%89%B9%E5%BE%81">6.3.2.2. b树的特征</a></li></ul></li><li><a href="#633-btreeb%E5%8A%A0%E6%A0%91">6.3.3. B+treeB加树</a><ul><li><a href="#6331-btree%E5%AE%9A%E4%B9%89">6.3.3.1. b+tree定义</a></li><li><a href="#6332-%E6%AF%94b-tree%E5%A5%BD%E7%9A%84%E7%82%B9">6.3.3.2. 比b-tree好的点</a></li></ul></li><li><a href="#634-b%E6%A0%91">6.3.4. B*树</a></li><li><a href="#635-%E5%89%8D%E7%BC%80%E6%A0%91trie%E6%A0%91%E5%AD%97%E5%85%B8%E6%A0%91">6.3.5. 前缀树Trie树/字典树</a></li></ul></li><li><a href="#64-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91huffman-tree">6.4. 哈夫曼树Huffman Tree</a></li></ul></li><li><a href="#7-%E5%A0%86">7. 堆</a><ul><li><a href="#71-%E4%BA%8C%E5%8F%89%E5%A0%86">7.1. 二叉堆</a></li><li><a href="#72-%E5%A0%86%E6%8E%92%E5%BA%8F">7.2. 堆排序</a></li></ul></li><li><a href="#8-%E5%9B%BE">8. 图</a><ul><li><a href="#81-%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5">8.1. 图的概念</a></li></ul></li><li><a href="#9-%E5%93%88%E5%B8%8C%E8%A1%A8hash-table">9. 哈希表hash-table</a></li><li><a href="#10-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">10. 排序算法</a><ul><li><a href="#101-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fselect-sort">10.1. 选择排序select Sort</a></li><li><a href="#102-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8Fmerge-sort">10.2. 归并排序merge sort</a></li><li><a href="#103-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8Fbubble-sort">10.3. 冒泡排序bubble sort</a></li></ul></li><li><a href="#11-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">11. 查找算法</a><ul><li><a href="#111-%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">11.1. 顺序查找</a></li><li><a href="#112-%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE">11.2. 有序表查找</a></li><li><a href="#113-%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE">11.3. 线性索引查找</a></li></ul></li><li><a href="#12-%E7%B4%A2%E5%BC%95">12. 索引</a><ul><li><a href="#121-%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95">12.1. 线性索引</a><ul><li><a href="#1211-%E7%A8%A0%E5%AF%86%E7%B4%A2%E5%BC%95">12.1.1. 稠密索引</a></li><li><a href="#1212-%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95">12.1.2. 分块索引</a></li><li><a href="#1213-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">12.1.3. 倒排索引</a></li></ul></li><li><a href="#122-%E6%A0%91%E5%BD%A2%E7%B4%A2%E5%BC%95">12.2. 树形索引</a></li><li><a href="#123-%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95">12.3. 多级索引</a></li></ul></li><li><a href="#13-acm">13. acm</a></li><li><a href="#14-leetcode-%E8%AE%B0%E5%BD%95">14. leetcode 记录</a></li></ul><h1>1. 数据结构总结</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="11-存储方式">1.1. 存储方式<a href="#11-存储方式" class="hash-link" aria-label="1.1. 存储方式的直接链接" title="1.1. 存储方式的直接链接">​</a></h2><p>数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）</p><ul><li><p>数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。</p></li><li><p>链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</p></li></ul><p>比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针</p><p>「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。</p><p>「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</p><p>「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="12-基本操作">1.2. 基本操作<a href="#12-基本操作" class="hash-link" aria-label="1.2. 基本操作的直接链接" title="1.2. 基本操作的直接链接">​</a></h2><p>最主要的操作就是 遍历</p><ul><li><p>线性遍历, 比如用 for 循环遍历一个数组; 比如链表, 既可以用 for 循环线性遍历, 也能用 递归遍历</p></li><li><p>非线性(递归) 遍历, 比如 二叉树递归遍历</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="13-时间复杂度">1.3. 时间复杂度<a href="#13-时间复杂度" class="hash-link" aria-label="1.3. 时间复杂度的直接链接" title="1.3. 时间复杂度的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="131-计算方法">1.3.1. 计算方法<a href="#131-计算方法" class="hash-link" aria-label="1.3.1. 计算方法的直接链接" title="1.3.1. 计算方法的直接链接">​</a></h3><ul><li>去掉常数项。</li><li>只保留最高阶项。</li><li>去掉最高结项的系数</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="132-常数复杂度">1.3.2. 常数复杂度<a href="#132-常数复杂度" class="hash-link" aria-label="1.3.2. 常数复杂度的直接链接" title="1.3.2. 常数复杂度的直接链接">​</a></h3><p>O(1) - 一般是顺序执行的代码</p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 高斯算法, 常数复杂度</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">gaosi</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> begin </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> end </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">4</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> sum </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">begin </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> end</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> end </span><span class="token operator" style="color:#393A34">/</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cout </span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;arr sum = &quot;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain"> sum </span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain"> endl</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="133-线性复杂度">1.3.3. 线性复杂度<a href="#133-线性复杂度" class="hash-link" aria-label="1.3.3. 线性复杂度的直接链接" title="1.3.3. 线性复杂度的直接链接">​</a></h3><p>O(n) - 一层循环</p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 线性复杂度</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">changshu</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">++</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token function" style="color:#d73a49">printf</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;xxx&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="134-对数复杂度">1.3.4. 对数复杂度<a href="#134-对数复杂度" class="hash-link" aria-label="1.3.4. 对数复杂度的直接链接" title="1.3.4. 对数复杂度的直接链接">​</a></h3><p>O(logn) </p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 对数复杂度</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 假设会执行 x 次, 则 2^x = n, x = log n</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">duishu</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> n </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">10</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> n</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token function" style="color:#d73a49">printf</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;xxx&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="135-平方复杂度">1.3.5. 平方复杂度<a href="#135-平方复杂度" class="hash-link" aria-label="1.3.5. 平方复杂度的直接链接" title="1.3.5. 平方复杂度的直接链接">​</a></h3><p>O(n^2)</p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 平方复杂度</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 当 i = 0, 内循环执行 n 次</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 当 i = 1, 内循环执行 n - 1 次</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * sum = n + (n-1) + (n-2) + ... + 1 = (n + 1) * n /2 约等于 n^2</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">pingfang</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> n</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> n</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">++</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">// 注意这里 j = i, 不是 从 0 开始的, 但是最终计算出来复杂度还是 n^2, </span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> j </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> i</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> j </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> n</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">++</span><span class="token plain">j</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token function" style="color:#d73a49">printf</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;xxx&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="136-指数复杂度">1.3.6. 指数复杂度<a href="#136-指数复杂度" class="hash-link" aria-label="1.3.6. 指数复杂度的直接链接" title="1.3.6. 指数复杂度的直接链接">​</a></h3><p>O(2^n)</p><h1>2. 数组</h1><p>数组有上界和下界，数组的元素在上下界内是连续的, 因此 随机访问速度快; 一旦定义, 容量就固定了, 再增删会涉及到数组的复制, 那将是耗时的操作</p><p>多维数组(数组的元素为数组)</p><p>动态数组: Java 提供了 ArrayList和Vector</p><ul><li>Insert - 在某个索引处插入元素</li><li>Get - 读取某个索引处的元素</li><li>Delete - 删除某个索引处的元素</li><li>Size - 获取数组的长度</li></ul><h1>3. 栈</h1><p>栈中的元素采用LIFO (Last In First Out)，即后进先出。可以想象成一个桶 bucket</p><p>典型应用: 实现 ctrl + z 撤销, 把之前的应用状态(限制个数)保存到内存中，最近的状态放到第一个</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- Push — 推入, 在栈的最上方插入元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Pop — 弹出, 返回栈最上方的元素，并将其删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- isEmpty — 查询栈是否为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Top/peek — 返回栈最上方的元素，并不删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * ArrayStack - 模拟 Stack 类, 数组实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ArrayStack&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T[] bucket;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int count; // 元素个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ArrayStack(Class&lt;T&gt; clazz, int size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object newInstance = Array.newInstance(clazz, size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bucket = (T[]) newInstance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        count = 0; // 初始化为 0 个 元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void push(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bucket[count] = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        count = count + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T pop() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = count -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        T ret = bucket[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bucket[index] = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        count = count -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T top() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = count -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return bucket[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>4. 队列</h1><p>队列(Queue)与栈类似，都是采用线性结构存储数据。它们的区别在于，栈采用LIFO方式，而队列采用先进先出，即FIFO(First in First Out), </p><p>队列只允许在&quot;队首&quot;进行删除操作，而在&quot;队尾&quot;进行插入操作。可以想象成一条队伍</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Enqueue — 在队列末尾插入元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Dequeue — 将队列第一个元素删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">isEmpty — 查询队列是否为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Top — 返回队列的第一个元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数组实现的队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ArrayQueue&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T[] data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ArrayQueue(Class&lt;T&gt; clazz, int size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object newInstance = Array.newInstance(clazz, size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        data = (T[]) newInstance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T deQueue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        T ret = data[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        data[0] = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; count; i++) {// 顺次向前挪动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            data[i] = data[i+1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        count = count -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void enQueue(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        data[count] = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        count = count + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T top() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return data[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean empty() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (count == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (count &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;count &lt; 0&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>5. 链表</h1><p>链表是一系列节点组成的链，每一个节点保存了数据以及指向下一个节点的指针。链表头指针指向第一个节点，如果链表为空，则头指针为空或者为null。</p><p>场景: 实现文件系统, 哈希表</p><ul><li>单向链表  - 节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</li><li>双向链表 - 一般是双向循环链表, 每个数据结点中都有两个指针，分别指向直接后继和直接前驱</li></ul><p>双向循环链表图示:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">InsertAtEnd — 在链表结尾插入元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">InsertAtHead — 在链表开头插入元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Delete — 删除链表的指定元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DeleteAtHead — 删除链表第一个元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Search — 在链表中查询指定元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">isEmpty — 查询链表是否为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * DoubleLink 双向循环链表 - 模拟 单列的 LinkedHashMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DoubleLink&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Node&lt;T&gt; head;// important</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 作为基本坐标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private class Node&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Node&lt;T&gt; prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Node&lt;T&gt; next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private T value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Node(T value, Node&lt;T&gt; prev, Node&lt;T&gt; next) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.next = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.prev = prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DoubleLink() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        head = new Node&lt;&gt;(null, null, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        head = head.next = head.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * insert element to the end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void insertAtEnd(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; prev = head.prev;// 前一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; next = head; // 后一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; node = new Node&lt;T&gt;(value, prev, next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prev.next = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next.prev = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void insertAtHead(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; prev = head;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; next = head.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; node = new Node&lt;T&gt;(value, prev, next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prev.next = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next.prev = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void insertAt(int index, T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DoubleLink&lt;T&gt;.Node&lt;T&gt; findNode = this.findNode(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; prev = findNode.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; next = findNode.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DoubleLink&lt;T&gt;.Node&lt;T&gt; node = new Node&lt;T&gt;(value, prev, next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prev.next = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next.prev = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void deleteAt(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DoubleLink&lt;T&gt;.Node&lt;T&gt; findNode = this.findNode(index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; prev = findNode.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; next = findNode.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prev.next = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next.prev = prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        findNode = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * find specific node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param index index, start with 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; findNode(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; ret = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (index &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;index can not less than 0&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 参考 LinkedHashmap 实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (index &lt;= size / 2) {// 正向</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;T&gt; first =  head.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; index; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ret = first.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 反向查找</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; last = head.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = size - 1; i &gt;= index; i--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = last.prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean empty() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (size == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>6. 树</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="61-树的基本概念and一般结构">6.1. 树的基本概念and一般结构<a href="#61-树的基本概念and一般结构" class="hash-link" aria-label="6.1. 树的基本概念and一般结构的直接链接" title="6.1. 树的基本概念and一般结构的直接链接">​</a></h2><p>树(Tree)是一个分层的数据结构，由节点和连接节点的边组成。树是一种特殊的图，它与图最大的区别是没有循环。</p><p>核心思想是使用 &quot;二分法&quot;, &quot;数据平衡策略&quot; 来提高查询效率</p><p>几个概念:</p><ul><li>root - 根节点</li><li>parent - 这个节点具有子节点</li><li>child - 这个节点具有父节点</li><li>leaf - 这个节点没有子节点</li><li>sibling - 同等级(同辈)节点</li><li>一颗树深度为h，最大层数为k，深度与最大层数相同，k=h, 叶子数为2h; 第k层的结点数最多是：2^(k-1); 总结点数是：2^(k-1)，且总节点数一定是奇数</li><li>树的高度为最大层次。即空的二叉树的高度是0，非空树的高度等于它的最大层次(根的层次为1，根的子节点为第2层，依次类推)。</li></ul><p>N叉树(N-ary Tree)
平衡树(Balanced Tree)
二叉树(Binary Tree) - 常见
二叉查找树(Binary Search Tree) - 常见
平衡二叉树(AVL Tree)
红黑树(Red Black Tree)
2-3树(2–3 Tree)</p><p>二叉树一般结构：二叉树的每个结点至多只有二棵子树，二叉树的子树有左右之分。二叉树的第i层至多有2^(i-1)个结点；</p><ul><li><p>满二叉树：除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上</p></li><li><p>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。</p></li></ul><p>图示:</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="62-二叉查找树">6.2. 二叉查找树<a href="#62-二叉查找树" class="hash-link" aria-label="6.2. 二叉查找树的直接链接" title="6.2. 二叉查找树的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="621-非平衡二叉查找树">6.2.1. 非平衡二叉查找树<a href="#621-非平衡二叉查找树" class="hash-link" aria-label="6.2.1. 非平衡二叉查找树的直接链接" title="6.2.1. 非平衡二叉查找树的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6211-bstbinary-search-tree-查找树的一般结构">6.2.1.1. BST(Binary Search Tree)-查找树的一般结构<a href="#6211-bstbinary-search-tree-查找树的一般结构" class="hash-link" aria-label="6.2.1.1. BST(Binary Search Tree)-查找树的一般结构的直接链接" title="6.2.1.1. BST(Binary Search Tree)-查找树的一般结构的直接链接">​</a></h4><ul><li><p>定义: 它是特殊的二叉树, 节点可比较：-- <code>任意节点, left subNode &lt; node &lt; right subNode</code></p><p>  对于二叉树，假设x为二叉树中的任意一个结点，x节点包含关键字key，节点x的key值记为key<!-- -->[x]<!-- -->。如果y是x的左子树中的一个结点，则key<!-- -->[y]<!-- --> &lt;= key<!-- -->[x]<!-- -->；如果y是x的右子树的一个结点，则key<!-- -->[y]<!-- --> &gt;= key<!-- -->[x]<!-- -->。那么，这棵树就是二叉查找树</p></li><li><p>前驱和后继</p><ul><li><p>节点的前驱：是该节点的左子树中的最大节点。即，&quot;二叉树中数据值小于该结点&quot;的&quot;最大结点&quot;</p></li><li><p>节点的后继：是该节点的右子树中的最小节点。即，&quot;二叉树中数据值大于该结点&quot;的&quot;最小结点&quot;</p></li></ul></li><li><p>特征:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(03) 任意节点的左、右子树也分别为二叉查找树。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(04) 没有键值相等的节点（no duplicate nodes）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>时间复杂度  - 平衡状态下, B树的搜索性能逼近二分查找(插入和查找的时间复杂度均为<code>O(log n)</code>), 但是在最坏的情况下仍然会有<code>O(n)</code>的时间复杂度, n 可以看作 高度</p><p>  不平衡是怎么造成的? </p><p>  比如 插入的序列是有序的时; 可以通过随机化建立二叉搜索树来尽量的避免这种情况</p><p>  再比如 由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉</p></li><li><p>插入过程: (<a href="https://lufficc.com/blog/binary-search-tree" target="_blank" rel="noopener noreferrer">https://lufficc.com/blog/binary-search-tree</a> <a href="https://www.cnblogs.com/MrListening/p/5782752.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/MrListening/p/5782752.html</a>)</p><ul><li><p>若当前的二叉查找树为空，则插入的元素为根节点</p></li><li><p>若插入的元素值小于根节点值，则将元素插入到左子树中</p></li><li><p>若插入的元素值不小于根节点值，则将元素插入到右子树中</p></li></ul></li><li><p>删除过程(希望删除节点 p)</p><ul><li><p>p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点）</p></li><li><p>p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可</p></li><li><p>p的左子树和右子树均不空 - 找到 后继/前驱节点 y 移动过来代替 p, 然后连接 y parent 和 y 的 child (对于 后继: 让 y 的 parent 成为 y 的右子树 的 parent; 对于 前驱: 让 y 的 parent 成为 y 的左子树的 parent )</p><p>为什么要找 后继/前驱? - 因为 他们一定是单支节点(后继没有左子树/前驱没有右子树), 这种节点容易移动, 并且满足节点的大小关系</p></li></ul></li><li><p>搜索过程: 从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中; 否则，如果查询关键字比结点关键字小，就进入左子树；如果比结点关键字大，就进入右子树；如果左子树或右子树的指针为空，则报告找不到相应的关键字；</p><p>如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找(插入和查找的时间复杂度均为O(log n))；它比连续内存空间的二分查找的优点是，改变B树结构（插入与删除结点）不需要移动大段的内存数据 (比如 b tree在插入节点时候, 只需要将指针指向新增节点, 原有数据在内存中的位置不变)</p><p>相反, 如果左右子树不平衡, 这时候的搜索性能已经是线性的了 (此时是最坏的情况, 会有O(n)的时间复杂度), 要避免这样的不平衡 b tree</p><p>实际使用的B树都是在原B树的基础上加上平衡算法，即“<code>平衡二叉树</code>”（binary balanced tree，又称AVL树）；如何保持B树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的策略；</p></li></ul><ul><li>几种遍历方式 - 前序遍历、中序遍历、后序遍历3种方式。 - 对二叉查找树进行中序遍历，即可得到有序(从小到大)的数列</li></ul><p>ref: <a href="https://blog.csdn.net/qq_33243189/article/details/80222629" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_33243189/article/details/80222629</a></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">2.1 前序遍历 - parent节点排最先，然后同级先左后右</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">若二叉树非空，则执行以下操作：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(01) 访问根结点；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(02) 先序遍历左子树；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(03) 先序遍历右子树。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void preOrder(BSTNode&lt;T&gt; tree) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(tree != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(tree.key+&quot; &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        preOrder(tree.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        preOrder(tree.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void preOrder() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    preOrder(mRoot);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.2 中序遍历 -  先左后parent最后右</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">若二叉树非空，则执行以下操作：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(01) 中序遍历左子树；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(02) 访问根结点；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(03) 中序遍历右子树。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void inOrder(BSTNode&lt;T&gt; tree) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(tree != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inOrder(tree.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(tree.key+&quot; &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inOrder(tree.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void inOrder() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inOrder(mRoot);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2.3 后序遍历 - 先左后右最后parent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">若二叉树非空，则执行以下操作：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(01) 后序遍历左子树；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(02) 后序遍历右子树；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(03) 访问根结点。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void postOrder(BSTNode&lt;T&gt; tree) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(tree != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        postOrder(tree.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        postOrder(tree.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(tree.key+&quot; &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void postOrder() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    postOrder(mRoot);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>遍历结果图示:</p><p>Java实现</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">遍历: 前序, 中序, 后序遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">find 查找</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max 最大值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">min 最小值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">predecessor 前驱节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">successor 后继节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">insert 插入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">remove 删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">destroy 销毁二叉树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class BinarySearchTree&lt;T extends Comparable&lt;T&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Node&lt;T&gt; root;// root node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class Node&lt;T extends Comparable&lt;T&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private T       value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Node&lt;T&gt; parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Node&lt;T&gt; left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Node&lt;T&gt; right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Node(T value, Node&lt;T&gt; parent, Node&lt;T&gt; left, Node&lt;T&gt; right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.parent = parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.left = left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.right = right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BinarySearchTree(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        root = new Node&lt;&gt;(value, null, null, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 前序遍历 - parent节点排最先，然后同级先左后右</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void preOrderTraverse(Node&lt;T&gt; node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (node == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;can not traverse null node&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(node.value + &quot; &quot;);// print current node&#x27;s value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        preOrderTraverse(node.left);   //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        preOrderTraverse(node.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 中序遍历 - 先左后parent最后右</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void middleOrderTraverse(Node&lt;T&gt; node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (node == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;cannot traverse null node&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        middleOrderTraverse(node.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(node.value + &quot; &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        middleOrderTraverse(node.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 后序遍历 - 先左后右最后parent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void postOrderTraverse(Node&lt;T&gt; node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (node == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;cannot traverse null node&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        postOrderTraverse(node.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        postOrderTraverse(node.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(node.value + &quot; &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 使用递归查找</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param enterNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; find(Node&lt;T&gt; enterNode, T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enterNode == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;cannot find with null enterNode&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int tmp = value.compareTo(enterNode.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tmp == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return enterNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (tmp &lt; 0) {  // value &lt; enterNode.value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return find(enterNode.left, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return find(enterNode.right, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 没有递归的查找</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param enterNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; find_2(Node&lt;T&gt; enterNode, T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enterNode == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;cannot find with null enterNode&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (enterNode != null) {// 如果 enterNode == null 了， 证明循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 到叶子节点了， 跳出, 返回null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int tmp = value.compareTo(enterNode.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (tmp == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return enterNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (tmp &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterNode = enterNode.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterNode = enterNode.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; find(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.find(root, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // -------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 最大值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param enterNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; maxNode(Node&lt;T&gt; enterNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;T&gt; right = enterNode.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (right == null) { // 证明此时enterNode 是叶子节点了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return enterNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterNode = right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 最小值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param enterNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; minNode(Node&lt;T&gt; enterNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;T&gt; left = enterNode.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (left == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return enterNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterNode = left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 节点的前驱：是该节点的左子树中的最大节点。即比当前节点小的最大节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param enterNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; predecessor(Node&lt;T&gt; enterNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; left = enterNode.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // enterNode 存在 left node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //        p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      /  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     *    *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //       \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //        o</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //    - 那么只需要 以这个left node 为 根节点， 找到最大值即可, 即这里的 o</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (left != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return this.maxNode(left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果 enterNode 没有 left node，分两种情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1. enterNode 自身是一个 right node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //        o</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      /  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     *    p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //          \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     - 找到 parent, 即这里的 o， 返回parent (这个 parent 就是比 enterNode 小的最大节点)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2. enterNode 自身是一个left node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      o</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //       \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //        *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      /  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     p    *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  - 则查找&quot;enterNode的最低的父结点，并且该父结点要具有右孩子&quot;, 即这里的 o，找</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //        到的这个&quot;最低的父结点&quot;就是&quot;x的前驱结点&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; parent = enterNode.parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (parent == null) {// enterNode is root</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enterNode == parent.right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enterNode == parent.left) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 循环找 parent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterNode = parent; // enterNode 指针移动到 parent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent = enterNode.parent; // parent 指针移动到 新的 parent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (enterNode == parent.right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new RuntimeException(MessageFormat.format(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;子节点{0} 和 父节点 {1} 断开了&quot;, enterNode, parent));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 节点的后继：是该节点的右子树中的最小节点， 即比当前节点大的最小节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param enterNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; successor(Node&lt;T&gt; enterNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果存在 right node，则返回 以这个 right node 为子树的最小节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; right = enterNode.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (right != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return minNode(right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; parent = enterNode.parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (parent == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enterNode == parent.left) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enterNode == parent.right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterNode = parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent = enterNode.parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (enterNode == parent.left) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new RuntimeException(MessageFormat.format(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;子节点{0} 和 父节点 {1} 断开了&quot;, enterNode, parent));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ----------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * insert node into the tree</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param node 待插入节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void insert(Node&lt;T&gt; node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; enterPoint = this.root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;T&gt; enterPointTmp = enterPoint;// 暂存指针移动前的 enterPoint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int tmp = node.value.compareTo(enterPoint.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (tmp == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new RuntimeException(&quot;value already exist&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (tmp &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterPoint = enterPoint.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterPoint = enterPoint.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (enterPoint == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterPoint = enterPointTmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int tmp = node.value.compareTo(enterPoint.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tmp == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;value already exist&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (tmp &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterPoint.left = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterPoint.right = node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * delete specific node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void delete(Node&lt;T&gt; node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 若 node 为 leaf节点，直接删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //       *           *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      /             \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     p               p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 若 node 为 &quot;只有一个子节点&quot;, 这个子节点为 singleSon, 那么用 singleSon 代替 node 即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //       p       p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      /         \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     *           *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 若 node 为 &quot;有两个子节点&quot;,   需要找node的后继节点successor 或者 前驱 predecessor, 替换 node, 分 2 种情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      1. successor 为 node 的直接子节点(即右节点)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //         p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //        / \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //       *   su</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //          - 直接用 successor 替代 node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     2. successor 不为 node 的直接子节点(即不是右节点)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //         p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //        / \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //       *   *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //          /</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //         su</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //          - 用 successor 替换 node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // # 为什么要找 successor代替node? - 想要用 o 代替 node , o 需要 满足 node.left &lt; o (node) &lt; node.right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //      而 successor, predecessor的位置满足 node.left &lt; predecessor &lt; o (node) &lt; successor &lt; node.right</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; left = node.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; right = node.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; parent = node.parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (left ==null &amp;&amp; right == null) {// 没有子节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (parent.left == node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent.left = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (parent.right == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent.right = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (left != null &amp;&amp; right != null) {// 有两个子节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Node&lt;T&gt; successor = this.successor(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (parent.left == node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent.left = successor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (parent.right == node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                parent.right = successor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            successor.parent = parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            left.parent = successor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            successor.left = left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (right != successor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                right.parent = successor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                successor.right = right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 只有一个子节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; son = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (left != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            son = left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (right != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            son = right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (parent.left == node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent.left = son;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (parent.right == node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent.right = son;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node.parent = node.left = node.right = null;// 删除node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * destroy tree</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void destroy(Node&lt;T&gt; enterNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enterNode == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; left = enterNode.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (left != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            destroy(left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; right = enterNode.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (right != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            destroy(right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enterNode = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void destroy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        destroy(root);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6212-splay-tree-伸展树">6.2.1.2. Splay Tree 伸展树<a href="#6212-splay-tree-伸展树" class="hash-link" aria-label="6.2.1.2. Splay Tree 伸展树的直接链接" title="6.2.1.2. Splay Tree 伸展树的直接链接">​</a></h4><p>伸展树(Splay Tree)是特殊的二叉查找树。它的特殊是指，它除了<code>本身是棵二叉查找树</code>之外，它还具备一个特点: <code>当某个节点被访问时，伸展树会通过旋转使该节点成为树根</code>。这样做的好处是，下次要访问该节点时，能够迅速的访问到该节点。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="622-平衡二叉树">6.2.2. 平衡二叉树<a href="#622-平衡二叉树" class="hash-link" aria-label="6.2.2. 平衡二叉树的直接链接" title="6.2.2. 平衡二叉树的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6221-avl树">6.2.2.1. AVL树<a href="#6221-avl树" class="hash-link" aria-label="6.2.2.1. AVL树的直接链接" title="6.2.2.1. AVL树的直接链接">​</a></h4><p><a href="http://www.cnblogs.com/skywang12345/p/3577479.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/skywang12345/p/3577479.html</a></p><p>相比于&quot;二叉查找树&quot;，它的特点是：AVL树中任何节点的<code>左右两个子树的高度最大差别为1</code>, 所以它也被称为高度平衡树; 没有值相等重复的节点</p><p>这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在<code>O(logN)</code></p><p>不平衡分四种情况</p><ul><li>LL - LeftLeft，也称为&quot;左左&quot;。插入或删除一个节点后，根节点的左子树的左子树还有非空子节点，导致&quot;根的左子树的高度&quot;比&quot;根的右子树的高度&quot;大2，导致AVL树失去了平衡。</li><li>LR：LeftRight，也称为&quot;左右&quot;。插入或删除一个节点后，根节点的左子树的右子树还有非空子节点，导致&quot;根的左子树的高度&quot;比&quot;根的右子树的高度&quot;大2，导致AVL树失去了平衡</li><li>RL：RightLeft，称为&quot;右左&quot;。插入或删除一个节点后，根节点的右子树的左子树还有非空子节点，导致&quot;根的右子树的高度&quot;比&quot;根的左子树的高度&quot;大2，导致AVL树失去了平衡。</li><li>RR：RightRight，称为&quot;右右&quot;。插入或删除一个节点后，根节点的右子树的右子树还有非空子节点，导致&quot;根的右子树的高度&quot;比&quot;根的左子树的高度&quot;大2，导致AVL树失去了平衡</li></ul><p>图示:</p><p>对应的旋转操作</p><p>LL失去平衡的情况，可以通过一次旋转让AVL树恢复平衡, LL旋转是围绕&quot;失去平衡的AVL根节点&quot;进行的 - 将旋转节点变为右子节点</p><p>旋转代码：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private AVLTreeNode&lt;T&gt; leftLeftRotation(AVLTreeNode&lt;T&gt; k2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AVLTreeNode&lt;T&gt; k1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k1 = k2.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k2.left = k1.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k1.right = k2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k2.height = max( height(k2.left), height(k2.right)) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k1.height = max( height(k1.left), k2.height) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return k1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>RR是与LL对称的情况 - 将旋转节点变为左子节点</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private AVLTreeNode&lt;T&gt; rightRightRotation(AVLTreeNode&lt;T&gt; k1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AVLTreeNode&lt;T&gt; k2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k2 = k1.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k1.right = k2.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k2.left = k1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k1.height = max( height(k1.left), height(k1.right)) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k2.height = max( height(k2.right), k1.height) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return k2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>LR失去平衡的情况，需要经过两次旋转才能让AVL树恢复平衡：先针对局部（root的左子树）进行一次 RR单旋转（将旋转节点变为左子节点）， 此时 整棵树转换为了 LL 的情况 ， 再进行 LL单旋转</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private AVLTreeNode&lt;T&gt; leftRightRotation(AVLTreeNode&lt;T&gt; k3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k3.left = rightRightRotation(k3.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return leftLeftRotation(k3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>RL是与LR的对称情况</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private AVLTreeNode&lt;T&gt; rightLeftRotation(AVLTreeNode&lt;T&gt; k1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    k1.right = leftLeftRotation(k1.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return rightRightRotation(k1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>全部的代码如下：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 自平衡二叉树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @since 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AVLTree&lt;T extends Comparable&lt;T&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Node&lt;T&gt; root;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private class Node&lt;T extends Comparable&gt; {// 没有 parent 成员</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private T       value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Node&lt;T&gt; left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Node&lt;T&gt; right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int     height;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Node(T value, Node&lt;T&gt; left, Node&lt;T&gt; right) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.left = left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.right = right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.height = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * LL：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 根节点的左子树的左子树还有非空子节点 ( x 有子节点, 造成左边偏重)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * &lt;pre&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *         rn                    l</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *       /  \                  /  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *      l    r     --&gt;        x    rn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *    /  \                   /\   / \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   x    y                      y   r</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  /\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * &lt;/pre&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param rotationNode 围绕旋转的节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return 旋转后的根节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; leftLeftRotation(Node&lt;T&gt; rotationNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; leftToTop = rotationNode.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationNode.left = leftToTop.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        leftToTop.right = rotationNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationNode.height = max(height(rotationNode.left), height(rotationNode.right)) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        leftToTop.height = max(height(leftToTop.left), height(leftToTop.right)) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return leftToTop;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * RR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 根节点的右子树的右子树还有非空子节点(y 有子节点, 造成右边偏重)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * &lt;pre&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *         rn                     r</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *        /  \                  /  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *      l    r     --&gt;        rn    y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *          / \              / \   /\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *         x   y            l   x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *            /\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * &lt;/pre&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param rotationNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; rightRightRotation(Node&lt;T&gt; rotationNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; rightToTop = rotationNode.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationNode.right = rightToTop.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rightToTop.left = rotationNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationNode.height = max(height(rotationNode.left), height(rotationNode.right)) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rightToTop.height = max(height(rightToTop.left), height(rightToTop.right)) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rightToTop;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * LR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 根节点的左子树的右子树还有非空子节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 第一次旋转 - RR - 通过局部 RR旋转, 转化为完全的 左左类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 第二次旋转 - LL - LL 旋转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * &lt;pre&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *         rn                        rn                          y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *       /  \                      /  \                        /  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *      l    r     -- RR -&gt;       y    r   -- LL --&gt;          l    rn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *    /  \                      /  \                        / \   / \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *   x    y                    l    w                      x  z  w   r</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *       / \                 /  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *      z   w               x   z</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * &lt;/pre&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param rotationNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; leftRightRotation(Node&lt;T&gt; rotationNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationNode.left = this.rightRightRotation(rotationNode.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return leftLeftRotation(rotationNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * RL:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 和 LR 相反</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param rotationNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; rightLeftRotation(Node&lt;T&gt; rotationNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rotationNode.right = this.leftLeftRotation(rotationNode.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rightRightRotation(rotationNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ----------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 插入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param enterNode 根节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param value 插入值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Node&lt;T&gt; insert(Node&lt;T&gt; enterNode, T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (enterNode == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterNode = new Node&lt;&gt;(value, null, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int compareValue = value.compareTo(enterNode.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (compareValue &lt; 0) { // 将 value 插入到 左子树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterNode.left = insert(enterNode.left, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 插入后， 如果失去平衡， 需要旋转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (height(enterNode.left) - height(enterNode.right) &gt;= 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (value.compareTo(enterNode.left.value) &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        enterNode = leftLeftRotation(enterNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        enterNode = leftRightRotation(enterNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (compareValue &gt; 0) {// 将value 插入到右子树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterNode.right = insert(enterNode.right, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (height(enterNode.right) - height(enterNode.left) &gt;= 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (value.compareTo(enterNode.right.value) &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        enterNode = rightRightRotation(enterNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        enterNode = rightLeftRotation(enterNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new RuntimeException(&quot;insert failed: cannot insert repeating value&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    int compareValue = value.compareTo(enterNode.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    if (compareValue &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //        enterNode = enterNode.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    } else if (compareValue &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //        enterNode = enterNode.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //        throw new RuntimeException(&quot;insert failed: cannot insert repeating value&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    if (enterNode == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enterNode.height = max(height(enterNode.left), height(enterNode.right)) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return enterNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void insert(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        root = insert(root, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ---------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param enterNode 根节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param delete 待删除节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return 删除操作完成后的根节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; remove(Node&lt;T&gt; enterNode, Node&lt;T&gt; delete) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int compareValue = delete.value.compareTo(enterNode.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (compareValue &lt; 0) {// 待删除的节点在&quot;tree的左子树&quot;中， 删除后， 右边偏重</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 进入点往左边移动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 删除完后， 原始 enterNode的左指针指向删除完毕后的根节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterNode.left = remove(enterNode.left, delete);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (height(enterNode.right) - height(enterNode.left) &gt;= 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Node&lt;T&gt; r = enterNode.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (height(r.left) &lt; height(r.right)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode = rightRightRotation(enterNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode = rightLeftRotation(enterNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (compareValue &gt; 0) {// 待删除的节点在&quot;tree的右子树&quot;中, 删除后， 左边偏重</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterNode.right = remove(enterNode.right, delete);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (height(enterNode.left) - height(enterNode.right) &gt;= 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Node&lt;T&gt; l = enterNode.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (height(l.left) &gt; height(l.right)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode = leftLeftRotation(enterNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode = leftRightRotation(enterNode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {// enterNode 正是要删除的节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (enterNode.left != null &amp;&amp; enterNode.right != null) {// 左右子树都不为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (height(enterNode.left) &gt; height(enterNode.right)) {// 若左子树更高</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 找到左子树的最大节点 (enterNode 的 前驱), 代替 enterNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 此时, AVL树仍然是平衡的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;T&gt; leftMax = maxNode(enterNode.left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode.value = leftMax.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode.left = remove(enterNode.left, leftMax);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {// 若右子树更高</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 找得到右子树的最小节点(enterNode 的后继), 代替 enterNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Node&lt;T&gt; rightMin = minNode(enterNode.right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode.value = rightMin.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode.right = remove(enterNode.right, rightMin);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (enterNode.left == null &amp;&amp; enterNode.right == null) {// 没有子树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 直接删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                enterNode = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {// 只有一个子树(有一个子树为空)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 子节点代替enterNode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (enterNode.right != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode = enterNode.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    enterNode = enterNode.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return enterNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void remove(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; find = find(root, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (find == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;delete error: value [&quot;+value+&quot;] is not exist.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        root = remove(root, find);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ----------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * find</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param enterNode 根节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param value 查找值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return 查找到的节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Node&lt;T&gt; find(Node&lt;T&gt; enterNode, T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int compare = value.compareTo(enterNode.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (compare &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterNode =  find(enterNode.left, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (compare &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterNode = find(enterNode.right, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return enterNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Node&lt;T&gt; maxNode(Node&lt;T&gt; enterNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; right = enterNode.right;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (right != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterNode = maxNode(right);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return enterNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Node&lt;T&gt; minNode(Node&lt;T&gt; enterNode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;T&gt; left = enterNode.left;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (left != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enterNode = minNode(left);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return enterNode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int max(int h1, int h2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (h1 &gt; h2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return h1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return h2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int height(Node&lt;T&gt; node) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (node != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return node.height;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int height() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return height(root);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6222-红黑树">6.2.2.2. 红黑树<a href="#6222-红黑树" class="hash-link" aria-label="6.2.2.2. 红黑树的直接链接" title="6.2.2.2. 红黑树的直接链接">​</a></h4><p><a href="https://zhuanlan.zhihu.com/p/24367771" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/24367771</a></p><p>R-B Tree，全称是<code>Red-Black Tree</code>，又称为“红黑树”，它一种自平衡的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><p>AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树</p><p>基于 2-3树 实现, 红黑树中将节点之间的链接分为两种不同类型，<code>红色链接</code>，他用来链接两个2-nodes节点来表示一个3-nodes节点, 并且向左倾斜，即一个2-node是另一个2-node的左子节点。<code>黑色链接</code>用来链接普通的2-3节点</p><p>如果将红色连接水平绘制, 会更形象化:</p><p>有这么几条规则需要遵守: (如果被新插入的节点打破, 就需要变色, 旋转...)</p><ul><li>节点是红色或黑色。</li><li>根是黑色</li><li>所有叶子都是黑色（这里的叶子是指NIL节点, 即 null 节点）</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。(即：从每个叶子到根的所有路径上不能有两个连续的红色节点。)</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 - 这一条确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</li></ul><p>这些约束确保了红黑树的关键特性: <code>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</code></p><p>它的时间复杂度是<code>O(lgn)</code>，效率非常之高。</p><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，例如，Java集合中的TreeSet和TreeMap, jdk1.8 中的hashmap</p><p>相对于 avl，红黑树的插入/删除效率更高， 因为允许存在部分不平衡， 减少了旋转次数 - 最多只需要 3 次旋转</p><p>相应的， 由于 avl 遵循严格的平衡， 查找效率要高一些， 但是差别不大</p><p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p><p><code>左旋和右旋</code>：左旋 和 右旋 是相对的两个概念，对x进行左旋，意味着&quot;将x变成一个左节点&quot;; 通常左旋操作用于将一个向右倾斜的红色链接旋转为向左倾斜。对比操作前后，可以看出，该操作实际上是将红线链接的两个节点中的一个较大的节点移动到根节点上</p><p><code>颜色反转</code>:当出现一个临时的4-node的时候，即一个节点的两个子节点均为红色; 这其实是个A，E，S 4-node连接，我们需要将E提升至父节点，操作方法很简单，就是把E对子节点的连线设置为黑色，自己的颜色设置为红色</p><p>或者这么理解: 新插入的节点都当作是红色的，如果遇到父节点的颜色为黑则修复操作结束, 如果父节点为红色节点的时候是需要插入修复操作的。</p><p>todo： <a href="http://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/skywang12345/p/3603935.html</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="63-多路平衡查找树">6.3. 多路平衡查找树<a href="#63-多路平衡查找树" class="hash-link" aria-label="6.3. 多路平衡查找树的直接链接" title="6.3. 多路平衡查找树的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="631--3树二三树">6.3.1. -3树(二三树)<a href="#631--3树二三树" class="hash-link" aria-label="6.3.1. -3树(二三树)的直接链接" title="6.3.1. -3树(二三树)的直接链接">​</a></h3><p>每个节点允许保存一个值或者两个值, 对于普通的 2-node, 保存一个值和左右子节点的指针, 对于 3-node, 保存 2 个值和左中右 3 个指针, 两个值左小右大</p><p>2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。在2-3查找树基础上改进的红黑树不仅具有较高的效率，并且实现起来较2-3查找树简单</p><p>红黑树和B树都是基于它而来</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="632-b树b-tree">6.3.2. B树(B-tree)<a href="#632-b树b-tree" class="hash-link" aria-label="6.3.2. B树(B-tree)的直接链接" title="6.3.2. B树(B-tree)的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6321-b树的概念">6.3.2.1. b树的概念<a href="#6321-b树的概念" class="hash-link" aria-label="6.3.2.1. b树的概念的直接链接" title="6.3.2.1. b树的概念的直接链接">​</a></h4><p>B树也是一种用于查找的平衡树，但是它不是二叉树。<code>可以拥有多于2个子节点</code>, 能够用来存储排序后的数据, 为<code>优化大块数据的读和写操作</code>而生</p><p>数据库索引技术里大量使用者B树和B+树的数据结构</p><p>了解b-tree的生长/添加过程, 就能推导出这些特性: <a href="https://zhuanlan.zhihu.com/p/24309634" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/24309634</a></p><p>B-tree和二叉树的一个显著的区别就是，<code>B-tree是从下往上生长，而二叉树是从上往下生长的</code>。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6322-b树的特征">6.3.2.2. b树的特征<a href="#6322-b树的特征" class="hash-link" aria-label="6.3.2.2. b树的特征的直接链接" title="6.3.2.2. b树的特征的直接链接">​</a></h4><p>规则:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">- 子节点数量最少 2 个, 最多无穷个; 每个节点的值(关键字)数量可以有多个, 按递增次序排列，并遵循左小右大原则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 非根节点关键字数量大于等于ceil(m/2)-1且小于等于m-1个；（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2, m表示节点的最大分支个数)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 非叶节点有N个子节点，则该节点的关键字数等于N-1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 所有叶子节点均在同一层</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 叶子节点也有指向下层的指针, , 只不过指向的是 null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>查询算法: 比如要查找的值为 v</p><ul><li>如果节点的关键字只有一个, 比如 根节点, 这时进入左右分支, 和二叉查找算法一样</li><li>如果节点关键字有多个, 那么根据大小找到 v 在 这些值中的相对位置, 根据位置决定进入哪个子节点</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">如上图我要从上图中找到E字母，查找流程如下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">（1）获取根节点的关键字进行比较，当前根节点关键字为M，E要小于M（26个字母顺序），所以往找到指向左边的子节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">（2）拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">（3）拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>插入算法: 生长过程是从下往上的</p><ul><li>先确定是几阶树, 以确定每个节点关键字个数范围, 比如: 当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2） -1小于等于5-1（关键字数小于cei(5/2) -1就要进行节点合并，大于5-1就要进行节点拆分,非根节点关键字数&gt;=2）</li><li>满足节点本身比左边节点大，比右边节点小, 同个节点内的关键字也是左边小 右边大</li></ul><p>要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;</p><ul><li><p>当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2） -1, 即 2, 小于等于5-1, 即 4;（关键字数小于cei(5/2) -1就要进行节点合并，大于5-1就要进行节点拆分)</p></li><li><p>先插入 3、8、31、11, 此时达到节点最大关键字个数, 再插入需要拆分, 拆分规则是: 将靠近中间的关键字提取出来作为父节点, 左右两边的构成两个子节点, 继续插入到子节点中, 超过范围就提升到父节点中...</p></li></ul><p>删除算法:</p><ul><li>依然是根据树的阶数计算出每个节点的关键字个数范围</li><li>删除关键字, 删除后, 如果当前节点关键字个数小于 ceil（m/2） -1, 就从 父节点拉一个关键字下来, 相应的要从其他节点给父节点补一个关键字</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="633-btreeb加树">6.3.3. B+tree(B加树)<a href="#633-btreeb加树" class="hash-link" aria-label="6.3.3. B+tree(B加树)的直接链接" title="6.3.3. B+tree(B加树)的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6331-btree定义">6.3.3.1. b+tree定义<a href="#6331-btree定义" class="hash-link" aria-label="6.3.3.1. b+tree定义的直接链接" title="6.3.3.1. b+tree定义的直接链接">​</a></h4><p>B+树是B树的一个升级版，也是一种多路搜索树, 相对于B树来说B+树更充分的利用了节点的空间，比b-tree 查询性能更好，其速度完全接近于二分法查找</p><p>卫星数据：指的是节点元素指向的实际数据（比如数据库中的某一行记录， 在 b-tree 中所有节点都有卫星数据， 即都带有真实数据， b+tree 中只有 leaf node 有卫星数据）</p><ul><li>有k个子树的中间节点包含有k个元素（B树中是k-1个元素， 存疑？），每个元素不保存数据，只用来索引，<code>所有数据都保存在叶子节点</code></li><li><code>叶子结点本身依关键字的大小自小而大顺序链接</code>, 形成有序链表</li><li>所有的<code>中间节点元素都重复存在于子节点</code>，在子节点元素中都是最大（或都是最小）元素</li><li>最大元素再根节点中</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6332-比b-tree好的点">6.3.3.2. 比b-tree好的点<a href="#6332-比b-tree好的点" class="hash-link" aria-label="6.3.3.2. 比b-tree好的点的直接链接" title="6.3.3.2. 比b-tree好的点的直接链接">​</a></h4><ul><li>【树的层级更少， 磁盘io更少速度更快】 - 非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树<code>每个非叶子节点所能保存的关键字大大增加, 树的层级更少</code>所以查询数据更快</li><li>【查询速度更稳定】 - 叶子节点保存了父节点的所有关键字记录的指针，所有<code>数据地址必须要到叶子节点才能获取到</code>，所以每次数据查询的次数都一样, <code>查询速度更稳定</code></li><li>【具备排序功能， 范围查询更简单】 - 每个叶子节点的关键字从小到大构成有序链表, <code>左边结尾数据都会保存右边节点开始数据的指针</code>, 在查询大小区间的数据时候更方便</li><li>【全节点遍历更快】 - <code>遍历整棵树只需要遍历所有的叶子节点即可</code>，而不需要像B树一样需要对每一层进行遍历。<code>有利于数据库做全表扫描</code></li><li><code>不如 b树的地方: 如果经常访问的数据离根节点很近, b+树仍然需要在 叶子节点才能查到, 而 b 树 不必遍历到 叶子节点</code></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="634-b树">6.3.4. B*树<a href="#634-b树" class="hash-link" aria-label="6.3.4. B*树的直接链接" title="6.3.4. B*树的直接链接">​</a></h3><p>B*树是B+树的变体, 不同之处:</p><ul><li>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em> 树的初始化个数为（cei(2/3</em>m)）</li><li>B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="635-前缀树trie树字典树">6.3.5. 前缀树(Trie树/字典树)<a href="#635-前缀树trie树字典树" class="hash-link" aria-label="6.3.5. 前缀树(Trie树/字典树)的直接链接" title="6.3.5. 前缀树(Trie树/字典树)的直接链接">​</a></h3><p>Tire树称为字典树，又称单词查找树</p><p>前缀树(Prefix Trees或者Trie)与树类似, 不同的是, 前缀树每个节点存储的是一个字符, 相同字符不重复存储，用于处理字符串相关的问题时非常高效。</p><p>场景: 它可以实现快速检索，常用于字典中的单词查询，搜索引擎的自动补全甚至IP路由。保存大量字符串</p><p>它的优点是：<code>利用字符串的公共前缀来减少查询时间</code>，最大限度地减少无谓的字符串比较，查询效率比哈希树高。　</p><p>下图展示了“top”, “thus”和“their”三个单词在前缀树中如何存储的：</p><p>应用示例:</p><ul><li><p>串的快速检索: 给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。</p><p>我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。</p></li><li><p>串的排序: 给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。</p><p>用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可</p></li><li><p>最长公共前缀</p><p>对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数，于是，问题就转化为求公共祖先的问题。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="64-哈夫曼树huffman-tree">6.4. 哈夫曼树(Huffman Tree)<a href="#64-哈夫曼树huffman-tree" class="hash-link" aria-label="6.4. 哈夫曼树(Huffman Tree)的直接链接" title="6.4. 哈夫曼树(Huffman Tree)的直接链接">​</a></h2><p><a href="http://www.cnblogs.com/skywang12345/p/3706833.html" target="_blank" rel="noopener noreferrer">http://www.cnblogs.com/skywang12345/p/3706833.html</a></p><h1>7. 堆</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="71-二叉堆">7.1. 二叉堆<a href="#71-二叉堆" class="hash-link" aria-label="7.1. 二叉堆的直接链接" title="7.1. 二叉堆的直接链接">​</a></h2><p>二叉堆就是完全二叉树, </p><p>但是排序规则不同, 按照数据的排列方式可以分为两种：最大堆和最小堆</p><ul><li>大顶堆：父结点的键值总是大于或等于任何一个子节点的键值；</li><li>小顶堆：父结点的键值总是小于或等于任何一个子节点的键值。</li></ul><p>性质: 不保证节点间的有序, 只能保证最大堆的根节点为最大值, 最小堆得根节点是最小值</p><p>使用场景:</p><ul><li>优先队列 - 优先队列中的元素都有一个优先级, 最高的元素最先被取出, 队列结构可以用堆实现</li><li>堆排序 - 找最值得时候可以用堆结构</li></ul><p>为了节省空间, 所以二叉堆一般都通过&quot;数组&quot;来存储, 数组下标规律: (假设 其中某一个元素的index假设为n, 数组下标从 1 开始)</p><p>1）它的父节点若存在，父节点的index为n//2(n//2指n除以2取整数)</p><p>2）若是左子节点存在，index为2*n</p><p>3）若是右子节点存在，index为2*n+1</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="72-堆排序">7.2. 堆排序<a href="#72-堆排序" class="hash-link" aria-label="7.2. 堆排序的直接链接" title="7.2. 堆排序的直接链接">​</a></h2><h1>8. 图</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="81-图的概念">8.1. 图的概念<a href="#81-图的概念" class="hash-link" aria-label="8.1. 图的概念的直接链接" title="8.1. 图的概念的直接链接">​</a></h2><p>图(graph)由多个节点(vertex)构成，节点之间可以互相连接组成一个网络。(x, y)表示一条边(edge)，它表示节点x与y相连。边可能会有权值(weight/cost)。</p><p>根据边是否有方向，将图可以划分为：无向图和有向图。</p><p>遍历算法: 广度优先搜索(Breadth First Search), 深度优先搜索(Depth First Search)</p><h1>9. 哈希表(hash-table)</h1><ul><li><p>哈希(Hash): 将某个对象通过哈希函数变换为唯一标识符(hash)，该标识符通常用一个短的随机字母和数字组成的字符串来代表。哈希可以用来实现各种数据结构，其中最常用的就是哈希表(hash table)。</p></li><li><p>哈希函数: 使用哈希函数将键映射成索引。这种映射函数就是哈希函数; </p><ul><li><p>对于正整数作为键, 一般用这个整数, 除以数组的容量, 取余数, 结果作为保存到数组中的索引.</p></li><li><p>字符串作为键的时候, 可以将组成字符串的每一个字符取值然后以一定规则进行哈希</p></li></ul></li><li><p>哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值; 哈希表通常由数组实现。数组的下标即为哈希值，由哈希函数计算，作为哈希表的键(key)，而数组中保存的数据即为值(value)</p><ul><li><p>原理: 如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值; 如果键是复杂类型, 使用哈希函数将被查找的键转换为数组的索引, 然后根据索引到数组中查找对应的值; </p></li><li><p>碰撞冲突: 在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下需要处理多个键被哈希到同一个索引值的情况, 怎么解决: 拉链法和线性探测法</p><ul><li><p>拉链法: 使得数组的每一个元素指向一个条链表, 发生碰撞的值都存储到链表中; 原则: 选择容量足够大的数组，使得所有的链表都尽可能的短小，以保证查找的效率</p></li><li><p>线性探测法: 使用大小为M的数组来保存N个键值对，其中M&gt;N，需要使用数组中的空位解决碰撞冲突; 如果发生碰撞, 就将索引+1, 值存放到相邻的下一个位置</p></li></ul></li><li><p>影响hash table性能的指标:</p><ul><li>哈希函数</li><li>哈希表的大小</li><li>哈希冲突处理方式</li></ul></li></ul></li></ul><h1>10. 排序算法</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="101-选择排序select-sort">10.1. 选择排序(select Sort)<a href="#101-选择排序select-sort" class="hash-link" aria-label="10.1. 选择排序(select Sort)的直接链接" title="10.1. 选择排序(select Sort)的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Function selectionSort(arry)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  For i = 0 To end of arry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    smallestIndex = i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    For j = i+1 To end of array</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      If array item j &lt; array item smallestIndex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        smallestIndex = j</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      End If</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    swap array item at i and smallestIndex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return arry</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>复杂度分析： for循环套for循环， N*N -&gt; O(N^2)</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="102-归并排序merge-sort">10.2. 归并排序(merge sort)<a href="#102-归并排序merge-sort" class="hash-link" aria-label="10.2. 归并排序(merge sort)的直接链接" title="10.2. 归并排序(merge sort)的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>复杂度: O(n*log n)</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="103-冒泡排序bubble-sort">10.3. 冒泡排序(bubble sort)<a href="#103-冒泡排序bubble-sort" class="hash-link" aria-label="10.3. 冒泡排序(bubble sort)的直接链接" title="10.3. 冒泡排序(bubble sort)的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Function bubbleSort(array)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  For i = 0 To end of array</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    swappedFlag = false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    For j = 0 To array size - i-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      If array item j &gt; array item j+1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        swap array item at j and j+1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        swappedFlag = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      End If</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果 没有发生交换， 说明已经是有序的了， 可以直接跳出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    If Not swappedFlag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Break</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Eng If</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return array</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>复杂度： O(N^2), 最好情况O(N)</p><h1>11. 查找算法</h1><p>在表中执行查找动作, 分为</p><ul><li><p>static search table (静态查找表), 在表中只是做查找操作</p></li><li><p>dynamic search table(动态查找表), 在查找过程中, 同时插入新的数据记录 或者删除某些数据记录</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="111-顺序查找">11.1. 顺序查找<a href="#111-顺序查找" class="hash-link" aria-label="11.1. 顺序查找的直接链接" title="11.1. 顺序查找的直接链接">​</a></h2><p>就是遍历查找, 不要求表有序</p><p>时间复杂度: O(n)</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="112-有序表查找">11.2. 有序表查找<a href="#112-有序表查找" class="hash-link" aria-label="11.2. 有序表查找的直接链接" title="11.2. 有序表查找的直接链接">​</a></h2><p>二分查找</p><p>要求表有序, 每次取中间坐标, 循环比较</p><p>O(logn)</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="113-线性索引查找">11.3. 线性索引查找<a href="#113-线性索引查找" class="hash-link" aria-label="11.3. 线性索引查找的直接链接" title="11.3. 线性索引查找的直接链接">​</a></h2><h1>12. 索引</h1><p>索引是一种加快查找速度而设计的数据结构, </p><p>一个索引包括多个索引项, 每个索引项包括关键字 and 数据在磁盘中的位置</p><p>索引就是把一个关键字和对应的 record 关联的过程</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="121-线性索引">12.1. 线性索引<a href="#121-线性索引" class="hash-link" aria-label="12.1. 线性索引的直接链接" title="12.1. 线性索引的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1211-稠密索引">12.1.1. 稠密索引<a href="#1211-稠密索引" class="hash-link" aria-label="12.1.1. 稠密索引的直接链接" title="12.1.1. 稠密索引的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1212-分块索引">12.1.2. 分块索引<a href="#1212-分块索引" class="hash-link" aria-label="12.1.2. 分块索引的直接链接" title="12.1.2. 分块索引的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1213-倒排索引">12.1.3. 倒排索引<a href="#1213-倒排索引" class="hash-link" aria-label="12.1.3. 倒排索引的直接链接" title="12.1.3. 倒排索引的直接链接">​</a></h3><h2 class="anchor anchorWithStickyNavbar_LWe7" id="122-树形索引">12.2. 树形索引<a href="#122-树形索引" class="hash-link" aria-label="12.2. 树形索引的直接链接" title="12.2. 树形索引的直接链接">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="123-多级索引">12.3. 多级索引<a href="#123-多级索引" class="hash-link" aria-label="12.3. 多级索引的直接链接" title="12.3. 多级索引的直接链接">​</a></h2><h1>acm</h1><p><a href="https://baike.baidu.com/item/Timus%20Online%20Judge/6537795" target="_blank" rel="noopener noreferrer">https://baike.baidu.com/item/Timus%20Online%20Judge/6537795</a></p><blockquote><p><a href="https://acm.timus.ru/forum/?space=1&amp;num=1394" target="_blank" rel="noopener noreferrer">https://acm.timus.ru/forum/?space=1&amp;num=1394</a></p></blockquote><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ACM程序设计大赛简介</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果真正是在计算机领域做学问的话，对ACM的大名一定不会陌生，ACM的全称是Association for Computing Machinery（美国计算机学会），建立于1947年，是世界上第一个教育和科研的，也是最有影响的计算机组织。今天，ACM已经有超过8万个成员，遍布在世界各地。ACM的主要活动包括一些专题的兴趣小组（SIGs Special Interesting Groups），每年要组织一系列高水平的学术会议，还有一些面向不同层次的学术竞赛，ACM/ICPC就是其中之一。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ACM/ICPC（ACM International Collegiate Programming Contest），即ACM国际大学生程序设计竞赛，是由ACM协会提供给大学生的一个展示和提高解题与编程能力的机会。面向全世界的大学生，分为地区赛和决赛，地区赛的优胜者（通常是前两名）有资格参加决赛，决赛的颁奖仪式将和计算机界权威的学术奖——图灵奖的颁奖仪式同时进行。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ACM竞赛有着独特的赛制，比赛是以参赛队为单位的，每队三个人，每支队伍至少有两名参赛队员必须是大学本科尚未毕业的学生，所有参赛队员的学历不可以超过研究生两年。在赛场上，为了体现团体协作精神，三个人共用一台计算机，可以携带一切书面材料。比赛时间一般是4-5个小时，共有6-10道题，按照解答的题目多少和解答所用的时间长短决定名次。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    对于每道题目，参赛队必须写出解决该题的程序源代码，提交给裁判，由裁判编译得到可执行程序，如果对于所有的输入数据该程序都能在规定的时间内得到正确的结果，才能够获得通过。测试数据通常极为严格。当某个队通过了一道题时，工作人员会在这个队的计算机前插上一个代表这道题颜色的气球，这样所有比赛的情况一目了然，为了增加比赛的紧张气氛，比赛结束前一个小时，停止公布所有的成绩</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    竞赛涵盖的范围很广，大致划分如下：Direct（简单题），Computational Geometry（计算几何），Number Theory（数论），Combinatorics（组合数学），Search Techniques（搜索技术），Dynamic Programming（动态规划），Graph Theory（图论），Other（其他）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    目前ACM/ICPC由IBM赞助，全球地区赛共分若干个赛区，数十个赛点。中国学生可以报名参加亚洲赛区的任何赛点的比赛(从2004年开始，大陆各赛点将增加一轮地区赛的预选赛)。比赛支持C/C++，Java,Pascal等语言</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    在线评测系统(Online Judge)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">国内：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       浙江大学ACM网址: http://acm.zju.edu.cn/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       北京大学ACM网址:http://acm.pku.edu.cn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       哈尔宾工业大学ACM网址：http://acm.hit.edu.cn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">国外：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">USACO：http://ace.delos.com/usacogate/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      西班牙网站http://acm.uva.es</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      俄罗斯站点http://acm.timus.ru</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">讨论区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">武汉大学、北京大学、南京大学、上海交大、中山大学BBS的ACM/ICPC讨论区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ICPC官方网站：http://icpc.baylor.edu/icpc/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>13. leetcode 记录</h1><p><a href="https://github.com/aylei/leetcode-rust" target="_blank" rel="noopener noreferrer">https://github.com/aylei/leetcode-rust</a>
<a href="https://github.com/warycat/rustgym" target="_blank" rel="noopener noreferrer">https://github.com/warycat/rustgym</a>
<a href="https://github.com/TheAlgorithms/Rust" target="_blank" rel="noopener noreferrer">https://github.com/TheAlgorithms/Rust</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/算法">算法</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/xiaoyureed/xiaoyureed.github.io/tree/main/docs/data-structure-and-algorithm.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/css-pre-processor"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">几种CSS预处理器比较选型</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/design-pattern-note"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Design Pattern 笔记</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#11-存储方式" class="table-of-contents__link toc-highlight">1.1. 存储方式</a></li><li><a href="#12-基本操作" class="table-of-contents__link toc-highlight">1.2. 基本操作</a></li><li><a href="#13-时间复杂度" class="table-of-contents__link toc-highlight">1.3. 时间复杂度</a><ul><li><a href="#131-计算方法" class="table-of-contents__link toc-highlight">1.3.1. 计算方法</a></li><li><a href="#132-常数复杂度" class="table-of-contents__link toc-highlight">1.3.2. 常数复杂度</a></li><li><a href="#133-线性复杂度" class="table-of-contents__link toc-highlight">1.3.3. 线性复杂度</a></li><li><a href="#134-对数复杂度" class="table-of-contents__link toc-highlight">1.3.4. 对数复杂度</a></li><li><a href="#135-平方复杂度" class="table-of-contents__link toc-highlight">1.3.5. 平方复杂度</a></li><li><a href="#136-指数复杂度" class="table-of-contents__link toc-highlight">1.3.6. 指数复杂度</a></li></ul></li><li><a href="#61-树的基本概念and一般结构" class="table-of-contents__link toc-highlight">6.1. 树的基本概念and一般结构</a></li><li><a href="#62-二叉查找树" class="table-of-contents__link toc-highlight">6.2. 二叉查找树</a><ul><li><a href="#621-非平衡二叉查找树" class="table-of-contents__link toc-highlight">6.2.1. 非平衡二叉查找树</a><ul><li><a href="#6211-bstbinary-search-tree-查找树的一般结构" class="table-of-contents__link toc-highlight">6.2.1.1. BST(Binary Search Tree)-查找树的一般结构</a></li><li><a href="#6212-splay-tree-伸展树" class="table-of-contents__link toc-highlight">6.2.1.2. Splay Tree 伸展树</a></li></ul></li><li><a href="#622-平衡二叉树" class="table-of-contents__link toc-highlight">6.2.2. 平衡二叉树</a><ul><li><a href="#6221-avl树" class="table-of-contents__link toc-highlight">6.2.2.1. AVL树</a></li><li><a href="#6222-红黑树" class="table-of-contents__link toc-highlight">6.2.2.2. 红黑树</a></li></ul></li></ul></li><li><a href="#63-多路平衡查找树" class="table-of-contents__link toc-highlight">6.3. 多路平衡查找树</a><ul><li><a href="#631--3树二三树" class="table-of-contents__link toc-highlight">6.3.1. -3树(二三树)</a></li><li><a href="#632-b树b-tree" class="table-of-contents__link toc-highlight">6.3.2. B树(B-tree)</a><ul><li><a href="#6321-b树的概念" class="table-of-contents__link toc-highlight">6.3.2.1. b树的概念</a></li><li><a href="#6322-b树的特征" class="table-of-contents__link toc-highlight">6.3.2.2. b树的特征</a></li></ul></li><li><a href="#633-btreeb加树" class="table-of-contents__link toc-highlight">6.3.3. B+tree(B加树)</a><ul><li><a href="#6331-btree定义" class="table-of-contents__link toc-highlight">6.3.3.1. b+tree定义</a></li><li><a href="#6332-比b-tree好的点" class="table-of-contents__link toc-highlight">6.3.3.2. 比b-tree好的点</a></li></ul></li><li><a href="#634-b树" class="table-of-contents__link toc-highlight">6.3.4. B*树</a></li><li><a href="#635-前缀树trie树字典树" class="table-of-contents__link toc-highlight">6.3.5. 前缀树(Trie树/字典树)</a></li></ul></li><li><a href="#64-哈夫曼树huffman-tree" class="table-of-contents__link toc-highlight">6.4. 哈夫曼树(Huffman Tree)</a></li><li><a href="#71-二叉堆" class="table-of-contents__link toc-highlight">7.1. 二叉堆</a></li><li><a href="#72-堆排序" class="table-of-contents__link toc-highlight">7.2. 堆排序</a></li><li><a href="#81-图的概念" class="table-of-contents__link toc-highlight">8.1. 图的概念</a></li><li><a href="#101-选择排序select-sort" class="table-of-contents__link toc-highlight">10.1. 选择排序(select Sort)</a></li><li><a href="#102-归并排序merge-sort" class="table-of-contents__link toc-highlight">10.2. 归并排序(merge sort)</a></li><li><a href="#103-冒泡排序bubble-sort" class="table-of-contents__link toc-highlight">10.3. 冒泡排序(bubble sort)</a></li><li><a href="#111-顺序查找" class="table-of-contents__link toc-highlight">11.1. 顺序查找</a></li><li><a href="#112-有序表查找" class="table-of-contents__link toc-highlight">11.2. 有序表查找</a></li><li><a href="#113-线性索引查找" class="table-of-contents__link toc-highlight">11.3. 线性索引查找</a></li><li><a href="#121-线性索引" class="table-of-contents__link toc-highlight">12.1. 线性索引</a><ul><li><a href="#1211-稠密索引" class="table-of-contents__link toc-highlight">12.1.1. 稠密索引</a></li><li><a href="#1212-分块索引" class="table-of-contents__link toc-highlight">12.1.2. 分块索引</a></li><li><a href="#1213-倒排索引" class="table-of-contents__link toc-highlight">12.1.3. 倒排索引</a></li></ul></li><li><a href="#122-树形索引" class="table-of-contents__link toc-highlight">12.2. 树形索引</a></li><li><a href="#123-多级索引" class="table-of-contents__link toc-highlight">12.3. 多级索引</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.a7606eaf.js"></script>
<script src="/assets/js/main.c0bf4a94.js"></script>
</body>
</html>