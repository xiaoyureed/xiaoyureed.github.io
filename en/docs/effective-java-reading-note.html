<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-effective-java-reading-note">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Effective Java 阅读笔记 | Xiaoyureed&#x27;s 网络 Wiki </title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://xiaoyureed.github.io/en/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://xiaoyureed.github.io/en/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://xiaoyureed.github.io/en/docs/effective-java-reading-note"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Effective Java 阅读笔记 | Xiaoyureed&#x27;s 网络 Wiki "><meta data-rh="true" name="description" content="effective java reading note。"><meta data-rh="true" property="og:description" content="effective java reading note。"><link data-rh="true" rel="icon" href="/en/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://xiaoyureed.github.io/en/docs/effective-java-reading-note"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/en/docs/effective-java-reading-note" hreflang="en"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/effective-java-reading-note" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/effective-java-reading-note" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/en/blog/rss.xml" title="Xiaoyureed&#39;s 网络 Wiki  RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/en/blog/atom.xml" title="Xiaoyureed&#39;s 网络 Wiki  Atom Feed"><link rel="stylesheet" href="/en/assets/css/styles.ca3abbab.css">
<link rel="preload" href="/en/assets/js/runtime~main.674636ef.js" as="script">
<link rel="preload" href="/en/assets/js/main.b3bfd78e.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/en/"><div class="navbar__logo"><img src="/en/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/en/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Xiaoyureed</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/en/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/en/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/xiaoyureed" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/en/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Tutorial - Basics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/en/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Toggle the collapsible sidebar category &#x27;Tutorial - Extras&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/SpringBoot-note">Spring Boot 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/agile-development-user-story-scrum">敏捷开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/autohotkey">Autohotkey 脚本</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/chatgpt">Chatgpt Usage Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cpp">CPP and C 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cross-gfw">Cross The GFW</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cs-note">Computer Science Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/css-pre-processor">几种CSS预处理器比较选型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/data-structure-and-algorithm">Data Structure and Algorithm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/design-pattern-note">Design Pattern 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/dev-resources">开发者资源</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/distributed-system">Distributed System 分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/docker-note-virtual-dev-env">Docker Note &amp; Other Virtual Develop Environment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/en/docs/effective-java-reading-note">Effective Java 阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/how-to-test-java-app">How to Test Java App</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/html-note">HTML 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/idea-note">InteliJ idea tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/interview-system-design">经典的系统设计思路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/java-code-clean">Java Clean Code Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/java-note">Java Core 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/linux-note">鸟哥的 Linux 私房菜阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/mybatis-note">MyBatis Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-audio-video">Audio and Video development Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-big-data-introduce">大数据开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-computational-ad">计算广告 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-crawler-spider">网络爬虫 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-desktop-develop">桌面应用开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-http">HTTP protocol Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-reactive-programming">响应式编程 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-rpc">RPC Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-rule-engine-note">规则引擎 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/quant-money">量化交易</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/saas-paas-iaas-as-a-service">SaaS Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/spring-note">Spring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/springmvc-note">Spring MVC</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/en/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Effective Java 阅读笔记</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Effective Java 阅读笔记</h1></header><div align="center">effective java reading note。</div><ul><li><a href="#1-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81">1. 创建和销毁</a><ul><li><a href="#11-%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8static-factory-method%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">1.1. 考虑使用static factory method代替构造函数</a><ul><li><a href="#111-%E4%BC%98%E7%82%B9">1.1.1. 优点</a></li><li><a href="#112-%E7%BC%BA%E7%82%B9">1.1.2. 缺点</a></li><li><a href="#113-%E5%9C%BA%E6%99%AF%E4%BD%95%E6%97%B6%E5%8F%AF%E4%BB%A5%E6%9B%BF%E6%8D%A2%E6%9E%84%E9%80%A0%E5%99%A8">1.1.3. 场景何时可以替换构造器</a></li></ul></li><li><a href="#12-%E9%81%87%E5%88%B0%E5%BE%88%E5%A4%9A%E5%8F%AF%E9%80%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E6%97%B6%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8builder%E6%A8%A1%E5%BC%8F">1.2. 遇到很多可选构造器参数时，用构建器Builder模式</a><ul><li><a href="#121-%E5%9C%BA%E6%99%AF%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8builder%E6%A8%A1%E5%BC%8F">1.2.1. 场景何时使用builder模式</a></li><li><a href="#122-builder%E6%A8%A1%E5%BC%8F">1.2.2. Builder模式</a></li></ul></li><li><a href="#13-private%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%BC%BA%E5%8C%96singleton">1.3. Private构造器或者使用枚举类型来强化singleton</a></li><li><a href="#14-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1">1.4. 避免创建不必要的对象</a><ul><li><a href="#141-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">1.4.1. 应用场景</a></li><li><a href="#142-%E5%AF%B9%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2">1.4.2. 对于字符串</a></li><li><a href="#143-%E9%80%9A%E8%BF%87%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E9%87%8D%E7%94%A8%E5%AF%B9%E8%B1%A1">1.4.3. 通过静态工厂方法重用对象</a></li><li><a href="#144-%E9%87%8D%E7%94%A8%E5%B7%B2%E7%9F%A5%E4%B8%8D%E4%BC%9A%E8%A2%AB%E4%BF%AE%E6%94%B9%E7%9A%84%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">1.4.4. 重用已知不会被修改的可变对象</a></li><li><a href="#145-%E8%A7%86%E5%9B%BE%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E5%AD%98%E7%96%91">1.4.5. 视图适配器的实例不需要创建多个存疑</a></li></ul></li><li><a href="#15-%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">1.5. 消除过期的对象引用</a><ul><li><a href="#151-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A0%88%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">1.5.1. 内存泄漏:栈的内存泄露</a></li><li><a href="#152-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%BC%93%E5%AD%98%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F">1.5.2. 内存泄漏:缓存判断是否过期</a></li><li><a href="#153-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%90%8E%E4%B8%8D%E8%A6%81%E5%BF%98%E8%AE%B0%E5%8F%96%E6%B6%88%E6%B3%A8%E5%86%8C">1.5.3. 内存泄漏:注册回调后不要忘记取消注册</a></li></ul></li><li><a href="#16-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95">1.6. 避免使用终结方法</a></li></ul></li><li><a href="#2-%E8%A6%86%E7%9B%96object%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95">2. 覆盖object中的方法</a><ul><li><a href="#21-%E8%A6%86%E7%9B%96equals">2.1. 覆盖equals</a><ul><li><a href="#211-%E4%BD%95%E6%97%B6%E8%A6%86%E7%9B%96">2.1.1. 何时覆盖</a></li><li><a href="#212-%E8%A6%86%E7%9B%96%E6%97%B6%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E7%BA%A6%E5%AE%9A">2.1.2. 覆盖时需要遵守的约定</a></li><li><a href="#213-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84equals%E6%96%B9%E6%B3%95">2.1.3. 怎么实现高质量的equals方法</a></li></ul></li><li><a href="#22-%E8%A6%86%E7%9B%96hashcode">2.2. 覆盖hashCode</a><ul><li><a href="#221-%E4%B8%80%E7%A7%8D%E8%A6%86%E7%9B%96%E6%96%B9%E5%BC%8F">2.2.1. 一种覆盖方式</a></li><li><a href="#222-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E4%B8%94%E8%AE%A1%E7%AE%97hashcode%E5%BC%80%E9%94%80%E6%AF%94%E8%BE%83%E5%A4%A7%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E6%8A%8A%E6%95%A3%E5%88%97%E7%A0%81%E7%BC%93%E5%AD%98%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8">2.2.2. 如果一个类是不可变的，且计算hashcode开销比较大，可以考虑把散列码缓存在对象内部</a></li></ul></li><li><a href="#23-%E6%9C%80%E5%A5%BD%E5%A7%8B%E7%BB%88%E8%A6%86%E7%9B%96tostring">2.3. 最好始终覆盖toString</a></li><li><a href="#24-%E8%B0%A8%E6%85%8E%E5%9C%B0%E8%A6%86%E7%9B%96clone">2.4. 谨慎地覆盖clone</a><ul><li><a href="#241-%E5%B8%B8%E8%A7%84%E5%81%9A%E6%B3%95">2.4.1. 常规做法</a></li><li><a href="#242-%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%81%9A%E6%B3%95">2.4.2. 更好的做法</a></li></ul></li><li><a href="#25-%E8%80%83%E8%99%91%E5%AE%9E%E7%8E%B0comparable%E6%8E%A5%E5%8F%A3">2.5. 考虑实现comparable接口</a></li></ul></li><li><a href="#3-%E7%B1%BBand%E6%8E%A5%E5%8F%A3">3. 类and接口</a><ul><li><a href="#31-%E4%BD%BF%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96">3.1. 使类和成员的可访问性最小化</a></li><li><a href="#32-%E4%BD%BF%E5%8F%AF%E5%8F%98%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB">3.2. 使可变性最小化不可变类</a><ul><li><a href="#321-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB">3.2.1. 不可变类</a></li><li><a href="#322-%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E4%BE%8B%E5%AD%90demo">3.2.2. 一个不可变类例子demo</a></li><li><a href="#323-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%A7%81%E6%9C%89%E5%8C%96%E6%9E%84%E9%80%A0%E5%99%A8%E6%8F%90%E4%BE%9Bstatic%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">3.2.3. 不可变类其他实现方式：私有化构造器，提供static工厂方法</a></li><li><a href="#324-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E4%BC%98%E7%BC%BA%E7%82%B9">3.2.4. 不可变类优缺点</a></li></ul></li><li><a href="#33-%E5%A4%8D%E5%90%88%E7%BB%84%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF">3.3. 复合组合优于继承</a><ul><li><a href="#331-%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF">3.3.1. 使用复合的场景</a></li><li><a href="#332-%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E5%AE%9E%E4%BE%8B">3.3.2. 一个具体实例</a></li></ul></li><li><a href="#34-%E8%A6%81%E4%B9%88%E4%B8%BA%E7%BB%A7%E6%89%BF%E8%80%8C%E8%AE%BE%E8%AE%A1%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%96%87%E6%A1%A3%E8%A6%81%E4%B9%88%E7%A6%81%E6%AD%A2%E7%BB%A7%E6%89%BF">3.4. 要么为继承而设计，并提供文档，要么禁止继承</a></li><li><a href="#35-%E6%8E%A5%E5%8F%A3%E4%BC%98%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB">3.5. 接口优于抽象类</a><ul><li><a href="#351-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BC%98%E7%BC%BA%E7%82%B9">3.5.1. 接口和抽象类优缺点</a></li><li><a href="#352-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%90%88%E4%BD%9C%E9%AA%A8%E6%9E%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB">3.5.2. 抽象类和接口合作：骨架实现类</a></li></ul></li><li><a href="#36-%E6%8E%A5%E5%8F%A3%E5%8F%AA%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">3.6. 接口只用于定义类型</a></li><li><a href="#37-%E7%B1%BB%E5%B1%82%E6%AC%A1%E4%BC%98%E4%BA%8E%E6%A0%87%E7%AD%BE%E7%B1%BB">3.7. 类层次优于标签类</a></li><li><a href="#38-%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E8%A1%A8%E7%A4%BA%E7%AD%96%E7%95%A5">3.8. 用函数对象函数接口表示策略</a><ul><li><a href="#381-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">3.8.1. 策略模式</a></li><li><a href="#382-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">3.8.2. 函数对象</a></li></ul></li><li><a href="#39-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB">3.9. 优先考虑静态成员类</a></li><li><a href="#310-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E8%80%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E6%80%81%E7%B1%BB%E5%9E%8B">3.10. 使用泛型而不要使用原生态类型</a></li><li><a href="#311-%E5%88%97%E8%A1%A8%E4%BC%98%E4%BA%8E%E6%95%B0%E7%BB%84">3.11. 列表优于数组</a></li><li><a href="#312-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%BC%82%E6%9E%84%E5%AE%B9%E5%99%A8">3.12. 优先考虑类型安全的异构容器</a></li></ul></li><li><a href="#4-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3">4. 枚举和注解</a><ul><li><a href="#41-%E7%94%A8enum%E4%BB%A3%E6%9B%BFint%E5%B8%B8%E9%87%8F">4.1. 用enum代替int常量</a></li><li><a href="#42-%E5%9C%A8%E6%9E%9A%E4%B8%BEenum%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%9F%9F">4.2. 在枚举enum中使用实例域</a></li><li><a href="#43-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E4%BB%A5%E7%BC%96%E5%86%99%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">4.3. 实现接口以编写可扩展的枚举类型</a></li><li><a href="#44-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3or%E6%8E%A5%E5%8F%A3%E5%81%9A%E6%A0%87%E8%AF%86">4.4. 使用注解or接口做标识</a></li><li><a href="#45-%E5%9D%9A%E6%8C%81%E4%BD%BF%E7%94%A8override%E6%B3%A8%E8%A7%A3">4.5. 坚持使用@Override注解</a></li></ul></li><li><a href="#5-%E6%96%B9%E6%B3%95">5. 方法</a><ul><li><a href="#51-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%BC%80%E5%A7%8B%E6%A3%80%E6%9F%A5%E5%8F%82%E6%95%B0%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">5.1. 在方法开始检查参数的有效性</a></li><li><a href="#52-%E8%BF%9B%E8%A1%8C%E5%BF%85%E8%A6%81%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%8B%B7%E8%B4%9D">5.2. 进行必要的保护性拷贝</a></li><li><a href="#53-%E6%85%8E%E7%94%A8%E9%87%8D%E8%BD%BD">5.3. 慎用重载</a></li><li><a href="#54-%E5%BA%94%E8%AF%A5%E8%BF%94%E5%9B%9E0%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84%E6%88%96%E9%9B%86%E5%90%88%E8%80%8C%E4%B8%8D%E6%98%AFnull">5.4. 应该返回0长度的数组或集合，而不是null</a></li></ul></li><li><a href="#6-%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">6. 通用程序设计</a><ul><li><a href="#61-%E4%BD%BF%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%80%E5%B0%8F%E5%8C%96">6.1. 使局部变量的作用域最小化</a></li><li><a href="#62-foreach%E5%BE%AA%E7%8E%AF%E4%BC%98%E4%BA%8E%E4%BC%A0%E7%BB%9Ffor%E5%BE%AA%E7%8E%AF">6.2. Foreach循环优于传统for循环</a></li><li><a href="#63-%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B2%BE%E7%A1%AE%E7%9A%84%E7%AD%94%E6%A1%88%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8float-double">6.3. 如果要使用精确的答案，避免使用float double</a></li><li><a href="#64-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%BC%98%E4%BA%8E%E8%A3%85%E7%AE%B1%E7%B1%BB%E5%9E%8B">6.4. 基本类型优于装箱类型</a></li><li><a href="#65-%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1">6.5. 通过接口引用对象</a></li><li><a href="#66-%E6%8E%A5%E5%8F%A3%E4%BC%98%E4%BA%8E%E5%8F%8D%E5%B0%84%E5%AD%98%E7%96%91">6.6. 接口优于反射存疑</a></li></ul></li><li><a href="#7-%E5%BC%82%E5%B8%B8">7. 异常</a><ul><li><a href="#71-%E5%AF%B9%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">7.1. 对异常的多种处理方式</a></li><li><a href="#72-%E4%BD%BF%E5%A4%B1%E8%B4%A5%E4%BF%9D%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7">7.2. 使失败保持原子性</a></li></ul></li><li><a href="#8-jdk%E4%B8%AD%E7%9A%84%E5%8F%8D%E9%9D%A2%E6%A1%88%E4%BE%8B">8. jdk中的反面案例</a><ul><li><a href="#81-%E6%BB%A5%E7%94%A8%E7%BB%A7%E6%89%BFstack%E7%B1%BB">8.1. 滥用继承:stack类</a></li><li><a href="#82-%E5%80%BC%E5%AF%B9%E8%B1%A1%E5%BA%94%E8%AF%A5%E8%A2%AB%E8%AE%BE%E8%AE%A1%E4%B8%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1date%E7%B1%BB">8.2. 值对象应该被设计为不可变对象:Date类</a></li><li><a href="#83-%E6%BB%A5%E7%94%A8%E5%B8%B8%E9%87%8F%E6%8E%A5%E5%8F%A3">8.3. 滥用常量接口</a></li></ul></li></ul><h1>创建和销毁</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="考虑使用static-factory-method代替构造函数">考虑使用static factory method代替构造函数<a href="#考虑使用static-factory-method代替构造函数" class="hash-link" aria-label="Direct link to 考虑使用static factory method代替构造函数" title="Direct link to 考虑使用static factory method代替构造函数">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="优点">优点<a href="#优点" class="hash-link" aria-label="Direct link to 优点" title="Direct link to 优点">​</a></h3><ul><li><p>有名字</p></li><li><p>不必每次调用都创建新对象，为重复的调用返回相同对象</p><p>看 Boolean 的实现：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public final class Boolean implements java.io.Serializable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Comparable&lt;Boolean&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final Boolean TRUE = new Boolean(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final Boolean FALSE = new Boolean(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Boolean valueOf(boolean b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (b ? TRUE : FALSE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 可以返回子对象，更灵活，适合面向接口编程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">```java</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Father {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Father() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Father newInstance(String type) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (type.equals(&quot;ChildA&quot;)) { // 根据类型判断返回那个子类对象  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new ChildA();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new ChildB();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void getName() {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;My name is father&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class ChildA extends Father {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void getName() {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;My name is child A&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class ChildB extends Father {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void getName() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;My name is child B&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Father c1 = Father.newInstance(&quot;ChildA&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c1.getName();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Father c2 = Father.newInstance(&quot;ChildB&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        c2.getName();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  典型应用是：服务提供者框架，如jdbc实现；看下面的案例</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 服务接口，让提供者实现，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 相当于jdbc的connection接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Service {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 。。。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* Service provider interface，负责创建服务实现的实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 是可选的，如果没有，service interface的实现就按照类名称注册，通过反射创建实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 相当于jdbc的Driver接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Provider {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Service newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 管理器，负责服务注册和API访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 核心是用一个map维护 name 和 provider 的一一对应</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ServiceManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 组织实例化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ServiceManager() {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final HashMap&lt;String, Provider&gt; providers = new HashMap&lt;String, Provider&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final String DEFAULT_PROVIDER_NAME = &quot;def&quot;;//默认</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void registDefault(Provider p) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        providers.put(DEFAULT_PROVIDER_NAME, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 服务注册API，相当于jdbc中DriverManager.registerDriver();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @param name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @param provider</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void registProvider(String name, Provider provider) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        providers.put(name, provider);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * jdbc中的Drivermanager.getConnection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * @throws Exception</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Service newInstance() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return newInstance(DEFAULT_PROVIDER_NAME);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Service newInstance(String name) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Provider provider = providers.get(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (provider == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Exception(&quot;no provider regist  with name: &quot; + name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return provider.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><p>在创建参数化实例时，使代码变得简洁（语法糖）</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;K, V&gt; HashMap&lt;K, V&gt; newInstance() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new HashMap&lt;K, V&gt;();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="缺点">缺点<a href="#缺点" class="hash-link" aria-label="Direct link to 缺点" title="Direct link to 缺点">​</a></h3><ul><li><p>与其他静态方法不易区分，因此经常采用习惯的命名：valueOf、getInstance、newInstance</p></li><li><p>类如果不含 public 或者 protect 的构造器.就不能被子类化，无法产生子类，不能有继承关系</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="场景何时可以替换构造器">场景(何时可以替换构造器)<a href="#场景何时可以替换构造器" class="hash-link" aria-label="Direct link to 场景(何时可以替换构造器)" title="Direct link to 场景(何时可以替换构造器)">​</a></h3><ul><li>静态工厂通常更加合适</li><li>需要有继承时，必须要用构造器</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="遇到很多可选构造器参数时用构建器builder模式">遇到很多可选构造器参数时，用构建器(Builder模式)<a href="#遇到很多可选构造器参数时用构建器builder模式" class="hash-link" aria-label="Direct link to 遇到很多可选构造器参数时，用构建器(Builder模式)" title="Direct link to 遇到很多可选构造器参数时，用构建器(Builder模式)">​</a></h2><p>有很多参数时，使用构造器不方便</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="场景何时使用builder模式">场景(何时使用builder模式)<a href="#场景何时使用builder模式" class="hash-link" aria-label="Direct link to 场景(何时使用builder模式)" title="Direct link to 场景(何时使用builder模式)">​</a></h3><p>若类的构造器or静态工厂中有多个参数（4个or更多），适用，特别是有很多可选参数时</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="builder模式">Builder模式<a href="#builder模式" class="hash-link" aria-label="Direct link to Builder模式" title="Direct link to Builder模式">​</a></h3><p>一种不合适的方法是: Javabean，通过setter设置参数，弊端：1.构造过程被分散到多个setter中，无法仅仅通过检验构造器参数的有效性来 保证一致性，不能保证线程安全；2.Javabean模式阻止了把类做成不可变类的可能</p><p>更好的方式是 Builder</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 外部类构造器为private，内部类构造器为public，build()也是public的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 内部类为static</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Apple {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String require1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String require2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String optional1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String optional2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String optional3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Apple(Builder b) {//这里相当于简化了参数，在这里进行参数检验</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.require1 = b.require1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.require2 = b.require2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.optional1 = b.optional1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.optional2 = b.optional2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.optional3 = b.optional3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这个类可用interface+泛型进行抽象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class Builder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final String require1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final String require2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //可选参数初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String optional1 = &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String optional2 = &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String optional3 = &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Builder(String require1, String require2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.require1 = require1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.require2 = require2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Builder optional1(String optional1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.optional1 = optional1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Builder optional2(String optional2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.optional2 = optional2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Builder optional3(String optional3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.optional3 = optional3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Apple build() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new Apple(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Apple apple = new Apple.Builder(&quot;r1&quot;, &quot;r2&quot;).optional1(&quot;o1&quot;).optional2(&quot;o2&quot;).optional3(&quot;o3&quot;).build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(apple);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="private构造器或者使用枚举类型来强化singleton">Private构造器或者使用枚举类型来强化singleton<a href="#private构造器或者使用枚举类型来强化singleton" class="hash-link" aria-label="Direct link to Private构造器或者使用枚举类型来强化singleton" title="Direct link to Private构造器或者使用枚举类型来强化singleton">​</a></h2><p>想要实现一个单例的类，可能会有如下的经历:</p><ul><li>私有化构造器 - 但是在反序列化时会产生新对象</li><li>使用包含单个元素的Enum (单元素的Enum是实现singleton的最佳方式, 当然还有别的, 比如 使用静态内部类, 借助 jvm自身特性保证线程安全)</li></ul><p>类似的, 通过私有化构造器强化 &quot;不可实例化&quot;, 比如 工具类</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="避免创建不必要的对象">避免创建不必要的对象<a href="#避免创建不必要的对象" class="hash-link" aria-label="Direct link to 避免创建不必要的对象" title="Direct link to 避免创建不必要的对象">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="应用场景">应用场景<a href="#应用场景" class="hash-link" aria-label="Direct link to 应用场景" title="Direct link to 应用场景">​</a></h3><p>通过创建附加的小对象， 提升程序的清晰性、简洁性和功能性，这通常是件好事。</p><p>反之，通过维护自己的对象池（object pool)来避免创達对象并不是一种好的做法，除非 池中的对象是非常重量级的；因为维护对象池会把代码弄乱，增加内存耗用</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="对于字符串">对于字符串<a href="#对于字符串" class="hash-link" aria-label="Direct link to 对于字符串" title="Direct link to 对于字符串">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">String s = &quot;stringette&quot;;//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String s = new String(&quot;stringette&quot;);//don&#x27;t do this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="通过静态工厂方法重用对象">通过静态工厂方法重用对象<a href="#通过静态工厂方法重用对象" class="hash-link" aria-label="Direct link to 通过静态工厂方法重用对象" title="Direct link to 通过静态工厂方法重用对象">​</a></h3><p>例如静态工厂方法Boolean.valueOf(String)回返回一个固定的Boolean实例，而构造器Boolean(String)在每次被调用都会创建一个新的对象</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="重用已知不会被修改的可变对象">重用已知不会被修改的可变对象<a href="#重用已知不会被修改的可变对象" class="hash-link" aria-label="Direct link to 重用已知不会被修改的可变对象" title="Direct link to 重用已知不会被修改的可变对象">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 判断 婴儿潮</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Date birthDate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Person(Date birthDate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.birthDate = birthDate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Date BOOM_START;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Date BOOM_END;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //这里的static块中的对象在每次Person创建时会被重用(只在 class 被 load 时候执行一次)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Calendar gmtCal=Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gmtCal.set(1946,Calendar.JANUARY,1,0,0,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BOOM_START=gmtCal.getTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gmtCal.set(1965,Calendar.JANUARY,1,0,0,0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BOOM_END=gmtCal.getTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isBabyBoomer(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 不推荐的做法: 将 BOOM_END BOOM_START 初始化放在这里来延迟初始化 (如果 isBabyBoomer() 从来不被调用, 这么做可以消除这些不必要的初始化工作，但是不建议这样做。这样做会使方法的实现更加复杂，而性能提升很小, 划不来.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return birthDate.compareTo(BOOM_START)&gt;=0&amp;&amp;birthDate.compareTo(BOOM_END)&lt;0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="视图适配器的实例不需要创建多个存疑">视图(适配器)的实例不需要创建多个(存疑)<a href="#视图适配器的实例不需要创建多个存疑" class="hash-link" aria-label="Direct link to 视图(适配器)的实例不需要创建多个(存疑)" title="Direct link to 视图(适配器)的实例不需要创建多个(存疑)">​</a></h3><p>针对给定对象的特定适配器，不需要创建多个适配器实例。虽然适配器适配的对象可能改变，但是所有返回对象在功能上是同等的。</p><p>例如，Map接口的keySet方法返回该Map对象的Set视图，其中包含该Map中所有的键 (key)。粗看起来，好像毎次调用keyset都应该创建一个新的Set实例，但是，对干一个给定的 Map对象，实际上每次调用keySet都返回同样的Set实例。虽然被返回的Set实例一般是可改变 的，但是所有返回的对象在功能上是等同的：当其中一个返回对象发生变化的时候，所有其 他的返回对象也要发生变化，因为它们是由同一个Map实例支律的•虽然创建keySet视图对象 的多个实例并无害处，却也是没有必要的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="消除过期的对象引用">消除过期的对象引用<a href="#消除过期的对象引用" class="hash-link" aria-label="Direct link to 消除过期的对象引用" title="Direct link to 消除过期的对象引用">​</a></h2><p>核心就是避免 内存泄露</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存泄漏栈的内存泄露">内存泄漏:栈的内存泄露<a href="#内存泄漏栈的内存泄露" class="hash-link" aria-label="Direct link to 内存泄漏:栈的内存泄露" title="Direct link to 内存泄漏:栈的内存泄露">​</a></h3><p>应用实例:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Stack {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Object[] elements;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int DEFAULT_INIT_CAPACITY = 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Stack() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elements = new Object[DEFAULT_INIT_CAPACITY];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void push(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (elements.length == size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            elements = Arrays.copyOf(elements, 2*size + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elements[size++] = o;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object pop() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (size == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Exception();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object o = elements[--size];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        elements[size] = null;//-----消除过期对象，防止内存泄露---------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return o;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存泄漏缓存判断是否过期">内存泄漏:缓存判断是否过期<a href="#内存泄漏缓存判断是否过期" class="hash-link" aria-label="Direct link to 内存泄漏:缓存判断是否过期" title="Direct link to 内存泄漏:缓存判断是否过期">​</a></h3><ul><li><p>解决方案1：当缓存对象是否过期由外部是否有他的键的引用决定，可用WeakHashMap代表缓存</p></li><li><p>解决方案2：对象是否过期不易确定，随时间推移，对象会变得越来越没价值</p><ul><li><p>这时，缓存应该时不时地清除没用项，这个工作可由一个后台线程来完成</p></li><li><p>或者可以在给缓存添加新项时顺便清理过期项，LinkedHashMap利用removeEldestEntry很好实现</p></li><li><p>对于更复杂缓存体系，必须使用java.lang.ref</p></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存泄漏注册回调后不要忘记取消注册">内存泄漏:注册回调后不要忘记取消注册<a href="#内存泄漏注册回调后不要忘记取消注册" class="hash-link" aria-label="Direct link to 内存泄漏:注册回调后不要忘记取消注册" title="Direct link to 内存泄漏:注册回调后不要忘记取消注册">​</a></h3><p>如果你实现了一个API,客户端在这个 API中注册回调，却没有显式地取消注册，那么除非你采取某些动作，否则它们就会积聚。确保 回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用（weak reference),例如，只将它们 保存成WeakHashMap中的键。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="避免使用终结方法">避免使用终结方法<a href="#避免使用终结方法" class="hash-link" aria-label="Direct link to 避免使用终结方法" title="Direct link to 避免使用终结方法">​</a></h2><p>终结方法（finalizer）通常是不可预测的，
通常使用try。。。finally+显式终结方法如：close()来终结资源</p><h1>覆盖object中的方法</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="覆盖equals">覆盖equals()<a href="#覆盖equals" class="hash-link" aria-label="Direct link to 覆盖equals()" title="Direct link to 覆盖equals()">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="何时覆盖">何时覆盖<a href="#何时覆盖" class="hash-link" aria-label="Direct link to 何时覆盖" title="Direct link to 何时覆盖">​</a></h3><p>如果类具有自己特有的“逻辑相等”概念（不 同于对象等同的概念），而且超类还没有榷盖equals以实现期望的行为，这时我们就需要覆盖 equals方法</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="覆盖时需要遵守的约定">覆盖时需要遵守的约定<a href="#覆盖时需要遵守的约定" class="hash-link" aria-label="Direct link to 覆盖时需要遵守的约定" title="Direct link to 覆盖时需要遵守的约定">​</a></h3><ol><li>自反性 x.equals(x) == true</li><li>对称性 x.euqals(y) == y.equals(x)</li><li>传递性 x.equals(y) , y.equlas(z) -&gt; x.equlas(z)</li><li>一致性 多次x.euqlas(y)的结果必选是一致的</li><li>非空性 x!=null&amp;&amp;x.equlas(null)==false ==true</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么实现高质量的equals方法">怎么实现高质量的equals方法<a href="#怎么实现高质量的equals方法" class="hash-link" aria-label="Direct link to 怎么实现高质量的equals方法" title="Direct link to 怎么实现高质量的equals方法">​</a></h3><ol><li>使用 == 操作符检查“参数是否为这个对象的引用”</li><li>使用instanceof操作符 检查“参数是否是正确的类型”</li><li>把参数转换为正确的类型</li><li>对于每一个关键域 逐个对比</li><li>编写完成后 请检查和测试他们是否是传递的、对称的、一致的</li><li>覆盖equals是总是要覆盖hashCode方法！</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="覆盖hashcode">覆盖hashCode()<a href="#覆盖hashcode" class="hash-link" aria-label="Direct link to 覆盖hashCode()" title="Direct link to 覆盖hashCode()">​</a></h2><p>一般和 equals() 同时覆盖</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="一种覆盖方式">一种覆盖方式<a href="#一种覆盖方式" class="hash-link" aria-label="Direct link to 一种覆盖方式" title="Direct link to 一种覆盖方式">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. 把某个非零的常数值，比如说17，保存到一个名为result的int类型变量中。(int result = 17)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 对于对象中每个关键域f (指equals方法中涉及的每个域)，完下面的步骤：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a. 为该域计算int类型的散列码 c:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i. 如果该域是boolean类型的，则计算(f ? 1 : 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ii. 如果该域是 byte、char、short、或者int类型的，则计算(int)f。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        iii. 如果是 long 类型的，则计算 (int)(f^(f&gt;&gt;&gt;32))。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        iv. 如果该域是 float 类型，则计算 FLoat.floatToIntBits(f)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        v. 如果该域是 double 类型，则计算 Double.doubleToLongBits(f)，然后按照步骤2.a.iii，为得到 long 类型值计算散列值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vi. 如果该域是一个对象引用，并且该类的equals方法通过递归地调用equals的方式来比较这个域，则同样为这个域递归地调用hashCode。如果需要更复杂的比较，则为这个域计算一个范式(canonical representation)，然后针对这个范式调用hashCode。如果这个域为null,则返回0。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vii. 如果该域是一个数组，则要把每个元素当作单独的域来处理。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b. 按照下面的公式，将 2.a 计算得到的散列码 c 合并到 result 中：result = 31 * result + c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 返回result。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4. 写完了之后，检查是否符合上述的三条规定。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注：在计算过程中选择31的原因，是因为31有个很好的性能，现代的JVM可以自动的优化计算过程，将31 * i优化成为(i &lt;&lt; 5) - i。用位运算和减法替代了乘法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public int hashCode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int result = 17;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = 31 * result + areaCode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = 31 * result + prefix;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = 31 * result + lineNumber;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="如果一个类是不可变的且计算hashcode开销比较大可以考虑把散列码缓存在对象内部">如果一个类是不可变的，且计算hashcode开销比较大，可以考虑把散列码缓存在对象内部<a href="#如果一个类是不可变的且计算hashcode开销比较大可以考虑把散列码缓存在对象内部" class="hash-link" aria-label="Direct link to 如果一个类是不可变的，且计算hashcode开销比较大，可以考虑把散列码缓存在对象内部" title="Direct link to 如果一个类是不可变的，且计算hashcode开销比较大，可以考虑把散列码缓存在对象内部">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private volatile static int hashcode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public int hashCode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int result = hashcode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (result == 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = 31 * result + areaCode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = 31 * result + prefix;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = 31 * result + lineNumber;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hashcode = result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="最好始终覆盖tostring">最好始终覆盖toString()<a href="#最好始终覆盖tostring" class="hash-link" aria-label="Direct link to 最好始终覆盖toString()" title="Direct link to 最好始终覆盖toString()">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="谨慎地覆盖clone">谨慎地覆盖clone()<a href="#谨慎地覆盖clone" class="hash-link" aria-label="Direct link to 谨慎地覆盖clone()" title="Direct link to 谨慎地覆盖clone()">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="常规做法">常规做法<a href="#常规做法" class="hash-link" aria-label="Direct link to 常规做法" title="Direct link to 常规做法">​</a></h3><p>实现cloneable接口，覆盖clone()</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Override </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public PhoneNumber clone() { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     super.clone(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 此公有方法首先调用super.clone(),然后修正任何需要修正的域(浅克隆、深度克隆)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="更好的做法">更好的做法<a href="#更好的做法" class="hash-link" aria-label="Direct link to 更好的做法" title="Direct link to 更好的做法">​</a></h3><p>提供一个拷贝构造器(copy constructor)或者拷贝工厂(copy factory) </p><p>相比Cloneable/clone优点： </p><p>不依赖于某一种很有风险的，语言之外的对象创建机制；
不要求遵守尚未制定好的文档规范；
不会与final域的正常使用发生冲突；
不会抛出不必要的受检查异常CloneNotSupportedException；
不需要强制进行类型转换；   </p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class GoodClone {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String special;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public GoodClone(int type, String spe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.type = type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.special = spe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 拷贝构造器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param good</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public GoodClone(GoodClone good) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.special = good.special;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.type = good.type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 拷贝工厂 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param good </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static GoodClone newInstance(GoodClone good) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new GoodClone(good.type, good.special);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="考虑实现comparable接口">考虑实现comparable接口<a href="#考虑实现comparable接口" class="hash-link" aria-label="Direct link to 考虑实现comparable接口" title="Direct link to 考虑实现comparable接口">​</a></h2><p>如果编写的 类有明显的排序关系, 实现 <code>Compareble&lt;T&gt;</code> 接口</p><h1>类and接口</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使类和成员的可访问性最小化">使类和成员的可访问性最小化<a href="#使类和成员的可访问性最小化" class="hash-link" aria-label="Direct link to 使类和成员的可访问性最小化" title="Direct link to 使类和成员的可访问性最小化">​</a></h2><p>访问修饰符</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">访问权限   类   包  子类  其他包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public     ∨   ∨    ∨     ∨          （对任何人都是可用的）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protect    ∨   ∨    ∨     ×　　　 （继承的类可以访问以及和private一样的权限）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(default)  ∨   ∨    ×     ×　　　 （包访问权限，即在整个包内均可被访问）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private    ∨   ×    ×     ×　　　 （除类型创建者和类型的内部方法之外的任何人都不能访问的元素）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">----------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private     私有        只有在声明这个成员的类内部可以访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(default)   包级私有    同个 package 可访问, 子类不可访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected   受保护的    同个 package 可访问, 子类可访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public      公有的       任何地方可以访问</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>private 和 default 成员不会影响API
Protected 和public 会被导出到API
实例域绝对不能是public (因为 包含public域的类都不是线程安全的)
在public class中使用public的方法访问private的域</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使可变性最小化不可变类">使可变性最小化(不可变类)<a href="#使可变性最小化不可变类" class="hash-link" aria-label="Direct link to 使可变性最小化(不可变类)" title="Direct link to 使可变性最小化(不可变类)">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="不可变类">不可变类<a href="#不可变类" class="hash-link" aria-label="Direct link to 不可变类" title="Direct link to 不可变类">​</a></h3><p>不可变对象本质上是线程安全的，它们不要求同步; 可以自由地被共享; 但是也有缺点: 对于每个不同的值(状态)都需要一个单独的对象实例来表示, 耗费内存</p><p>定义: 实例不能被修改的类，如：String，Integer等基本类型的包装类</p><p>使类不可变，有如下5条规范：</p><ol><li>不提供任何修改对象状态的方法（mutator）</li><li>保证类不可扩展（如继承），一般使用final修饰类</li><li>Final修饰所有域</li><li>Private修饰所有域</li><li>确保对任何可变元素的互斥访问: 🐍 客户端不能获得类的可变域所指向对象的引用; 🐍 不要用客户端提供的对象初始化类的可变域</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="一个不可变类例子demo">一个不可变类例子demo<a href="#一个不可变类例子demo" class="hash-link" aria-label="Direct link to 一个不可变类例子demo" title="Direct link to 一个不可变类例子demo">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 实现一个标准的不可变类,复数，有实数和虚数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xiaoyu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class Complex {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final double re;//实数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final double im;//虚数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Complex(double re, double im) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       this.re = re;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       this.im = im;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public double getRe() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return re;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public double getIm() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return im;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //加法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Complex add(Complex c) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Complex(re+c.re, im+c.im);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean equals(Object obj) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (obj == this) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!(obj instanceof Complex)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Complex temp = (Complex) obj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Double.compare(re, temp.re) == 0 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Double.compare(im, temp.im) == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int hashCode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // TODO Auto-generated method stub</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return super.hashCode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="不可变类其他实现方式私有化构造器提供static工厂方法">不可变类其他实现方式：私有化构造器，提供static工厂方法<a href="#不可变类其他实现方式私有化构造器提供static工厂方法" class="hash-link" aria-label="Direct link to 不可变类其他实现方式：私有化构造器，提供static工厂方法" title="Direct link to 不可变类其他实现方式：私有化构造器，提供static工厂方法">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//好处是更灵活，可以为静态工厂提供缓存，比如：对于hashcode计算复杂的类，缓存code值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Complex {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final double re;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final double im;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Complex(double re, double im) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.re = re;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.im = im;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Complex valueOf(double re, double im) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return new Complex(re, im);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="不可变类优缺点">不可变类优缺点<a href="#不可变类优缺点" class="hash-link" aria-label="Direct link to 不可变类优缺点" title="Direct link to 不可变类优缺点">​</a></h3><p>线程安全的，它们不要求同步, 可以自由地被共享</p><p>但是  对于每个不同的值都需要一个单独的对象</p><p>缺点的解决办法:</p><ul><li><p>对于频繁会用到值，在类内部提供public static final 的常量</p></li><li><p>或者 对于不可变类，创建一个与之配套的“配套类”，是可变的，如：String和StringBuilder</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="复合组合优于继承">复合(组合)优于继承<a href="#复合组合优于继承" class="hash-link" aria-label="Direct link to 复合(组合)优于继承" title="Direct link to 复合(组合)优于继承">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用复合的场景">使用复合的场景<a href="#使用复合的场景" class="hash-link" aria-label="Direct link to 使用复合的场景" title="Direct link to 使用复合的场景">​</a></h3><p>比较抽象的说法是，只有子类和父类确实存在&quot;is-a&quot;关系的时候使用继承，否则使用复合。
或者比较实际点的说法是，如果TypeB只需要TypeA的部分行为，则考虑使用复合。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="一个具体实例">一个具体实例<a href="#一个具体实例" class="hash-link" aria-label="Direct link to 一个具体实例" title="Direct link to 一个具体实例">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // The number of attempted element insertions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int addCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public InstrumentedHashSet() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public InstrumentedHashSet(int initCap, float loadFactor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(initCap, loadFactor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //覆盖hashset（父类）的两个方法，但是内部还是调用父类的对应方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean add(E e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        addCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return super.add(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //父类addAll内部是通过调用add方法实现，这里计数重复了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean addAll(Collection&lt;? extends E&gt; c) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        addCount += c.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return super.addAll(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getAddCount() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return addCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//解决办法是：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 即，在一个forwarding class中增加一个private field引用现有类的实例，forwarding class中的方法对应现有类的方法。【forwarding class】相当于是一个包装类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Set&lt;E&gt; s; // 组合, 而不是继承</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ForwardingSet(Set&lt;E&gt; s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.s = s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   //省略一些接口 。。。。。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean equals(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s.equals(o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int hashCode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s.hashCode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String toString() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s.toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//使用时直接继承forwarding class：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int addCount = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public InstrumentedSet(Set&lt;E&gt; s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean add(E e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        addCount++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return super.add(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean addAll(Collection&lt;? extends E&gt; c) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        addCount += c.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return super.addAll(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getAddCount() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return addCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="要么为继承而设计并提供文档要么禁止继承">要么为继承而设计，并提供文档，要么禁止继承<a href="#要么为继承而设计并提供文档要么禁止继承" class="hash-link" aria-label="Direct link to 要么为继承而设计，并提供文档，要么禁止继承" title="Direct link to 要么为继承而设计，并提供文档，要么禁止继承">​</a></h2><p>一个类设计为可继承，要遵循：</p><ol><li>构造器不能调用可被覆盖的方法</li><li>如果实现了cloneable、serielizable接口，则clone方法和readObject方法不能调用可被覆盖的方法</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="接口优于抽象类">接口优于抽象类<a href="#接口优于抽象类" class="hash-link" aria-label="Direct link to 接口优于抽象类" title="Direct link to 接口优于抽象类">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="接口和抽象类优缺点">接口和抽象类优缺点<a href="#接口和抽象类优缺点" class="hash-link" aria-label="Direct link to 接口和抽象类优缺点" title="Direct link to 接口和抽象类优缺点">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">对于 接口:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 现有的类可以很容易被更新，以实现新的接口。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 接口是定义mixin（混合类型）的理想选择。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 接口允许我们构造非层次结构的类型框架</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对于 抽象类:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 可以对于一些高层方法提供实现, 而把低层基本方法交给子类去实现(实际上高层方法就是调用的低层方法)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="抽象类和接口合作骨架实现类">抽象类和接口合作：骨架实现类<a href="#抽象类和接口合作骨架实现类" class="hash-link" aria-label="Direct link to 抽象类和接口合作：骨架实现类" title="Direct link to 抽象类和接口合作：骨架实现类">​</a></h3><p>在选择抽象类和接口时，并不是二选一的答案，或干脆枪毙掉抽象类。其实，可以把接口和抽象类的优点结合起来，对于你希望导出（对外提供）的每一个重要接口都提供一个抽象类（骨架实现类）。接口的作用仍然是定义类型，骨架实现类负责实现无需子类关心的方法。</p><p>按照惯例，骨架实现类的命名方法为： AbstractInterface，这里的Interface指的是接口的名字。JDK的的集合框架中，具有大量这样的骨架实现类：AbstractCollection，AbstractSet，AbstractList，AbstractMap</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//假设有一个接口，它可以实现一组对象的求和，代码如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Summation&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //实现两个对象的相加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  T twoEleAdd(T obj01, T obj02);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //实现List求和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  T listEleSum(List&lt;T&gt; list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //实现数组求和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  T arrayEleSum(T[] array);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//根据观察，它的基本方法只有一个T twoEleAdd(T obj01, T obj02);,现在我们可以来实现他的“骨架”了：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractSummation&lt;T&gt; implements Summation&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public abstract T towEleAdd(T obj01, T obj02);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public T listEleSum(List&lt;T&gt; list) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    T firstEle = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (T t : list) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (firstEle == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        firstEle = t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      firstEle = towEleAdd(firstEle, t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return firstEle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public T arrayEleSum(T[] array) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    T firstEle = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (T t : array) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (firstEle == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        firstEle = t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      firstEle = towEleAdd(firstEle, t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return firstEle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//继承这个骨架类就只用实现towEleAdd方法，就可以完成一组对象的求和工作了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="接口只用于定义类型">接口只用于定义类型<a href="#接口只用于定义类型" class="hash-link" aria-label="Direct link to 接口只用于定义类型" title="Direct link to 接口只用于定义类型">​</a></h2><p>类实现接口时，接口就冲当该类实例的类型，为了其他目的（如：引入常量）而定义接口是不好的</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="类层次优于标签类">类层次优于标签类<a href="#类层次优于标签类" class="hash-link" aria-label="Direct link to 类层次优于标签类" title="Direct link to 类层次优于标签类">​</a></h2><p>标签类: 一个类可以有多个风格的实例，如：类Figure（图形），可以有实例Circle（圆），Rectangle（方形），square（正方）; 这些标签类（tagged class）有着许多优点，但是破坏了可读性</p><p>类层次: 继承, 实现</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="用函数对象函数接口表示策略">用函数对象(函数接口)表示策略<a href="#用函数对象函数接口表示策略" class="hash-link" aria-label="Direct link to 用函数对象(函数接口)表示策略" title="Direct link to 用函数对象(函数接口)表示策略">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="策略模式">策略模式<a href="#策略模式" class="hash-link" aria-label="Direct link to 策略模式" title="Direct link to 策略模式">​</a></h3><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户端而独立变化</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="函数对象">函数对象<a href="#函数对象" class="hash-link" aria-label="Direct link to 函数对象" title="Direct link to 函数对象">​</a></h3><p>定义这样一种对象，它的方法执行其他对象上的操作，如果一个类仅仅导出这样的一个方法，它的实例实际上就等同于一个指向该方法的指针。这样的实例被称为函数对象</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class StringLengthComparator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int compare(String s1, String s2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s1.length() - s2.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//这个类是无状态的，没有域，这类的所有实例是功能上等价的，所以可以作为单例存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class StringLengthComparator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private StringLengthComparator() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final StringLengthComparator </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        INSTANCE = new StringLengthComparator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int compare(String s1, String s2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s1.length() - s2.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 但是，用这述这种方法有个问题，就是规定了参数的类型，这样就无法传递任何其他的比较策略。相反，对于这种情况，应该定义一个Comparator接口，并修改StringLengthComparator来实现这个接口。换句话说， 在设计具体的策略类时，还需要定义一个策略接口：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Strategy interface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Comparator&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int compare(T t1, T t2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//当下，前面的具体策略类声名如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class StringLengthComparator implements Comparator&lt;String&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    ... </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//这样，在传递具体策略类的对象的时候，只需要将参数类型定为接口类型(使用接口做类型定义)，现在可以传递其他的比较策略了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//        具体策略类往往使用匿名类声名，如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Arrays.sort(stringArray, new Comparator&lt;String&gt;() { // 1.   当一个具体策略只被使用一次时，通常使用匿名类来声名和实例化这个具体策略。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int compare(String s1, String s2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s1.length() - s2.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2.   当一个具体策略是设计用来重复使用的时候，它的类通常就要被实现为私有的静态成员类，并通过公有的静态final域或静态工厂方法导出，其类型为策略接口。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Exporting a concrete strategy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Host {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class StrlenCmp implements Comparator&lt;String&gt;, Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int compare(String s1, String s2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return s1.length() - s2.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Returned comparator is serializable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final Comparator&lt;String&gt; STRING_LENGTH_COMPARATOR = new StrlenCmp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="优先考虑静态成员类">优先考虑静态成员类<a href="#优先考虑静态成员类" class="hash-link" aria-label="Direct link to 优先考虑静态成员类" title="Direct link to 优先考虑静态成员类">​</a></h2><p>静态成员类 非静态成员类 区别:</p><ol><li><p>非静态成员类 的 实例 与外围类的一个实例 关联 (在非静态成员类内部，可以调用外围的方法，其实例包含一个外围实例的引用)---------------所以会增加构造的时间开销; 所以当不访问外围类时，要声明成静态的static，如果不static，则每个实例将包含一个指向外围类实例的引用，要消耗时间空间，导致外围实例不被回收</p></li><li><p>如果嵌套类实例 能在 外围类实例 之外独立存在，必须是静态成员类 --------------- 所以在没有外围类实例时，不能创建非静态成员类，非静态成员实例的必须要有一个外围实例</p></li></ol><p>使用场景: 如果一个嵌套类需要在一个以上的地方使用，或者它太长了，不适合放在一个方法（注意：不是类）内部，那么应该使用成员类。如果成员类的每个实例都需要一个指向外围实例的应用（需要使用this），则该成员类做成非静态的；否则就应该做成静态的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使用泛型而不要使用原生态类型">使用泛型而不要使用原生态类型<a href="#使用泛型而不要使用原生态类型" class="hash-link" aria-label="Direct link to 使用泛型而不要使用原生态类型" title="Direct link to 使用泛型而不要使用原生态类型">​</a></h2><p>ref: <a href="https://www.jianshu.com/p/000070fc7267" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/000070fc7267</a></p><p>A:原生态类型如 List:不带任何类型参数的泛型名称
B:参数化类型如<code>List&lt;String&gt;</code> ：表示元素类型为String的列表
C:无限制的通配符类型如<code>List&lt;?&gt;</code>:表示元素为未知类型</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="列表优于数组">列表优于数组<a href="#列表优于数组" class="hash-link" aria-label="Direct link to 列表优于数组" title="Direct link to 列表优于数组">​</a></h2><ul><li><p>数组是协变的(convariant)，如果 Sub 是 Super 的子类型，那么数组类型 Sub[] 就是 Super[] 的子类型。泛型是不可变的，<code>List&lt;Sub&gt;</code>不是<code>List&lt;Super&gt;</code>的子类型, 所以优先使用列表可以用到泛型</p></li><li><p>数组是具体化的(reified)，因此数组在运行时才知道并检查它们的元素类型约束, 而泛型约束在编译期间就可以检查.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="优先考虑类型安全的异构容器">优先考虑类型安全的异构容器<a href="#优先考虑类型安全的异构容器" class="hash-link" aria-label="Direct link to 优先考虑类型安全的异构容器" title="Direct link to 优先考虑类型安全的异构容器">​</a></h2><p>普通容器: 泛型中的 &quot;泛型参数&quot;将元素类型定死了, 如：<code>Set&lt;String&gt;</code>，只有一个类型参数，可以存“jjj”“xxxx”等；<code>HashMap&lt;String, Object&gt;</code>集合有两个类型参数，可以存 “小明”-new People(), “小红”-new People()</p><p>异构容器: 一个容器里面它存放的类型参数数目是不固定的，那么它就是一个异构的容器; 如：<code>Map&lt;Class&lt;T&gt;, T&gt;</code>，可以存Student.class-new Student(), Car.class-new Car()</p><p>一个使用场景: 使用一个容器来存放数据库中有任意列的一个行。因为一行，列的数目是不固定的，每个列的类型也是不确定的，那么就可以使用一个异构的容器来表示这个行</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//表示一行记录中的一列， T是类型，valClass是值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Column&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final T valClass ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @SuppressWarnings( &quot;unchecked&quot; )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Column(Class&lt;T&gt; valClass) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this. valClass = (T) valClass;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @SuppressWarnings( &quot;unchecked&quot; )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public T cast(Object obj) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return obj == null ? null : ((Class&lt;T&gt;) valClass).cast(obj);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> //表示一行记录，包含多个column</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DatabaseRow {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Map&lt;Column&lt;?&gt;, Object&gt; row = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public &lt;T&gt; void putColumn(Column&lt;T&gt; type, T instance) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (type == null )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      throw new NullPointerException(&quot;Type is null&quot; );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    row.put(type, instance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public &lt;T&gt; T getColumn(Column&lt;T&gt; type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return type.cast( row.get(type));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DatabaseRow db = new DatabaseRow();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Column&lt;Integer&gt; colInt = new Column&lt;Integer&gt;(Integer. class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Column&lt;Double&gt; colDouble = new Column&lt;Double&gt;(Double. class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Column&lt;Float&gt; colFloat = new Column&lt;Float&gt;(Float. class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.putColumn(colInt, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.putColumn(colDouble, 10.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    db.putColumn(colFloat, 12.3f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System. out.println(colInt.getClass() + &quot; &quot; + colDouble.getClass());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System. out.println(db.getColumn(colInt) + &quot; &quot; + db.getColumn(colDouble));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>枚举和注解</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="用enum代替int常量">用enum代替int常量<a href="#用enum代替int常量" class="hash-link" aria-label="Direct link to 用enum代替int常量" title="Direct link to 用enum代替int常量">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="在枚举enum中使用实例域">在枚举enum中使用实例域<a href="#在枚举enum中使用实例域" class="hash-link" aria-label="Direct link to 在枚举enum中使用实例域" title="Direct link to 在枚举enum中使用实例域">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="实现接口以编写可扩展的枚举类型">实现接口以编写可扩展的枚举类型<a href="#实现接口以编写可扩展的枚举类型" class="hash-link" aria-label="Direct link to 实现接口以编写可扩展的枚举类型" title="Direct link to 实现接口以编写可扩展的枚举类型">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使用注解or接口做标识">使用注解or接口做标识<a href="#使用注解or接口做标识" class="hash-link" aria-label="Direct link to 使用注解or接口做标识" title="Direct link to 使用注解or接口做标识">​</a></h2><p>Java1.5之后，使用注解如：@Test 标明有些元素需要通过xx工具或xx框架特殊处理</p><p>空接口，如：cloneable，serielizable接口
相对于标记注解的优点：</p><ol><li>使用接口，定义了类型，可以在	编译时发现（使用注解情况下）运行时才能显现的错</li><li>可以被更加精确的锁定--------这个还不理解</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="坚持使用override注解">坚持使用@Override注解<a href="#坚持使用override注解" class="hash-link" aria-label="Direct link to 坚持使用@Override注解" title="Direct link to 坚持使用@Override注解">​</a></h2><p>可以避免一大类非法错误
如：覆盖equals，hashcode方法是出错</p><h1>方法</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="在方法开始检查参数的有效性">在方法开始检查参数的有效性<a href="#在方法开始检查参数的有效性" class="hash-link" aria-label="Direct link to 在方法开始检查参数的有效性" title="Direct link to 在方法开始检查参数的有效性">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="进行必要的保护性拷贝">进行必要的保护性拷贝<a href="#进行必要的保护性拷贝" class="hash-link" aria-label="Direct link to 进行必要的保护性拷贝" title="Direct link to 进行必要的保护性拷贝">​</a></h2><p>将传入参数拷贝一份之后再传入</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//在编写不可变类时，或者要让客户端的对象进入内部数据结构中时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class Period {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Date start;  //这里看似不可变，但是Date类是可变的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Date end;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Period(Date start,Date end) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(start.compareTo(end) &gt; 0){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(start + &quot; after &quot; + end);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.start = start;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.end = end;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Date start(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return start;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Date end(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return end;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //remainder omitted  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//由于date是可变的，如下操作即可改变date状态：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Date start = new Date();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Date end = new Date();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Period period = new Period(start, end);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end.setYear(78);  // end 被改变了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(period.end());  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对 构造函数 改进</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Period(Date start,Date end) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.start = new Date(start.getTime());  // 重新赋值一份, 切断 client 和 函数内部的联系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.end = new Date(end.getTime());  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(this.start.compareTo(this.end) &gt; 0){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException(this.start + &quot; after &quot; + this.end);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="慎用重载">慎用重载<a href="#慎用重载" class="hash-link" aria-label="Direct link to 慎用重载" title="Direct link to 慎用重载">​</a></h2><p>重载是发生在编译时的，所以严格的说，它并不是多态, 要调用哪个重载方法是在编译时做出决定的</p><p>对于重载方法的选择是静态（编译时的对象类型决定）的，对于覆盖的方法的选择则是动态（运行时的对象类型决定）的</p><p>是否重载, 只和参数个数, 类型有关, 和返回值无关</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class OverloadTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static String mothod(Collection&lt;?&gt; col) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;unknown collection&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static String mothod(List&lt;?&gt; list) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;list&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Collection&lt;?&gt;[] coll = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new HashSet&lt;String&gt;(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new ArrayList&lt;String&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(Collection&lt;?&gt; c : coll) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(mothod(c));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             //都调用mothod(Collection&lt;?&gt; col)方法，程序将打印两次unknown collection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             // 因为程序调用哪个重载方法是在编译时确定的，在for循环中参数的编译时类型为Collection&lt;?&gt;，所以每次迭代都将调用mothod(Collection&lt;?&gt; col)方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="应该返回0长度的数组或集合而不是null">应该返回0长度的数组或集合，而不是null<a href="#应该返回0长度的数组或集合而不是null" class="hash-link" aria-label="Direct link to 应该返回0长度的数组或集合，而不是null" title="Direct link to 应该返回0长度的数组或集合，而不是null">​</a></h2><p>调用者不必做额外的特例处理，如对是null的情况做额外处理</p><h1>通用程序设计</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使局部变量的作用域最小化">使局部变量的作用域最小化<a href="#使局部变量的作用域最小化" class="hash-link" aria-label="Direct link to 使局部变量的作用域最小化" title="Direct link to 使局部变量的作用域最小化">​</a></h2><ol><li>在第一次使用的时候声明变量</li><li>局部变量都应该初始化，如果不能初始化，就应该推迟声明</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="foreach循环优于传统for循环">Foreach循环优于传统for循环<a href="#foreach循环优于传统for循环" class="hash-link" aria-label="Direct link to Foreach循环优于传统for循环" title="Direct link to Foreach循环优于传统for循环">​</a></h2><p>因为隐藏了索引 i</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="如果要使用精确的答案避免使用float-double">如果要使用精确的答案，避免使用float double<a href="#如果要使用精确的答案避免使用float-double" class="hash-link" aria-label="Direct link to 如果要使用精确的答案，避免使用float double" title="Direct link to 如果要使用精确的答案，避免使用float double">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="基本类型优于装箱类型">基本类型优于装箱类型<a href="#基本类型优于装箱类型" class="hash-link" aria-label="Direct link to 基本类型优于装箱类型" title="Direct link to 基本类型优于装箱类型">​</a></h2><p>节省了内存</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="通过接口引用对象">通过接口引用对象<a href="#通过接口引用对象" class="hash-link" aria-label="Direct link to 通过接口引用对象" title="Direct link to 通过接口引用对象">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="接口优于反射存疑">接口优于反射(存疑)<a href="#接口优于反射存疑" class="hash-link" aria-label="Direct link to 接口优于反射(存疑)" title="Direct link to 接口优于反射(存疑)">​</a></h2><h1>异常</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="对异常的多种处理方式">对异常的多种处理方式<a href="#对异常的多种处理方式" class="hash-link" aria-label="Direct link to 对异常的多种处理方式" title="Direct link to 对异常的多种处理方式">​</a></h2><ul><li><p>异常转译（exception translation） - 如果方法B抛出了NoSuchElementException这个受检异常，然而在方法A中调用方法B时，根据方法A中的逻辑，当遇到NoSuchElementException异常时，抛出一个IndexsOutOfBoundsException异常更为合适。那么就不应该选择向上传播抛出NoSuchElementException，而是应该选择捕获NoSuchElementException，然后抛出IndexsOutOfBoundsException。</p></li><li><p>转换为非受检异常</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使失败保持原子性">使失败保持原子性<a href="#使失败保持原子性" class="hash-link" aria-label="Direct link to 使失败保持原子性" title="Direct link to 使失败保持原子性">​</a></h2><p>操作抛出异常，对象的状态不变，和异常之前的状态一致</p><p>方法1：设计不可变对象
方法2：在执行操作之前，检查参数有效性
方法3：依靠回复代码
方法4：在对象的一份临时拷贝中操作，之后用结果代替原来对象内容</p><h1>jdk中的反面案例</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="滥用继承stack类">滥用继承:stack类<a href="#滥用继承stack类" class="hash-link" aria-label="Direct link to 滥用继承:stack类" title="Direct link to 滥用继承:stack类">​</a></h2><p>util包有一个工具类，明显是滥用继承的代表。没错，这个类就是鼎鼎大名的Stack类了。</p><p>我们知道Statck数据结构本身的特点就是“后进先出”。那么它理想就应该只有两个方法来操纵数据，一个是push()方法，另一个是pop()方法。但是由于继承了Vector，Stack从父亲那里继承了诸如add(),remove(),set()等违反游戏规则的方法。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="值对象应该被设计为不可变对象date类">值对象应该被设计为不可变对象:Date类<a href="#值对象应该被设计为不可变对象date类" class="hash-link" aria-label="Direct link to 值对象应该被设计为不可变对象:Date类" title="Direct link to 值对象应该被设计为不可变对象:Date类">​</a></h2><p>不可变对象是指，实例属性经过初始化后在对象的整个生命周期内固定不变。例如jdk的String以及各种基本类型的包装类。</p><p>不可变对象易于设计，并且在并发环境下更加安全，无需额外的同步机制。</p><p>util包里的Date类属于值对象，类似于人民币一元，十元的概念，应该被设计为不可变对象。也就是说，不应该提供各种setter方法来修改对象的属性域。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="滥用常量接口">滥用常量接口<a href="#滥用常量接口" class="hash-link" aria-label="Direct link to 滥用常量接口" title="Direct link to 滥用常量接口">​</a></h2><p>在接口中定义常量，让使用的类实现该接口---------错误</p><p>常量接口是指没有任何方法，只包含表态final域的接口对象，每一个域都导出一个。实现该接口的类即可获得接口的所有常量属性，看起来非常方便！
然而，常量接口模式是对接口的不良使用。首先，常量的使用应属于内部实现细节，实现常量接口会把这样的细节暴露到导出的API中。其次，如果在后续升级中发现一个类不再需要以前的常量，这个类依然必须实现这个常量接口，以确保向下兼容性。</p><p>jdk平台io包里的ObjectStreamConstants就属于常量接口，不值得效仿。</p><p>那么，如果需要导出常量，最好的选择方案是jdk5引入的枚举类型(enum)。当然，如果某些常量跟某个类或接口联系非常紧密，也可以把这个常量绑定在该类，例如Integer.MAX__VALUE或Math.PI等。</p><p>然而，某些开发人员还是喜欢选择常量接口，因为枚举略显繁琐，而类又必须写一串长长的&quot;public static final &quot;修饰。但是他们的使用还是有底线的，当需要某个常量的，代码只会用XXConstants.XX的模式，而不会直接让类实现这个接口。这种使用算是一种折中方案。采用哪种方法，还是看项目规范吧。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/en/docs/tags/阅读笔记">阅读笔记</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/xiaoyureed/xiaoyureed.github.io/tree/main/docs/effective-java-reading-note.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/en/docs/docker-note-virtual-dev-env"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Docker Note &amp; Other Virtual Develop Environment</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/en/docs/how-to-test-java-app"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">How to Test Java App</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#考虑使用static-factory-method代替构造函数" class="table-of-contents__link toc-highlight">考虑使用static factory method代替构造函数</a><ul><li><a href="#优点" class="table-of-contents__link toc-highlight">优点</a></li><li><a href="#缺点" class="table-of-contents__link toc-highlight">缺点</a></li><li><a href="#场景何时可以替换构造器" class="table-of-contents__link toc-highlight">场景(何时可以替换构造器)</a></li></ul></li><li><a href="#遇到很多可选构造器参数时用构建器builder模式" class="table-of-contents__link toc-highlight">遇到很多可选构造器参数时，用构建器(Builder模式)</a><ul><li><a href="#场景何时使用builder模式" class="table-of-contents__link toc-highlight">场景(何时使用builder模式)</a></li><li><a href="#builder模式" class="table-of-contents__link toc-highlight">Builder模式</a></li></ul></li><li><a href="#private构造器或者使用枚举类型来强化singleton" class="table-of-contents__link toc-highlight">Private构造器或者使用枚举类型来强化singleton</a></li><li><a href="#避免创建不必要的对象" class="table-of-contents__link toc-highlight">避免创建不必要的对象</a><ul><li><a href="#应用场景" class="table-of-contents__link toc-highlight">应用场景</a></li><li><a href="#对于字符串" class="table-of-contents__link toc-highlight">对于字符串</a></li><li><a href="#通过静态工厂方法重用对象" class="table-of-contents__link toc-highlight">通过静态工厂方法重用对象</a></li><li><a href="#重用已知不会被修改的可变对象" class="table-of-contents__link toc-highlight">重用已知不会被修改的可变对象</a></li><li><a href="#视图适配器的实例不需要创建多个存疑" class="table-of-contents__link toc-highlight">视图(适配器)的实例不需要创建多个(存疑)</a></li></ul></li><li><a href="#消除过期的对象引用" class="table-of-contents__link toc-highlight">消除过期的对象引用</a><ul><li><a href="#内存泄漏栈的内存泄露" class="table-of-contents__link toc-highlight">内存泄漏:栈的内存泄露</a></li><li><a href="#内存泄漏缓存判断是否过期" class="table-of-contents__link toc-highlight">内存泄漏:缓存判断是否过期</a></li><li><a href="#内存泄漏注册回调后不要忘记取消注册" class="table-of-contents__link toc-highlight">内存泄漏:注册回调后不要忘记取消注册</a></li></ul></li><li><a href="#避免使用终结方法" class="table-of-contents__link toc-highlight">避免使用终结方法</a></li><li><a href="#覆盖equals" class="table-of-contents__link toc-highlight">覆盖equals()</a><ul><li><a href="#何时覆盖" class="table-of-contents__link toc-highlight">何时覆盖</a></li><li><a href="#覆盖时需要遵守的约定" class="table-of-contents__link toc-highlight">覆盖时需要遵守的约定</a></li><li><a href="#怎么实现高质量的equals方法" class="table-of-contents__link toc-highlight">怎么实现高质量的equals方法</a></li></ul></li><li><a href="#覆盖hashcode" class="table-of-contents__link toc-highlight">覆盖hashCode()</a><ul><li><a href="#一种覆盖方式" class="table-of-contents__link toc-highlight">一种覆盖方式</a></li><li><a href="#如果一个类是不可变的且计算hashcode开销比较大可以考虑把散列码缓存在对象内部" class="table-of-contents__link toc-highlight">如果一个类是不可变的，且计算hashcode开销比较大，可以考虑把散列码缓存在对象内部</a></li></ul></li><li><a href="#最好始终覆盖tostring" class="table-of-contents__link toc-highlight">最好始终覆盖toString()</a></li><li><a href="#谨慎地覆盖clone" class="table-of-contents__link toc-highlight">谨慎地覆盖clone()</a><ul><li><a href="#常规做法" class="table-of-contents__link toc-highlight">常规做法</a></li><li><a href="#更好的做法" class="table-of-contents__link toc-highlight">更好的做法</a></li></ul></li><li><a href="#考虑实现comparable接口" class="table-of-contents__link toc-highlight">考虑实现comparable接口</a></li><li><a href="#使类和成员的可访问性最小化" class="table-of-contents__link toc-highlight">使类和成员的可访问性最小化</a></li><li><a href="#使可变性最小化不可变类" class="table-of-contents__link toc-highlight">使可变性最小化(不可变类)</a><ul><li><a href="#不可变类" class="table-of-contents__link toc-highlight">不可变类</a></li><li><a href="#一个不可变类例子demo" class="table-of-contents__link toc-highlight">一个不可变类例子demo</a></li><li><a href="#不可变类其他实现方式私有化构造器提供static工厂方法" class="table-of-contents__link toc-highlight">不可变类其他实现方式：私有化构造器，提供static工厂方法</a></li><li><a href="#不可变类优缺点" class="table-of-contents__link toc-highlight">不可变类优缺点</a></li></ul></li><li><a href="#复合组合优于继承" class="table-of-contents__link toc-highlight">复合(组合)优于继承</a><ul><li><a href="#使用复合的场景" class="table-of-contents__link toc-highlight">使用复合的场景</a></li><li><a href="#一个具体实例" class="table-of-contents__link toc-highlight">一个具体实例</a></li></ul></li><li><a href="#要么为继承而设计并提供文档要么禁止继承" class="table-of-contents__link toc-highlight">要么为继承而设计，并提供文档，要么禁止继承</a></li><li><a href="#接口优于抽象类" class="table-of-contents__link toc-highlight">接口优于抽象类</a><ul><li><a href="#接口和抽象类优缺点" class="table-of-contents__link toc-highlight">接口和抽象类优缺点</a></li><li><a href="#抽象类和接口合作骨架实现类" class="table-of-contents__link toc-highlight">抽象类和接口合作：骨架实现类</a></li></ul></li><li><a href="#接口只用于定义类型" class="table-of-contents__link toc-highlight">接口只用于定义类型</a></li><li><a href="#类层次优于标签类" class="table-of-contents__link toc-highlight">类层次优于标签类</a></li><li><a href="#用函数对象函数接口表示策略" class="table-of-contents__link toc-highlight">用函数对象(函数接口)表示策略</a><ul><li><a href="#策略模式" class="table-of-contents__link toc-highlight">策略模式</a></li><li><a href="#函数对象" class="table-of-contents__link toc-highlight">函数对象</a></li></ul></li><li><a href="#优先考虑静态成员类" class="table-of-contents__link toc-highlight">优先考虑静态成员类</a></li><li><a href="#使用泛型而不要使用原生态类型" class="table-of-contents__link toc-highlight">使用泛型而不要使用原生态类型</a></li><li><a href="#列表优于数组" class="table-of-contents__link toc-highlight">列表优于数组</a></li><li><a href="#优先考虑类型安全的异构容器" class="table-of-contents__link toc-highlight">优先考虑类型安全的异构容器</a></li><li><a href="#用enum代替int常量" class="table-of-contents__link toc-highlight">用enum代替int常量</a></li><li><a href="#在枚举enum中使用实例域" class="table-of-contents__link toc-highlight">在枚举enum中使用实例域</a></li><li><a href="#实现接口以编写可扩展的枚举类型" class="table-of-contents__link toc-highlight">实现接口以编写可扩展的枚举类型</a></li><li><a href="#使用注解or接口做标识" class="table-of-contents__link toc-highlight">使用注解or接口做标识</a></li><li><a href="#坚持使用override注解" class="table-of-contents__link toc-highlight">坚持使用@Override注解</a></li><li><a href="#在方法开始检查参数的有效性" class="table-of-contents__link toc-highlight">在方法开始检查参数的有效性</a></li><li><a href="#进行必要的保护性拷贝" class="table-of-contents__link toc-highlight">进行必要的保护性拷贝</a></li><li><a href="#慎用重载" class="table-of-contents__link toc-highlight">慎用重载</a></li><li><a href="#应该返回0长度的数组或集合而不是null" class="table-of-contents__link toc-highlight">应该返回0长度的数组或集合，而不是null</a></li><li><a href="#使局部变量的作用域最小化" class="table-of-contents__link toc-highlight">使局部变量的作用域最小化</a></li><li><a href="#foreach循环优于传统for循环" class="table-of-contents__link toc-highlight">Foreach循环优于传统for循环</a></li><li><a href="#如果要使用精确的答案避免使用float-double" class="table-of-contents__link toc-highlight">如果要使用精确的答案，避免使用float double</a></li><li><a href="#基本类型优于装箱类型" class="table-of-contents__link toc-highlight">基本类型优于装箱类型</a></li><li><a href="#通过接口引用对象" class="table-of-contents__link toc-highlight">通过接口引用对象</a></li><li><a href="#接口优于反射存疑" class="table-of-contents__link toc-highlight">接口优于反射(存疑)</a></li><li><a href="#对异常的多种处理方式" class="table-of-contents__link toc-highlight">对异常的多种处理方式</a></li><li><a href="#使失败保持原子性" class="table-of-contents__link toc-highlight">使失败保持原子性</a></li><li><a href="#滥用继承stack类" class="table-of-contents__link toc-highlight">滥用继承:stack类</a></li><li><a href="#值对象应该被设计为不可变对象date类" class="table-of-contents__link toc-highlight">值对象应该被设计为不可变对象:Date类</a></li><li><a href="#滥用常量接口" class="table-of-contents__link toc-highlight">滥用常量接口</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/en/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/en/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/en/assets/js/runtime~main.674636ef.js"></script>
<script src="/en/assets/js/main.b3bfd78e.js"></script>
</body>
</html>