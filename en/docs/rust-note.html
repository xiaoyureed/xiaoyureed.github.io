<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-rust-note">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Rust 笔记🌈 | Xiaoyureed&#x27;s 网络 Wiki </title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://xiaoyureed.github.io/en/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://xiaoyureed.github.io/en/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://xiaoyureed.github.io/en/docs/rust-note"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Rust 笔记🌈 | Xiaoyureed&#x27;s 网络 Wiki "><meta data-rh="true" name="description" content="- 1. 简单介绍"><meta data-rh="true" property="og:description" content="- 1. 简单介绍"><link data-rh="true" rel="icon" href="/en/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://xiaoyureed.github.io/en/docs/rust-note"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/en/docs/rust-note" hreflang="en"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/rust-note" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/rust-note" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/en/blog/rss.xml" title="Xiaoyureed&#39;s 网络 Wiki  RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/en/blog/atom.xml" title="Xiaoyureed&#39;s 网络 Wiki  Atom Feed"><link rel="stylesheet" href="/en/assets/css/styles.8eda099e.css">
<link rel="preload" href="/en/assets/js/runtime~main.71354b01.js" as="script">
<link rel="preload" href="/en/assets/js/main.be3ba4f3.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/en/"><div class="navbar__logo"><img src="/en/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/en/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Xiaoyureed</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/en/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/en/blog">Blog</a><a href="https://github.com/xiaoyureed" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/intro">intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/FreeMarker-note">FreeMarker Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/SpringBoot-note">Spring Boot 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/agile-development-user-story-scrum">敏捷开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/android">Android 开发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/autohotkey">Autohotkey 脚本</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/blockchain">blockchain区块链</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/c-sharp-and-dot-net">C# &amp; .NET</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/chatgpt">Chatgpt Usage Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cloud-native-platform">云服务平台</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cpp">CPP and C 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cross-gfw">Cross The GFW</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cs-note">Computer Science Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/css-pre-processor">几种CSS预处理器比较选型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/data-structure-and-algorithm">Data Structure and Algorithm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/design-pattern-note">Design Pattern 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/dev-resources">开发者资源</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/devops">DevOps</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/distributed-system">Distributed System 分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/docker-note-virtual-dev-env">Docker Note &amp; Other Virtual Develop Environment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/effective-java-reading-note">Effective Java 阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/elk-elastic-log">Distributed log collection分布式日志收集</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/english-note">英语学习🔥</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/extjs-note">Extjs 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/flutter">flutter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/games-development-introduce">游戏开发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/git-note">Git 备忘 🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/github-starts">Github 星标⭐️</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/golang-note">Golang 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/gps-gis-tracing">基于地理位置开发技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/gradle">gradle</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/greasy-monkey">油猴插件&amp;编写脚本🐒</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/groovy-note">groovy note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/health">Health 关爱程序员健康🏥</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/how-to-test-java-app">How to Test Java App</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/html-note">HTML 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/idea-note">InteliJ idea tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/interview-system-design">经典的系统设计思路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/iot">Iot 物联网</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/java-code-clean">Java Clean Code Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/java-concurrent">Java Concurrent🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/java-memory-model-jmm-jvm">JMM and GC🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/java-note">Java Core 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/jquery-note">JQuery notes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/js-tutorial">JavaScript tutorial</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/kotlin">kotlin</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/kubernetes-k8s">kubernetes-k8s ☁️</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/linux-note">鸟哥的 Linux 私房菜阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/mac">Mac 开发环境</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/machine-learning-ml">machine-learning-ml</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/maven-note">Maven Notes🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/message-queue">Message Queue🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/money">Investment Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/mongodb-note">MongoDB Notes🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/monitor-system-grafana-prometheus-influxdb-hbase">monitor-system-grafana-prometheus监控🖥</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/mvc-mvvm">MVC to MVVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/mybatis-note">MyBatis Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/netty-note">netty</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/nlp-natural-language-processing">nlp-natural-language-processing👄</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/nodejs-yarn-npm">Nodejs, Yarn, Npm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/oracle">Oracle 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-audio-video">Audio and Video development Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-big-data-introduce">大数据开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-cache">Cache 缓存🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-computational-ad">计算广告 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-crawler-spider">网络爬虫 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-db-design-note">关系型数据库表设计🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-desktop-develop">桌面应用开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-http">HTTP protocol Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-reactive-programming">响应式编程 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-rest-api">RESTful api 及 其他webService技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-rpc">RPC Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-rule-engine-note">规则引擎 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/php-note">PHP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/play-framework">Play框架</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/postgres-note">Postgres note🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/process-workflow-bpm-engine">工作流引擎</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/protect-your-app-authentication-oauth2-jwt-https">Protect Your App 安全保护认证鉴权🔑</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/python-note">Python🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/quant-money">量化交易</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/quarkus">Quarkus</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/react-note">React🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/real-time-communication-protocol">实时通信 Real-time</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/redis-note">Redis🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/regex">Regular Expression 正则🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/en/docs/rust-note">Rust 笔记🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/saas-paas-iaas-as-a-service">SaaS Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/serverless">Serverless</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/service-mesh">service mesh 服务网格</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/servlet">Servlet Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/shell-bash-note">shell-bash脚本收集</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/spring-note">Spring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/springcloud-note">Spring Cloud 笔记🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/springmvc-note">Spring MVC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/task-schedule-note">Task Schedule</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/tcp-ip-note">TCP IP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/tomcat-jetty-nginx">Tomcat Jetty Nginx 等 web 容器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/vertx">Vertx</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/video-creator">拍摄</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/webassembly">webassembly</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/webpack-esbuild-vite-rollup">前端打包构建工具</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/windows-sub-system-on-linux">WSL 使用</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/en/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Rust 笔记🌈</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Rust 笔记🌈</h1></header><ul><li><a href="#1-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">1. 简单介绍</a><ul><li><a href="#11-%E6%84%9F%E6%82%9F">1.1. 感悟</a></li><li><a href="#12-%E6%9E%B6%E6%9E%84">1.2. 架构</a></li><li><a href="#13-%E4%BC%98%E7%82%B9-%E5%AF%B9%E6%AF%94">1.3. 优点 对比</a></li><li><a href="#14-%E6%80%9D%E6%83%B3">1.4. 思想</a></li><li><a href="#15-%E8%AF%AD%E4%B9%89-%E6%A6%82%E5%BF%B5">1.5. 语义 概念</a></li></ul></li><li><a href="#2-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">2. 开发环境配置</a><ul><li><a href="#21-install">2.1. install</a></li><li><a href="#22-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8">2.2. 命令行工具使用</a></li><li><a href="#23-ide">2.3. IDE</a></li><li><a href="#24-%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F">2.4. 配置国内镜像</a></li></ul></li><li><a href="#3-%E6%A0%87%E5%87%86%E5%BA%93">3. 标准库</a><ul><li><a href="#31-path-%E8%B7%AF%E5%BE%84">3.1. path 路径</a></li><li><a href="#32-%E6%97%B6%E9%97%B4">3.2. 时间</a></li></ul></li><li><a href="#4-%E5%AF%B9%E6%AF%94-2018">4. 对比 2018</a><ul><li><a href="#41-nll">4.1. nll</a></li><li><a href="#42-raw-identifier">4.2. Raw identifier</a></li><li><a href="#43-%E7%AE%80%E5%8C%96%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">4.3. 简化模式匹配</a></li><li><a href="#44-main-%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%BF%94%E5%9B%9E-result">4.4. main 函数可以返回 Result</a></li><li><a href="#45-impl-trait-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B">4.5. impl trait 抽象类型</a></li></ul></li><li><a href="#5-%E8%AF%AD%E6%B3%95">5. 语法</a><ul><li><a href="#51-%E6%B3%A8%E9%87%8A">5.1. 注释</a></li><li><a href="#52-%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC">5.2. 变量赋值</a><ul><li><a href="#521-%E9%BB%98%E8%AE%A4%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84">5.2.1. 默认是不可变的</a></li><li><a href="#522-%E5%AD%97%E9%9D%A2%E9%87%8F">5.2.2. 字面量</a></li></ul></li><li><a href="#53-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">5.3. 基本数据类型</a><ul><li><a href="#531-convert">5.3.1. convert</a></li><li><a href="#532-%E5%80%BC%E7%B1%BB%E5%9E%8B-and-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">5.3.2. 值类型 and 引用类型</a></li><li><a href="#533-%E5%B8%B8%E9%87%8F-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">5.3.3. 常量 静态变量</a></li><li><a href="#534-%E6%95%B0%E5%AD%97">5.3.4. 数字</a></li><li><a href="#535-%E5%B8%83%E5%B0%94%E5%80%BC-%E5%AD%97%E7%AC%A6-%E5%AD%97%E8%8A%82">5.3.5. 布尔值 字符 字节</a></li><li><a href="#536-%E6%95%B0%E7%BB%84">5.3.6. 数组</a></li><li><a href="#537-range-%E8%8C%83%E5%9B%B4">5.3.7. Range 范围</a></li><li><a href="#538-%E5%88%87%E7%89%87">5.3.8. 切片</a></li><li><a href="#539-str-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87">5.3.9. str 字符串切片</a></li><li><a href="#5310-%E5%8E%9F%E7%94%9F%E6%8C%87%E9%92%88-raw-pointer">5.3.10. 原生指针 raw pointer</a></li><li><a href="#5311-never-%E7%B1%BB%E5%9E%8B-%E6%84%9F%E5%8F%B9%E5%8F%B7">5.3.11. never 类型 感叹号</a></li></ul></li><li><a href="#54-%E5%AD%97%E7%AC%A6%E4%B8%B2">5.4. 字符串</a><ul><li><a href="#541-%E5%87%A0%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%BA%E5%88%AB">5.4.1. 几种字符串区别</a></li><li><a href="#542-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">5.4.2. 常用方法</a></li><li><a href="#543-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2">5.4.3. 字符串转换</a></li><li><a href="#544-%E6%A0%BC%E5%BC%8F%E5%8C%96">5.4.4. 格式化</a></li><li><a href="#545-%E8%B0%83%E8%AF%95%E6%89%93%E5%8D%B0%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B-debug-display">5.4.5. 调试打印复合类型 Debug Display</a></li><li><a href="#546-%E9%97%AE%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%A4%9A%E6%AC%A1%E5%86%99">5.4.6. 问号操作符 多次写</a></li></ul></li><li><a href="#55-%E9%9B%86%E5%90%88">5.5. 集合</a><ul><li><a href="#551-vec-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84">5.5.1. Vec 动态数组</a></li><li><a href="#552-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-vecdeque">5.5.2. 双端队列 VecDeque</a></li><li><a href="#553-%E9%93%BE%E8%A1%A8-linkedlist">5.5.3. 链表 Linkedlist</a></li><li><a href="#554-hashmap-%E6%97%A0%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8">5.5.4. hashmap 无序哈希表</a><ul><li><a href="#5541-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">5.5.4.1. 哈希表基本使用</a></li><li><a href="#5542-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA-key">5.5.4.2. 复合类型作为 key</a></li><li><a href="#5543-%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E6%94%BB%E5%87%BB">5.5.4.3. 哈希碰撞攻击</a></li></ul></li><li><a href="#555-btreemap-%E6%9C%89%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8">5.5.5. BTreeMap 有序哈希表</a></li><li><a href="#556-hashset-%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88">5.5.6. hashset 无序集合</a></li><li><a href="#557-btreeset-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88">5.5.7. BTreeSet 有序集合</a></li><li><a href="#558-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-binaryheap">5.5.8. 优先队列 BinaryHeap</a></li></ul></li><li><a href="#56-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.6. 类型转换</a><ul><li><a href="#561-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.6.1. 基本的类型转换</a></li><li><a href="#562-%E8%BD%AC%E6%8D%A2%E7%9B%B8%E5%85%B3%E7%9A%84-trait">5.6.2. 转换相关的 trait</a></li></ul></li><li><a href="#57-%E6%89%80%E6%9C%89%E6%9D%83">5.7. 所有权</a><ul><li><a href="#571-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%89%80%E6%9C%89%E6%9D%83-raii%E6%9C%BA%E5%88%B6">5.7.1. 为什么需要所有权 RAII机制</a></li><li><a href="#572-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">5.7.2. 基本原则</a></li><li><a href="#573-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B5%8B%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83">5.7.3. 字符串赋值的所有权</a></li><li><a href="#574-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83">5.7.4. 函数参数的所有权</a></li><li><a href="#575-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%89%80%E6%9C%89%E6%9D%83">5.7.5. 函数返回值所有权</a></li><li><a href="#576-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83">5.7.6. 复合类型中的所有权</a></li><li><a href="#577-%E5%A4%9A%E6%89%80%E6%9C%89%E6%9D%83">5.7.7. 多所有权</a></li></ul></li><li><a href="#58-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%82%E6%95%B0">5.8. 生命周期参数</a><ul><li><a href="#581-%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">5.8.1. 什么是生命周期</a></li><li><a href="#582-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E9%87%8A">5.8.2. 为什么存在生命周期注释</a></li><li><a href="#583-%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%82%E6%95%B0">5.8.3. 函数中的生命周期参数</a></li><li><a href="#584-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E7%9C%81%E7%95%A5%E7%9A%84%E8%A7%84%E5%88%99">5.8.4. 结构体中生命周期 省略的规则</a></li><li><a href="#585-%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E9%87%8A">5.8.5. 静态生命周期注释</a></li><li><a href="#586-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BA%A6%E6%9D%9F">5.8.6. 生命周期约束</a></li></ul></li><li><a href="#59-%E5%BC%95%E7%94%A8">5.9. 引用</a><ul><li><a href="#591-%E5%BC%95%E7%94%A8%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">5.9.1. 引用基本介绍</a></li><li><a href="#592-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8">5.9.2. 不可变引用</a></li><li><a href="#593-%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8">5.9.3. 可变引用</a></li><li><a href="#594-%E5%9E%82%E6%82%AC%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98dangling-references">5.9.4. 垂悬引用问题（Dangling References</a></li></ul></li><li><a href="#510-%E8%A3%B8%E6%8C%87%E9%92%88">5.10. 裸指针</a></li><li><a href="#511-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">5.11. 智能指针</a><ul><li><a href="#5111-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BB%8B%E7%BB%8D-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6">5.11.1. 智能指针介绍 工作机制</a></li><li><a href="#5112-raii%E6%9C%BA%E5%88%B6-%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6">5.11.2. RAII机制 实现内存回收</a></li><li><a href="#5113-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%BC%95%E7%94%A8-deref-%E5%92%8C-drop">5.11.3. 自定义智能指针 自动解引用 Deref 和 Drop</a></li><li><a href="#5114-box-%E6%97%A0%E7%97%9B%E4%BD%BF%E7%94%A8%E5%A0%86%E5%86%85%E5%AD%98">5.11.4. Box 无痛使用堆内存</a><ul><li><a href="#51141-box%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">5.11.4.1. Box基本使用</a></li><li><a href="#51142-%E5%8C%85%E8%A3%85%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B-dst">5.11.4.2. 包装动态大小类型 DST</a></li></ul></li><li><a href="#5115-rc-%E5%92%8C-weak-%E5%85%B1%E4%BA%AB%E5%A0%86%E5%86%85%E5%AD%98">5.11.5. Rc 和 Weak 共享堆内存</a><ul><li><a href="#51151-rc-%E5%BC%BA%E5%BC%95%E7%94%A8">5.11.5.1. Rc 强引用</a></li><li><a href="#51152-%E6%9E%84%E9%80%A0%E9%93%BE%E8%A1%A8">5.11.5.2. 构造链表</a></li><li><a href="#51153-weak-%E5%BC%B1%E5%BC%95%E7%94%A8">5.11.5.3. Weak 弱引用</a></li></ul></li><li><a href="#5116-refcell-%E5%92%8C-cell-%E6%8F%90%E4%BE%9B%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7">5.11.6. RefCell 和 Cell 提供内部可变性</a><ul><li><a href="#51161-cell">5.11.6.1. Cell</a></li><li><a href="#51162-refcell">5.11.6.2. RefCell</a></li></ul></li><li><a href="#5117-rc-box-refcell-cell-%E5%87%A0%E7%A7%8D%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94-%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8">5.11.7. Rc Box RefCell Cell 几种指针的区别对比 组合使用</a></li><li><a href="#5118-pin-%E5%92%8C-unpin">5.11.8. Pin 和 Unpin</a></li><li><a href="#5119-cow-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6">5.11.9. Cow 写时复制</a></li></ul></li><li><a href="#512-%E5%87%BD%E6%95%B0">5.12. 函数</a><ul><li><a href="#5121-%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">5.12.1. 函数基本语法</a></li><li><a href="#5122-%E5%87%BD%E6%95%B0%E4%BD%93%E8%A1%A8%E8%BE%BE%E5%BC%8F">5.12.2. 函数体表达式</a></li><li><a href="#5123-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">5.12.3. 函数作为参数</a></li><li><a href="#5124-result-%E8%BF%94%E5%9B%9E%E5%80%BC">5.12.4. Result 返回值</a></li><li><a href="#5125-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C-cfe">5.12.5. 编译期函数执行 cfe</a></li><li><a href="#5126-%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0">5.12.6. 发散函数</a></li><li><a href="#5127-%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">5.12.7. 泛型函数</a></li><li><a href="#5128-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">5.12.8. 高阶函数</a><ul><li><a href="#51281-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">5.12.8.1. 函数指针</a></li><li><a href="#51282-%E7%A6%81%E6%AD%A2%E5%87%BD%E6%95%B0%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%8F%98%E9%87%8F">5.12.8.2. 禁止函数捕获外部环境中变量</a></li></ul></li></ul></li><li><a href="#513-%E9%97%AD%E5%8C%85">5.13. 闭包</a><ul><li><a href="#5131-%E9%97%AD%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">5.13.1. 闭包基本使用</a></li><li><a href="#5132-rust-%E5%AE%9E%E7%8E%B0%E9%97%AD%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86">5.13.2. rust 实现闭包的原理</a></li><li><a href="#5133-%E6%8D%95%E8%8E%B7%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-and-%E4%B8%89%E7%A7%8D%E9%97%AD%E5%8C%85%E7%B1%BB%E5%9E%8B">5.13.3. 捕获环境变量 and 三种闭包类型</a></li><li><a href="#5134-%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC-or-%E5%8F%82%E6%95%B0">5.13.4. 闭包作为返回值 or 参数</a><ul><li><a href="#51341-%E9%80%83%E9%80%B8%E9%97%AD%E5%8C%85-%E9%9D%9E%E9%80%83%E9%80%B8%E9%97%AD%E5%8C%85">5.13.4.1. 逃逸闭包 非逃逸闭包</a></li><li><a href="#51342-%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">5.13.4.2. 闭包作为参数</a></li><li><a href="#51343-%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC">5.13.4.3. 闭包作为返回值</a></li><li><a href="#51344-%E9%97%AD%E5%8C%85%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">5.13.4.4. 闭包参数中的生命周期</a></li></ul></li><li><a href="#5135-%E8%BF%AD%E4%BB%A3%E5%99%A8">5.13.5. 迭代器</a><ul><li><a href="#51351-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8">5.13.5.1. 什么是迭代器</a></li><li><a href="#51352-iterator-trait">5.13.5.2. Iterator trait</a></li><li><a href="#51353-%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-%E6%94%B6%E9%9B%86%E5%99%A8-%E5%87%BD%E6%95%B0%E5%BC%8F%E9%A3%8E%E6%A0%BC">5.13.5.3. 迭代器适配器 收集器 函数式风格</a></li><li><a href="#51354-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8">5.13.5.4. 自定义迭代器</a></li><li><a href="#51355-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%82%E9%85%8D%E5%99%A8-%E6%94%B6%E9%9B%86%E5%99%A8">5.13.5.5. 自定义适配器 收集器</a></li></ul></li></ul></li><li><a href="#514-%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF">5.14. 条件循环</a></li><li><a href="#515-%E6%B3%9B%E5%9E%8B">5.15. 泛型</a><ul><li><a href="#5151-%E5%8D%95%E6%80%81%E5%8C%96">5.15.1. 单态化</a></li><li><a href="#5152-%E5%A4%9A%E9%87%8D%E7%BA%A6%E6%9D%9F-%E5%8A%A0%E5%8F%B7">5.15.2. 多重约束 加号</a></li><li><a href="#5153-%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0-and-%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">5.15.3. 默认泛型参数 and 关联类型</a></li><li><a href="#5154-%E7%A9%BA%E7%BA%A6%E6%9D%9F">5.15.4. 空约束</a></li><li><a href="#5155-turbofish-%E6%93%8D%E4%BD%9C%E7%AC%A6-and-%E8%BF%94%E5%9B%9E%E5%80%BC%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC">5.15.5. turbofish 操作符 and 返回值自动推导</a></li></ul></li><li><a href="#516-trait">5.16. trait</a><ul><li><a href="#5161-trait-%E6%A6%82%E5%BF%B5">5.16.1. trait 概念</a><ul><li><a href="#51611-trait-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">5.16.1.1. trait 基本使用</a></li><li><a href="#51612-%E5%AD%A4%E5%84%BF%E8%A7%84%E5%88%99-%E9%80%9A%E8%BF%87fundamental%E8%A7%84%E9%81%BF">5.16.1.2. 孤儿规则 通过fundamental规避</a></li><li><a href="#51613-%E7%89%B9%E5%8C%96-specialization">5.16.1.3. 特化 Specialization</a></li><li><a href="#51614-trait-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0-%E9%9C%80%E8%A6%81-impl-%E5%89%8D%E7%BC%80">5.16.1.4. trait 作为参数 需要 impl 前缀</a></li><li><a href="#51615-trait-%E4%BD%9C%E4%B8%BA-%E8%BF%94%E5%9B%9E%E5%80%BC-%E8%BF%94%E5%9B%9E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B">5.16.1.5. trait 作为 返回值 返回动态类型</a></li><li><a href="#51616-trait-%E7%BB%A7%E6%89%BF">5.16.1.6. trait 继承</a></li><li><a href="#51617-%E9%9D%99%E6%80%81%E5%88%86%E5%8F%91-%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91">5.16.1.7. 静态分发 动态分发</a></li><li><a href="#51618-%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B">5.16.1.8. 使用抽象类型</a><ul><li><a href="#516181-trait%E5%AF%B9%E8%B1%A1">5.16.1.8.1. trait对象</a></li><li><a href="#516182-trait%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-sized-trait">5.16.1.8.2. trait对象安全问题 Sized trait</a></li><li><a href="#516183-impl-trait">5.16.1.8.3. impl trait</a></li></ul></li><li><a href="#51619-trait%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.16.1.9. trait的类型转换</a></li></ul></li><li><a href="#5162-%E5%8F%AF%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC%E7%9A%84trait">5.16.2. 可自动推导的trait</a></li><li><a href="#5163-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9B%B8%E5%85%B3%E7%9A%84trait">5.16.3. 运算符重载相关的trait</a></li><li><a href="#5164-from-%E5%92%8C-into">5.16.4. From 和 Into</a></li><li><a href="#5165-derefmut-%E5%92%8C-deref">5.16.5. DerefMut 和 Deref</a></li><li><a href="#5166-asref-asmut">5.16.6. AsRef AsMut</a></li><li><a href="#5167-borrow-trait">5.16.7. Borrow trait</a></li><li><a href="#5168-drop-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE">5.16.8. Drop 资源释放</a></li><li><a href="#5169-%E6%A0%87%E7%AD%BE-trait">5.16.9. 标签 trait</a><ul><li><a href="#51691-send-%E5%92%8C-sync">5.16.9.1. Send 和 Sync</a></li><li><a href="#51692-copy-trait">5.16.9.2. Copy trait</a></li><li><a href="#51693-sized-trait--%E5%92%8C-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8Bdst">5.16.9.3. Sized trait  和 动态类型DST</a></li></ul></li><li><a href="#51610-default-trait">5.16.10. Default trait</a></li><li><a href="#51611-extend-trait">5.16.11. Extend trait</a></li><li><a href="#51612-any-trait">5.16.12. Any trait</a></li><li><a href="#51613-%E5%92%8C%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%9A%84trait">5.16.13. 和比较排序相关的trait</a></li></ul></li><li><a href="#517-%E5%85%83%E7%BB%84">5.17. 元组</a></li><li><a href="#518-%E7%BB%93%E6%9E%84%E4%BD%93">5.18. 结构体</a><ul><li><a href="#5181-%E7%BB%93%E6%9E%84%E4%BD%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">5.18.1. 结构体基本使用</a></li><li><a href="#5182-%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93-and-%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93">5.18.2. 元组结构体 and 单元结构体</a></li><li><a href="#5183-%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95">5.18.3. 结构体方法</a></li><li><a href="#5184-new-type-%E6%A8%A1%E5%BC%8F-%E5%92%8C-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-self%E5%88%AB%E5%90%8D">5.18.4. new type 模式 和 类型别名 Self别名</a></li><li><a href="#5185-%E6%A1%88%E4%BE%8B-%E5%BD%A9%E8%89%B2%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA">5.18.5. 案例 彩色命令行输出</a></li></ul></li><li><a href="#519-%E6%9E%9A%E4%B8%BE">5.19. 枚举</a><ul><li><a href="#5191-%E6%9E%9A%E4%B8%BE%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">5.19.1. 枚举基本使用</a></li><li><a href="#5192-option">5.19.2. Option</a></li><li><a href="#5193-c-%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%9E%9A%E4%B8%BE">5.19.3. c 风格的枚举</a></li><li><a href="#5194-%E6%A1%88%E4%BE%8B-%E5%BD%A9%E8%89%B2%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96">5.19.4. 案例 彩色命令行输出优化</a></li><li><a href="#5195-%E5%AE%9E%E4%BE%8B-%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8">5.19.5. 实例 创建链表</a></li></ul></li><li><a href="#520-match-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">5.20. match 模式匹配</a><ul><li><a href="#5201-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">5.20.1. 模式匹配简单使用</a></li><li><a href="#5202-if-lef-while-let-%E8%AF%AD%E6%B3%95%E7%B3%96">5.20.2. if lef while let 语法糖</a></li></ul></li><li><a href="#521-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">5.21. 错误处理</a><ul><li><a href="#5211-%E6%96%AD%E8%A8%80">5.21.1. 断言</a></li><li><a href="#5212-panic-%E5%92%8C-abort">5.21.2. panic 和 Abort</a></li><li><a href="#5213-result--%E5%92%8C-%E9%97%AE%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6">5.21.3. Result  和 问号操作符</a></li><li><a href="#5214-%E9%94%99%E8%AF%AF%E8%A3%85%E7%AE%B1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">5.21.4. 错误装箱 自定义异常</a></li><li><a href="#5215-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8">5.21.5. 捕获异常</a></li><li><a href="#5216-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%BF%9B%E5%8C%96%E8%BF%87%E7%A8%8B">5.21.6. 错误处理进化过程</a></li><li><a href="#5217-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">5.21.7. 第三方库处理异常</a></li></ul></li><li><a href="#522-io">5.22. io</a><ul><li><a href="#5221-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">5.22.1. 命令行参数</a></li><li><a href="#5222-%E6%96%87%E4%BB%B6-io">5.22.2. 文件 io</a></li></ul></li><li><a href="#523-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-oop">5.23. 面向对象 oop</a><ul><li><a href="#5231-%E5%8F%AF%E8%A7%81%E6%80%A7">5.23.1. 可见性</a></li><li><a href="#5232-%E5%A4%9A%E6%80%81">5.23.2. 多态</a></li><li><a href="#5233-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B">5.23.3. 向下转型</a></li><li><a href="#5234-%E5%90%84%E7%A7%8Dself%E5%8C%BA%E5%88%86%E4%BD%BF%E7%94%A8">5.23.4. 各种self区分使用</a></li><li><a href="#5235-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">5.23.5. 设计模式</a><ul><li><a href="#52351-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">5.23.5.1. 建造者模式</a></li><li><a href="#52352-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">5.23.5.2. 访问者模式</a></li><li><a href="#52353-raii%E6%A8%A1%E5%BC%8F">5.23.5.3. raii模式</a></li></ul></li></ul></li><li><a href="#524-%E5%AD%90%E8%BF%9B%E7%A8%8B">5.24. 子进程</a></li><li><a href="#525-%E5%8F%8D%E5%B0%84">5.25. 反射</a></li><li><a href="#526-%E5%AE%8F">5.26. 宏</a><ul><li><a href="#5261-%E5%AE%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">5.26.1. 宏基本介绍</a></li><li><a href="#5262-%E5%A3%B0%E6%98%8E%E5%AE%8F">5.26.2. 声明宏</a><ul><li><a href="#52621-%E5%88%9B%E5%BB%BA%E5%AE%8F">5.26.2.1. 创建宏</a></li><li><a href="#52622-%E9%87%8D%E5%A4%8D%E5%BE%AA%E7%8E%AF%E5%8C%B9%E9%85%8D">5.26.2.2. 重复循环匹配</a></li><li><a href="#52623-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B">5.26.2.3. 实际案例</a></li></ul></li><li><a href="#5263-%E5%AE%8F%E8%B0%83%E8%AF%95">5.26.3. 宏调试</a></li><li><a href="#5264-%E8%BF%87%E7%A8%8B%E5%AE%8F">5.26.4. 过程宏</a><ul><li><a href="#52641-%E8%BF%87%E7%A8%8B%E5%AE%8F%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99">5.26.4.1. 过程宏基本使用规则</a></li><li><a href="#52642-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%AE%8F">5.26.4.2. 自定义属性宏</a></li><li><a href="#52643-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%AE%8F">5.26.4.3. 函数调用宏</a></li><li><a href="#52644-derive-%E5%AE%8F">5.26.4.4. derive 宏</a></li></ul></li><li><a href="#5265-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85">5.26.5. 使用第三方包</a></li><li><a href="#5266-%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%92%E4%BB%B6">5.26.6. 编译器插件</a></li></ul></li></ul></li><li><a href="#6-unsafe-%E5%B1%8F%E8%94%BD%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5">6. unsafe 屏蔽内存安全检查</a><ul><li><a href="#61-unsafe-%E5%9F%BA%E6%9C%AC%E5%9C%BA%E6%99%AF">6.1. unsafe 基本场景</a></li><li><a href="#62-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91">6.2. 交叉编译</a></li><li><a href="#63-ffi-%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3">6.3. ffi 外部函数接口</a><ul><li><a href="#631-ffi-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">6.3.1. ffi 基本介绍</a></li><li><a href="#632-%E5%92%8C-elixir-%E4%BA%A4%E4%BA%92">6.3.2. 和 elixir 交互</a></li><li><a href="#633-%E5%92%8Cc-cpp-%E4%BA%A4%E4%BA%92">6.3.3. 和c cpp 交互</a><ul><li><a href="#6331-%E5%9C%A8-rust-%E4%B8%AD%E8%B0%83%E7%94%A8-c-%E5%87%BD%E6%95%B0">6.3.3.1. 在 rust 中调用 C 函数</a></li><li><a href="#6332-%E5%9C%A8-rust%E8%B0%83%E7%94%A8-cpp">6.3.3.2. 在 rust调用 cpp</a></li><li><a href="#6333-%E5%9C%A8-c-%E4%B8%AD%E8%B0%83%E7%94%A8-rust">6.3.3.3. 在 c 中调用 rust</a></li></ul></li><li><a href="#634-%E5%92%8C-python-%E4%BA%A4%E4%BA%92">6.3.4. 和 Python 交互</a></li><li><a href="#635-%E5%92%8C-swift">6.3.5. 和 Swift</a></li><li><a href="#636-%E5%92%8C-js-javascript-nodejs-%E4%BA%A4%E4%BA%92">6.3.6. 和 js JavaScript nodejs 交互</a></li><li><a href="#637-%E5%92%8C-java-%E4%BA%A4%E4%BA%92">6.3.7. 和 java 交互</a><ul><li><a href="#6371-java-%E8%B0%83%E7%94%A8-rust">6.3.7.1. java 调用 rust</a></li><li><a href="#6372-rust-%E8%B0%83%E7%94%A8-java">6.3.7.2. rust 调用 java</a></li></ul></li></ul></li></ul></li><li><a href="#7-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">7. 内存管理</a><ul><li><a href="#71-%E5%A0%86-%E5%92%8C-%E6%A0%88">7.1. 堆 和 栈</a></li><li><a href="#72-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">7.2. 内存对齐</a></li><li><a href="#73-%E6%89%8B%E5%8A%A8%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">7.3. 手动堆内存分配</a></li></ul></li><li><a href="#8-%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86-%E6%A8%A1%E5%9D%97">8. 工程管理 模块</a><ul><li><a href="#81-%E6%A6%82%E5%BF%B5%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A">8.1. 概念简单解释</a></li><li><a href="#82-%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AE%A1%E7%90%86">8.2. 可见性管理</a></li><li><a href="#83-%E7%BC%96%E8%AF%91%E5%99%A8%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86">8.3. 编译器版本管理</a></li><li><a href="#84-%E4%B8%BA%E9%A1%B9%E7%9B%AE%E5%8D%95%E7%8B%AC%E6%8C%87%E5%AE%9Aconfig-%E9%85%8D%E7%BD%AE">8.4. 为项目单独指定config 配置</a></li><li><a href="#85-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-cargo">8.5. 依赖管理 cargo</a><ul><li><a href="#851-cargo-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">8.5.1. cargo 基本命令</a></li><li><a href="#852-%E6%96%87%E4%BB%B6%E5%B8%83%E5%B1%80%E7%BB%93%E6%9E%84">8.5.2. 文件布局结构</a></li><li><a href="#853-cargotoml">8.5.3. Cargo.toml</a></li><li><a href="#854-cargolock">8.5.4. cargo.lock</a></li><li><a href="#855-workspace">8.5.5. workspace</a></li><li><a href="#856-%E4%BE%9D%E8%B5%96%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E5%88%99">8.5.6. 依赖的版本号规则</a></li></ul></li><li><a href="#86-buildrs">8.6. build.rs</a></li><li><a href="#87-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B">8.7. 项目管理案例</a><ul><li><a href="#871-%E5%AF%BC%E5%87%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8F">8.7.1. 导出自定义宏</a></li><li><a href="#872-%E5%AF%BC%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89-crate">8.7.2. 导入自定义 crate</a></li><li><a href="#873-%E6%89%A7%E8%A1%8C%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84-module">8.7.3. 执行子目录中的 module</a></li><li><a href="#874-%E5%AF%BC%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89-module">8.7.4. 导入自定义 module</a></li><li><a href="#875-%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9-crate">8.7.5. 导入第三方 crate</a></li></ul></li></ul></li><li><a href="#9-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">9. 单元测试</a></li><li><a href="#10-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91-and-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91">10. 交叉编译 and 条件编译</a></li><li><a href="#11-%E5%B9%B6%E5%8F%91">11. 并发</a><ul><li><a href="#111-%E9%80%9A%E7%94%A8%E6%A6%82%E5%BF%B5">11.1. 通用概念</a><ul><li><a href="#1111-%E8%BF%9B%E7%A8%8B-and-%E7%BA%BF%E7%A8%8B">11.1.1. 进程 and 线程</a></li><li><a href="#1112-%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91">11.1.2. 事件回调实现的异步并发</a></li></ul></li><li><a href="#112-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">11.2. 线程基本使用</a><ul><li><a href="#1121-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">11.2.1. 创建线程</a></li><li><a href="#1122-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B">11.2.2. 自定义配置线程</a></li><li><a href="#1123-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F">11.2.3. 线程本地变量</a></li><li><a href="#1124-%E6%89%8B%E5%8A%A8%E9%98%BB%E5%A1%9E%E5%94%A4%E9%86%92">11.2.4. 手动阻塞唤醒</a></li></ul></li><li><a href="#113-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">11.3. 线程同步</a><ul><li><a href="#1131-%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B">11.3.1. 错误示例</a></li><li><a href="#1132-%E9%94%81">11.3.2. 锁</a></li><li><a href="#1133-%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B">11.3.3. 原子类型</a></li><li><a href="#1134-channel">11.3.4. channel</a></li><li><a href="#1135-tokio-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D-channel-%E5%AE%9E%E7%8E%B0">11.3.5. tokio 中的各种 channel 实现</a></li></ul></li><li><a href="#114-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B0%8F%E4%BE%8B%E5%AD%90">11.4. 多线程小例子</a><ul><li><a href="#1141-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0">11.4.1. 实现线程池</a></li><li><a href="#1142-%E5%AE%9E%E7%8E%B0-map-reduce-%E7%AE%97%E6%B3%95">11.4.2. 实现 map-reduce 算法</a></li><li><a href="#1143-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%9F%E8%AE%A1%E5%92%8C">11.4.3. 多线程统计和</a></li><li><a href="#1144-%E5%B8%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84-webserver">11.4.4. 带线程池的 webserver</a></li></ul></li><li><a href="#115-rayon-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1">11.5. rayon 并行执行任务</a></li><li><a href="#116-crossbeam-%E6%97%A0%E9%94%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">11.6. CrossBeam 无锁的数据结构</a></li><li><a href="#117-rwlock-%E5%92%8C-refcell">11.7. RwLock 和 RefCell</a></li><li><a href="#118-mutex">11.8. Mutex</a></li><li><a href="#119-atomicptr-%E5%92%8C-cell">11.9. AtomicPtr 和 Cell</a></li><li><a href="#1110-send-%E5%92%8C-sync-trait">11.10. Send 和 Sync trait</a></li></ul></li><li><a href="#12-%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91">12. 异步并发</a><ul><li><a href="#121-%E5%BC%82%E6%AD%A5%E6%A6%82%E5%BF%B5">12.1. 异步概念</a><ul><li><a href="#1211-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5">12.1.1. 为什么使用异步</a></li><li><a href="#1212-%E6%99%AE%E9%80%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B-webserver">12.1.2. 普通多线程 webserver</a></li><li><a href="#1213-%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E5%BC%82%E6%AD%A5%E7%89%88%E6%9C%AC">12.1.3. 改进后的异步版本</a></li></ul></li><li><a href="#122-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">12.2. 基本使用</a><ul><li><a href="#1221-block_on">12.2.1. block_on</a></li><li><a href="#1222-await">12.2.2. await</a></li><li><a href="#1223-joinn">12.2.3. joinn</a></li></ul></li><li><a href="#123-future%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F">12.3. future并发模式</a><ul><li><a href="#1231-future%E5%BA%95%E5%B1%82%E6%98%AF%E7%94%9F%E6%88%90%E5%99%A8">12.3.1. future底层是生成器</a></li><li><a href="#1232-future%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E7%94%A8">12.3.2. future基本使用用</a></li><li><a href="#1233-%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0-future-%E7%B1%BB%E5%9E%8B">12.3.3. 动手实现 Future 类型</a></li><li><a href="#1234-%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0-%E5%BC%82%E6%AD%A5-sleep">12.3.4. 动手实现 异步 sleep</a></li></ul></li><li><a href="#124-async-std">12.4. async-std</a></li><li><a href="#125-tokio">12.5. tokio</a></li></ul></li><li><a href="#13-%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">13. 简单文件系统</a></li><li><a href="#14-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">14. 网络编程</a><ul><li><a href="#141-tcp">14.1. tcp</a></li><li><a href="#142-udp">14.2. udp</a></li></ul></li><li><a href="#15-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6">15. 消息中间件</a></li><li><a href="#16-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91">16. 游戏开发</a></li><li><a href="#17-%E7%88%AC%E8%99%AB">17. 爬虫</a></li><li><a href="#18-rpc-%E6%A1%86%E6%9E%B6">18. rpc 框架</a></li><li><a href="#19-%E7%BC%96%E5%86%99%E4%BB%A3%E7%90%86">19. 编写代理</a><ul><li><a href="#191-http-%E4%BB%A3%E7%90%86">19.1. http 代理</a></li><li><a href="#192-socket-%E4%BB%A3%E7%90%86">19.2. socket 代理</a></li></ul></li><li><a href="#20-%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-web-%E6%B8%B8%E6%88%8F">20. 开发微信小程序-web 游戏</a></li><li><a href="#21-%E7%AC%AC%E4%B8%89%E6%96%B9-crates">21. 第三方 crates</a><ul><li><a href="#211-%E4%BA%8B%E5%AE%9E%E4%B8%8A%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93">21.1. 事实上的标准库</a></li><li><a href="#212-markdown">21.2. markdown</a></li><li><a href="#213-%E6%A1%8C%E9%9D%A2%E5%BC%80%E5%8F%91">21.3. 桌面开发</a></li><li><a href="#214-%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86">21.4. 视频处理</a></li><li><a href="#215-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86">21.5. 图片处理</a></li><li><a href="#216-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%89%E6%96%B9%E5%BA%93">21.6. 游戏开发三方库</a></li><li><a href="#217-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF">21.7. 系统信息</a></li><li><a href="#218-web-%E5%BC%80%E5%8F%91%E5%8F%91">21.8. web 开发发</a><ul><li><a href="#2181-swagger-openapi-%E7%94%9F%E6%88%90">21.8.1. swagger openapi 生成</a></li><li><a href="#2182-web%E6%A1%86%E6%9E%B6">21.8.2. web框架</a></li><li><a href="#2183-orm">21.8.3. orm</a></li><li><a href="#2184-http-client">21.8.4. http client</a></li></ul></li><li><a href="#219-%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">21.9. 序列化反序列化</a><ul><li><a href="#2191-toml">21.9.1. toml</a></li><li><a href="#2192-json">21.9.2. json</a></li></ul></li><li><a href="#2110-%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE">21.10. 读写数据</a></li><li><a href="#2111-%E5%A2%9E%E5%BC%BA%E5%B7%A5%E5%85%B7">21.11. 增强工具</a></li><li><a href="#2112-%E6%8E%88%E6%9D%83-authorization">21.12. 授权 Authorization</a></li><li><a href="#2113-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F">21.13. 日志系统</a><ul><li><a href="#21131-tracing">21.13.1. tracing</a></li><li><a href="#21132-env_logger">21.13.2. env_logger</a></li><li><a href="#21133-log4rs-and-log">21.13.3. log4rs and log</a></li></ul></li><li><a href="#2114-%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90%E5%99%A8-parser">21.14. 文本解析器 parser</a></li><li><a href="#2115-lazy-static-%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96">21.15. lazy static 延迟初始化</a></li><li><a href="#2116-%E7%94%B5%E5%AD%90%E4%B9%A6">21.16. 电子书</a></li><li><a href="#2117-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F">21.17. 命令行程序</a><ul><li><a href="#21171-structopt">21.17.1. structopt</a></li><li><a href="#21172-clap">21.17.2. clap</a></li></ul></li><li><a href="#2118-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">21.18. 异步编程</a></li><li><a href="#2119-websocket">21.19. websocket</a></li><li><a href="#2120-%E7%BC%A9%E5%B0%8F%E4%BD%93%E7%A7%AF">21.20. 缩小体积</a></li><li><a href="#2121-http-client">21.21. http client</a></li><li><a href="#2122-%E5%AE%B9%E9%94%99%E8%BF%90%E8%A1%8C%E6%97%B6">21.22. 容错运行时</a></li><li><a href="#2123-%E7%9B%91%E6%8E%A7">21.23. 监控</a></li><li><a href="#2124-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">21.24. 电子邮件</a></li><li><a href="#2125-%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7">21.25. 分发工具</a></li><li><a href="#2126-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">21.26. 并发编程</a></li><li><a href="#2127-gui-%E5%9B%BE%E5%BD%A2%E5%BA%93">21.27. gui 图形库</a></li><li><a href="#2128-%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C-api">21.28. 底层网络 api</a></li><li><a href="#2129-%E6%AD%A3%E5%88%99">21.29. 正则</a></li><li><a href="#2130-%E9%9A%8F%E6%9C%BA">21.30. 随机</a><ul><li><a href="#21301-rand-%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97">21.30.1. rand 随机数字</a></li></ul></li><li><a href="#2131-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E">21.31. 搜索引擎</a></li><li><a href="#2132-%E5%BC%80%E6%BA%90%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8">21.32. 开源集合容器</a></li></ul></li><li><a href="#22-%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE">22. 开源项目</a></li><li><a href="#23-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">23. 参考链接</a></li></ul><h1>1. 简单介绍</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="11-感悟">1.1. 感悟<a href="#11-感悟" class="hash-link" aria-label="Direct link to 1.1. 感悟" title="Direct link to 1.1. 感悟">​</a></h2><ul><li>生态足够成熟, 无论是 cli app, lib 应用, web</li><li>让重构代码更轻松, 并发问题会被编译器提醒</li><li>rust 体现了软件开发的诸多最佳实践, , 让你成为更好的码农, 提升其他语言的能力</li><li>诞生的晚, 和其他语言的交互更方便, ffi 更容易使用....</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="12-架构">1.2. 架构<a href="#12-架构" class="hash-link" aria-label="Direct link to 1.2. 架构" title="Direct link to 1.2. 架构">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">好的架构需要有清晰的概念, 软件史上优雅的架构设计通常有优雅的概念:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - socket </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - stream /flow </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - pipe </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    比如说, 现在需要对输入的一段文本统计某个单词的个数, 那么首先需要进行切割, 这个动作可以抽象出一个概念, 叫做 分词(tokenize), 然后是对每个词做处理, 这个处理可能是线性的, 也可能是并行的, 这个概念叫做 map ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">好的架构有定义清晰的接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">好的架构要能够延迟决策</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 函数是代码块的延迟绑定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 类型是值的延迟绑定 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 泛型是类型的 延迟绑定 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 泛型函数是函数的延迟绑定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 配置是业务逻辑的 延迟绑定 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 用户代码是延迟绑定的最高表现形式, 比如 nginx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="13-优点-对比">1.3. 优点 对比<a href="#13-优点-对比" class="hash-link" aria-label="Direct link to 1.3. 优点 对比" title="Direct link to 1.3. 优点 对比">​</a></h2><ul><li><p>高性能: 零成本抽象</p></li><li><p>安全性: 所有权系统几乎解决了野指针, 强大的类型系统</p></li><li><p>表达力</p></li><li><p>生态工具完备: 自带测试, cargo 工具</p></li></ul><p><a href="https://opensource.com/article/20/5/rust-java" target="_blank" rel="noopener noreferrer">https://opensource.com/article/20/5/rust-java</a> 为什么java -&gt; rust</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="14-思想">1.4. 思想<a href="#14-思想" class="hash-link" aria-label="Direct link to 1.4. 思想" title="Direct link to 1.4. 思想">​</a></h2><ul><li><p>明确 : 有很多其他语言像 Python, java, 为了照顾初学者他会把很多基本的概念隐藏在语法的后面, 比如每一条语句的变量分配, 在堆还是在栈执行, 都被屏蔽了, 在做一些性能优化, 和其他语言进行交互就会暴露问题</p></li><li><p>零成本抽象(zero cost abstract): (编译期间即可编译成机器码, 运行时没有开销), 没有 runtime 和 gc, 和 c 无缝交互, 比如 future 就是一个很漂浪的抽象</p></li><li><p>全能: 从系统层到 web 层, 都可以使用 rust 开发</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="15-语义-概念">1.5. 语义 概念<a href="#15-语义-概念" class="hash-link" aria-label="Direct link to 1.5. 语义 概念" title="Direct link to 1.5. 语义 概念">​</a></h2><ol><li>范式: 面向对象 , 函数式</li><li>语义: 所有权, move, copy, 借用, lifecycle, drop</li><li>类型系统: 泛型, trait, 多态, 类型推断</li><li>内存管理: heap, stack, raii</li></ol><p>1, 2, 3 点涉及到开发者的操作, 2,3,4 编译器操作</p><h1>2. 开发环境配置</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-install">2.1. install<a href="#21-install" class="hash-link" aria-label="Direct link to 2.1. install" title="Direct link to 2.1. install">​</a></h2><p>git 环境支持</p><p><a href="https://www.rust-lang.org/tools/install" target="_blank" rel="noopener noreferrer">https://www.rust-lang.org/tools/install</a></p><p>会自动安装 cargo</p><p>安装完成后退出再次进入 terminal, rustc 等命令自动加入 path 了</p><p>给nightly通道用户的小提示：在更新rust之后使用cargo-sweep来帮助你清理垃圾
对于nightly通道的用户来说，通常在使用过程中会伴随着频繁的升级你的rust版本，而对于日常维护的项目，如果你升级了rust版本之后，target编译文件夹里面会生成多个版本的编译文件。这个时候就是使用cargo sweep的时候了，它会帮你清理掉除了当前版本以外的target目录下多余的文件。</p><p>用例： cargo sweep -i -r -v ~/src</p><p>-i 是开启保留~/src目录下target文件夹内当前电脑上已安装rust版本的编译文件。
-r 是开启递归（recursively）搜索
-v 是开启详细（啰嗦模式，开启之后会告诉你它干了啥。）
如果你的电脑上没有cargo sweep，可以用以下命令安装： cargo install cargo-sweep</p><p>Read More: <a href="https://www.reddit.com/r/rust/comments/jfdiao/tip_for_nightly_users_use_cargosweep_after/" target="_blank" rel="noopener noreferrer">https://www.reddit.com/r/rust/comments/jfdiao/tip_for_nightly_users_use_cargosweep_after/</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22-命令行工具使用">2.2. 命令行工具使用<a href="#22-命令行工具使用" class="hash-link" aria-label="Direct link to 2.2. 命令行工具使用" title="Direct link to 2.2. 命令行工具使用">​</a></h2><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">rustc --version</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 编译单个文件, 生成 xxx 可执行文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustc &lt;xxx.rs&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 编译 运行 dry.rs 下的 test mod, 无需 main函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustc --test dry.rs &amp;&amp; ./dry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 管理 rust 版本, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup update</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># rust 有 stable (默认)、nightly 版本之分</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup install nightly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 当前项目下生效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup override set nightly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup override set stable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 设置默认值, 对全局所有项目生效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup default stable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup default nightly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup default # show current version</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="23-ide">2.3. IDE<a href="#23-ide" class="hash-link" aria-label="Direct link to 2.3. IDE" title="Direct link to 2.3. IDE">​</a></h2><ol><li><p>vscode + rust-analyzer + CodeLLDB  (debug, format) + even better toml (toml support) + crates (view crate version) + advanced-new-file + error lens (show error msg in editor) + github copilot + idea keybindings</p></li><li><p>clion/idea + rust 插件 + toml 插件 + NativeDebug插件</p></li></ol><p>其他代码提示配置: (推荐 vscode + 插件, 就无需如下的配置了)</p><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># https://www.jianshu.com/p/c952db541d79</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 代码提示</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo install racer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 如果不成功, 升级到 nightly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup install nightly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 如果报错，则需要切换到nightly版本的编译器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 然后再次 安装 racer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup default nightly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 或者 直接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo +nightly install racer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 代码分析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup component add clippy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="24-配置国内镜像">2.4. 配置国内镜像<a href="#24-配置国内镜像" class="hash-link" aria-label="Direct link to 2.4. 配置国内镜像" title="Direct link to 2.4. 配置国内镜像">​</a></h2><p><a href="https://www.cnblogs.com/dhcn/p/12100675.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/dhcn/p/12100675.html</a></p><div class="language-t codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-t codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[registry]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">token = &quot;xxx crate.io token&quot; # 注册账号后由网站颁发, 用于发布包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 放到 `$HOME/.cargo/config` 文件中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[source.crates-io]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 替换成你偏好的镜像源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">replace-with = &#x27;rustcc&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#replace-with = &#x27;ustc&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 清华大学</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[source.tuna]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 中国科学技术大学</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[source.ustc]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 上海交通大学</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[source.sjtu]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># rustcc社区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[source.rustcc]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 命令别名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[alias]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b = &quot;build&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">t = &quot;test&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">r = &quot;run&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rr = &quot;run --release&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ben = &quot;bench&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">space_example = [&quot;run&quot;, &quot;--release&quot;, &quot;--&quot;, &quot;\&quot;command list\&quot;&quot;]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>3. 标准库</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="31-path-路径">3.1. path 路径<a href="#31-path-路径" class="hash-link" aria-label="Direct link to 3.1. path 路径" title="Direct link to 3.1. path 路径">​</a></h2><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// Path 可从 OsStr 类型创建</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// Path 分为两种：posix::Path，针对 类 UNIX 系统；以及 windows::Path，针对 Windows。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// prelude 会选择并输出符合平台类型 的 Path 种类。(prelude 是 Rust 自动地在每个程序中导入的一些通用的东西)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// Path 在内部并不是用 UTF-8 字符串表示的，而是存储为若干字节（Vec&lt;u8&gt;）的 vector。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 因此，将 Path 转化成 &amp;str 并非零开销的（free），且可能失败（因此它 返回一个 Option）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn path_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;-------------path_demo-------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::path::Path;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let path = Path::new(&quot;.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 路径是否存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Path::new(&quot;/etc/hosts&quot;).exists()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 或者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fs::metadata(path).is_ok()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `display` 方法返回一个可显示（showable）的结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let display = path.display();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;path = {}&quot;, display);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `join` 使用操作系统特定的分隔符来合并路径到一个字节容器，并返回新的路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将路径转换成一个字符串切片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match new_path.to_str() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="32-时间">3.2. 时间<a href="#32-时间" class="hash-link" aria-label="Direct link to 3.2. 时间" title="Direct link to 3.2. 时间">​</a></h2><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn time_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let start = SystemTime::now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _ in 0..10000000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let _a = &quot;hello&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{} ms&quot;, SystemTime::now().duration_since(start).unwrap().as_millis());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>4. 对比 2018</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="41-nll">4.1. nll<a href="#41-nll" class="hash-link" aria-label="Direct link to 4.1. nll" title="Direct link to 4.1. nll">​</a></h2><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// nll 特性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2015 edition 的周期检查会认为 变量有效直到作用域结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2018 edition 会分析代码, 确认变量后面不会用到, 则提前销毁变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut x = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y = &amp;mut x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *y += 1; // 2018 edition 在这一步后, 销毁 y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, x); // 2015 到这一步才销毁 y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 非词法作用域生命周期 (Non-Lexical Lifetime, NLL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn foo&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if x.len() % 2 == 0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //2015 中 error, 2018 引入了 nll, 不报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y = String::from(&quot;world&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    z = foo(&amp;x, &amp;y); // 2015 认为到这里 y 已经失效了, 所以报错, 实际这不符合直觉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, z);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// nll 无法解决的问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn get_default&lt;&#x27;r,K:Hash+Eq+Copy,V:Default&gt;(map: &amp;&#x27;r mut HashMap&lt;K,V&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            key: K)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            -&gt; &amp;&#x27;r mut V {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match map.get_mut(&amp;key) { // -------------+ &#x27;r</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(value) =&gt; value,              // |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        None =&gt; {                          // |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            map.insert(key, V::default()); // |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //  ^~~~~~ ERROR               // |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            map.get_mut(&amp;key).unwrap()     // |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }                                  // |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }                                      // |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 修正如下:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn get_default2&lt;&#x27;r,K:Hash+Eq+Copy,V:Default&gt;(map: &amp;&#x27;r mut HashMap&lt;K,V&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             key: K)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             -&gt; &amp;&#x27;r mut V {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if map.contains_key(&amp;key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ^~~~~~~~~~~~~~~~~~ &#x27;n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return match map.get_mut(&amp;key) { // + &#x27;r</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Some(value) =&gt; value,        // |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            None =&gt; unreachable!()       // |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };                               // v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // At this point, `map.get_mut` was never</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // called! (As opposed to having been called,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // but its result no longer being in use.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map.insert(key, V::default()); // OK now.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map.get_mut(&amp;key).unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="42-raw-identifier">4.2. Raw identifier<a href="#42-raw-identifier" class="hash-link" aria-label="Direct link to 4.2. Raw identifier" title="Direct link to 4.2. Raw identifier">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 利用 Raw identifier 将语言关键字用作函数名 (一般用于 FFI 中，用于避免 C 函数名和 Rust 的关键字或保留字重名)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn r#match(needle : &amp;str , haystack : &amp;str) - &gt; bool</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="43-简化模式匹配">4.3. 简化模式匹配<a href="#43-简化模式匹配" class="hash-link" aria-label="Direct link to 4.3. 简化模式匹配" title="Direct link to 4.3. 简化模式匹配">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// match 模式匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let o = &amp;Some(&quot;h&quot;.to_owned());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2015</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  ref也是一种模式匹配，是为了 解构 &amp;Some(ref s)中 s 的引用，避免其中的 s 被转移所有权 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match o {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;Some(ref v) =&gt; println!(&quot;{}&quot;, v),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; (),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2018</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //不 需要再使用引用操作符和 ref来进行解构了。在新的版本中 ， match 匹配会自动处理这种情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match o {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(v) =&gt; println!(&quot;{}&quot;, v),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; (),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="44-main-函数可以返回-result">4.4. main 函数可以返回 Result<a href="#44-main-函数可以返回-result" class="hash-link" aria-label="Direct link to 4.4. main 函数可以返回 Result" title="Direct link to 4.4. main 函数可以返回 Result">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在 Rust 2015版本中， main 函数并不能返回 Result&lt;T E&gt;。但是在实际开发中， 二进制 可执行库也需要返回错误， 比如， 读取文件的时候发生了错误， 这时需要正常退出程序。于 是在 Rust 2018 版本中，允许 main 函数返回 Result&lt;T, E&gt;了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="45-impl-trait-抽象类型">4.5. impl trait 抽象类型<a href="#45-impl-trait-抽象类型" class="hash-link" aria-label="Direct link to 4.5. impl trait 抽象类型" title="Direct link to 4.5. impl trait 抽象类型">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 可 以静态分发的抽象类型 impl Trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>5. 语法</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="51-注释">5.1. 注释<a href="#51-注释" class="hash-link" aria-label="Direct link to 5.1. 注释" title="Direct link to 5.1. 注释">​</a></h2><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//! Hello Demo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//!   包注释</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//! crate spec...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io::Read;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::fmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io::{stdout, BufWriter}; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::fs::File;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// main 方法的注释</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// ```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 支持 md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// ```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Hello, world!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="52-变量赋值">5.2. 变量赋值<a href="#52-变量赋值" class="hash-link" aria-label="Direct link to 5.2. 变量赋值" title="Direct link to 5.2. 变量赋值">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="521-默认是不可变的">5.2.1. 默认是不可变的<a href="#521-默认是不可变的" class="hash-link" aria-label="Direct link to 5.2.1. 默认是不可变的" title="Direct link to 5.2.1. 默认是不可变的">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn variables() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = 12;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 二次赋值不行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 也就是说 a 是不可变变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // a = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 但是能二次绑定, 重影/遮蔽（Shadowing）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里的 a 和之前的 a 没关系, 甚至类型都能改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = 11;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;a = {}&quot;, a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = &quot;new a&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;a = {}&quot;, a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可变变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 能够被二次赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut b = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b = 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;b = {}&quot;, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这是不行的, 因为 b 已经被使用过了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // b = &quot;bb&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 手动指定类型, 无符号 64 位整型变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果没有声明类型，i 将自动被判断为有符号 32 位整型变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let i: u64 = 12;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="522-字面量">5.2.2. 字面量<a href="#522-字面量" class="hash-link" aria-label="Direct link to 5.2.2. 字面量" title="Direct link to 5.2.2. 字面量">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 字面量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 带后缀的字面量，其类型在初始化时已经知道了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 1u8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y = 2u32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let z = 3f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = &quot;hello&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="53-基本数据类型">5.3. 基本数据类型<a href="#53-基本数据类型" class="hash-link" aria-label="Direct link to 5.3. 基本数据类型" title="Direct link to 5.3. 基本数据类型">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="531-convert">5.3.1. convert<a href="#531-convert" class="hash-link" aria-label="Direct link to 5.3.1. convert" title="Direct link to 5.3.1. convert">​</a></h3><p><a href="https://stackoverflow.com/questions/41034635/how-do-i-convert-between-string-str-vecu8-and-u8" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/41034635/how-do-i-convert-between-string-str-vecu8-and-u8</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="532-值类型-and-引用类型">5.3.2. 值类型 and 引用类型<a href="#532-值类型-and-引用类型" class="hash-link" aria-label="Direct link to 5.3.2. 值类型 and 引用类型" title="Direct link to 5.3.2. 值类型 and 引用类型">​</a></h3><p>值类型是指数据直接存储在栈中的数据类型 ，一些原生类型，比如数值 、布尔值、结构体, 枚举等都是值类型。因此对值类型的操作效率一般比较高，使用完立即会被回收, 这些基本类型实现了 Copy trait, 赋值语句中会执行拷贝</p><p>引用类型将数据存储在堆中，而栈中只存放指向堆中数据的地址, 如数组, 字符串; 因此对引用类型的操作效率一般比较低</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="533-常量-静态变量">5.3.3. 常量 静态变量<a href="#533-常量-静态变量" class="hash-link" aria-label="Direct link to 5.3.3. 常量 静态变量" title="Direct link to 5.3.3. 常量 静态变量">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 常量, 静态变量: 在全局声明常量 or 变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 需要手动指定类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 区别/异同:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 都是在编译期求值的，所以不能用于存储需要动态分配内存的类型，比如 HashMap, vec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 静态变量有固定的内存地址 (分配在静态存储区), 可以是可变的 (用 mut 修饰), 可能有内存安全问题, 所以修改需要在 unsafe 中; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 常量没有固定的内存地址, 不可变 (会被内联, 在被用到的地方会被复制过去, 用不到内存地址)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 普通常量 不能引用 静态变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用场景:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在存储的数据比较大、需要引用地址或具有可变性的情况下使用静态变量;否则，应该 优先使用普通常量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const MAX_POINTS: u32 = 100_000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static LANGUAGE: &amp;&#x27;static str = &quot;Rust&quot;;//&quot;string&quot; 字面量默认生命周期就是 static 的</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="534-数字">5.3.4. 数字<a href="#534-数字" class="hash-link" aria-label="Direct link to 5.3.4. 数字" title="Direct link to 5.3.4. 数字">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// 对于 基本数据类型, 数据的克隆, 移动都是在栈上, 无需存储到堆中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn basic_types() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 整型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 占据 8 bit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const A: i8 = -2; // 有符号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const B: u8 = 2; // 无符号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     // const b: u8 = -2; // 错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 占据 16 bit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // i16 u16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 占据 32 bit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // i32 u32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 64 bit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // i64 u64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 128</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // i128 u128</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // arch 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // isize    usize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //长度取决于所运行的目标平台，如果是 32 位架构的处理器将使用 32 位位长度整型。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const C: i16 = 10_000; // 10进制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const D: i16 = 0xff; // 16进制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const E: i16 = 0o77; // 8 进制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const F: i16 = 0b1111_0000; // 二进制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 浮点数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 2.0; // 默认 f64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y: f32 = 3.0; // f32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 相关函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i32::min_value();-----2147483648</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_value()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// https://cloud.tencent.com/developer/article/1518453</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="535-布尔值-字符-字节">5.3.5. 布尔值 字符 字节<a href="#535-布尔值-字符-字节" class="hash-link" aria-label="Direct link to 5.3.5. 布尔值 字符 字节" title="Direct link to 5.3.5. 布尔值 字符 字节">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 布尔值, 类型 bool</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let is_a = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 字符, 单引号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //4 个字节, 支持中文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const CC: char = &#x27;c&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let heart_eyed_cat = &#x27;😻&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 字节字面量, 如 b&#x27;*&#x27; 表示 42u8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const G: u8 = b&#x27;A&#x27;; // 字节, 只能 u8 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const n: u8 = b&#x27;\n&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="536-数组">5.3.6. 数组<a href="#536-数组" class="hash-link" aria-label="Direct link to 5.3.6. 数组" title="Direct link to 5.3.6. 数组">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于原始固定长度数组，只有实现 Copy trait 的类型才能作为其元素 ，也就是说，只有 可以在栈上存放的元素才可以存放在该类型的数组中 (只有确定大小类型(sized type)的实例才可以放到栈上，也就是，可以通过传值的方式传递)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 不确定大小类型(unsized tpe)的实例不能放到栈上而且必须通过传引用的方式传递</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可以自动推断类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = [1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // a 是一个长度为 5 的整型数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // b 是一个长度为 3 的字符串数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 明确指定类型, 数组类型可以通过 [T, N] 明确指定, T 为元素类型, N 为 个数; 如 [u8; 4] 这是静态类型 (因为已知大小了)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // [u8] 只能是动态大小类型, for don&#x27;t know the size </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c: [i32; 5] = [1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // c 是一个长度为 5 的 i32 数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let d = [3; 5];// 使用默认类型 i32, 元素都为 3, 个数为 5 个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 等同于 let d = [3, 3, 3, 3, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let d = [3u8; 5];// 指定类型为 u8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 数组访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let first = a[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let second = a[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a[0] = 123; // 错误：数组 a 不可变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut a = [1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a[0] = 4; // 正确</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 数组遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for ele in a.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, ele);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 连接两个 array 可以使用 join</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // match 语法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过匹配数组的不同元 可以实现指定的功能 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 挑选出以 3 结尾和第 二个元素为 2 的数组。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn pick(arr: [i32; 3])  {// 这个有限制, 参数数组的元素个数不可变, 必须为 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match arr {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            [_, _, 3] =&gt; println!(&quot;ends with 3&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            [a, 2, c] =&gt; println!(&quot;{:?}, 2, {:?}&quot;, a,  c),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  match匹配的最后一个分支，必须使用通配符或其他变量来穷尽枚举</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            [_, _, _] =&gt; println!(&quot;pass!&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 变长参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 利用数组切 片就可以模拟变长参数的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn sum(num: &amp;[i32]) { // 原素个数可变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match num {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            [one] =&gt; println!(&quot; at least two&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            [first, second] =&gt; println!(&quot;{:?} + {:?} = {:?} &quot;, first, second, first+second),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; println!(&quot;sum is {:?}&quot;, num.iter().fold(0, |sum, i| sum + i) ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sum(&amp;[1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sum(&amp;[1, 2]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sum(&amp;[1, 2, 3]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sum(&amp;[1, 2, 3, 5]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 二分查找</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据元素查找索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if let Ok(9) = arr.binary_search(&amp;13) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 等价</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    arr.binary_search_by(|x| x.cmp(&amp;13))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // binary search by_key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(s.binary_search(&amp;13),  Ok(9));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(s.binary_search(&amp;4),   Err(7));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r = s.binary_search(&amp;1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(match r { Ok(1...4) =&gt; true, _ =&gt; false, });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let seek = 13;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.binary_search_by(|probe| probe.cmp(&amp;seek)),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       Ok(9)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              (1, 21), (2, 34), (4, 55)];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   assert_eq!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       s.binary_search_by_key(&amp;13, |&amp;(a,b)| b),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       Ok(9)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="537-range-范围">5.3.7. Range 范围<a href="#537-range-范围" class="hash-link" aria-label="Direct link to 5.3.7. Range 范围" title="Direct link to 5.3.7. Range 范围">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// /包头不包尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(1..5) &lt;=&gt; std::ops::Range {start: 1, end: 5}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(1..=5) &lt;=&gt; std::ops::RangeInclusive::new(1, 5)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(3..6).sum()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in 0..4 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in 0..=4) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="538-切片">5.3.8. 切片<a href="#538-切片" class="hash-link" aria-label="Direct link to 5.3.8. 切片" title="Direct link to 5.3.8. 切片">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///切片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 切片是对原始数据集合的部分引用, 没有原始 数据集合 的所有权 (原始数据集合可能是 数组, Vec);无法修改原始值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 若原始值 为 T, 则 切片类型为  &amp;[T] or &amp;mut[T]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// ..y 等价于 0..y (包头不包尾巴)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// x.. 等价于位置 x 到数据结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// .. 等价于位置 0 到结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn slice_vec() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 字符串切片   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from(&quot;broadcast&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let part1 = &amp;s[0..5];// 截取子串, 字符串切片就是 &amp;str 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let part2 = &amp;s[5..9];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}={}+{}&quot;, s, part1, part2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 被切片引用的字符串禁止更改原始值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;xxxxxx&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let slice = &amp;s[0..3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.push_str(&quot;yes!&quot;); // 错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //数组切片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr = [1, 3, 5, 7, 9];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let part = &amp;arr[0..3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in part.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, i);//1, 3, 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 两个 const fn 方法: len(), is_empty()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过 &amp;mut 定义可变切片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr = &amp;mut [1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    arr[1] = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 动态数组转切片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr = &amp;vec![1,2,3][..];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="539-str-字符串切片">5.3.9. str 字符串切片<a href="#539-str-字符串切片" class="hash-link" aria-label="Direct link to 5.3.9. str 字符串切片" title="Direct link to 5.3.9. str 字符串切片">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// str 是典型的动态大小类型 (DST), 编译期不可知大小, 分配在堆上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//所以编译器要求必须以不可变借用的形式在代码中存在 即 &amp;str, 这个借用的大小是确定的(一个指针+长度), &amp;str 存储在栈上, 对应的 str 存在 堆上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 字符串字面量是特殊的 str, 特殊在其具有静态生命周期, 必须以类型  &amp;&#x27;static  str 接收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//fat pointer(胖指针): 包含 DST 的地址信息 和 长度的指针, &amp;str 即胖指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let ss = &quot;hello world&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let ptr = ss.as_ptr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let s = unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let slice = std::slice::from_raw_parts(ptr, ss.len());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::str::from_utf8(slice).unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // turns invalid UTF-8 bytes into � and so no error handling is required.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let buf = &amp;[0x41u8, 0x41u8, 0x42u8];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from_utf8_lossy(buf).to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if ss == s {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;equal&quot;);//equal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5310-原生指针-raw-pointer">5.3.10. 原生指针 raw pointer<a href="#5310-原生指针-raw-pointer" class="hash-link" aria-label="Direct link to 5.3.10. 原生指针 raw pointer" title="Direct link to 5.3.10. 原生指针 raw pointer">​</a></h3><p>分为 不可变 raw pointer 和 可变 raw pointer</p><p>指针不同于 引用, 指针类型 *T, 引用类型 &amp;T</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#![feature(never_type)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut a = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let a_ptr = &amp;mut a as *mut i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = Box::new(20);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b_ptr = &amp;*b as *const i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsafe { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *a_ptr += *b_ptr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{:?}&quot;, a);//30</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5311-never-类型-感叹号">5.3.11. never 类型 感叹号<a href="#5311-never-类型-感叹号" class="hash-link" aria-label="Direct link to 5.3.11. never 类型 感叹号" title="Direct link to 5.3.11. never 类型 感叹号">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 底类型 bottom type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// BangType</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Rust 中有很多种情况确 实没有值，但为了类型安全，必须把这些情况纳入类型系统进行统一 处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 发散函数 (Diverging Function ): 永远不会有返回值的函数, 如 panic! 或者 std::process: :exit ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// continue 和 break 关键字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//loop循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 空枚举，比如 enumVoid{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ! [feature (never_type)]// 需要支持</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn foo() -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // !表示永远不会有返回值的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x: ! = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 11;// 直接foo函数返回退出了, 所以 x 永远不会有返回值, 是 ! 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // panic 宏在 match 分支中使用时, 即使没有返回和其他分支相同的类型, 也没报错, 为什么?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因为返回 了 ! 类型, (never 类型可以转为任何类型)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 空枚举的用法场景:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum Void {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let res: Result&lt;i32, Void&gt; = Ok(11);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let Ok(num) = res;//当然这里也可以用 if let 语句处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="54-字符串">5.4. 字符串<a href="#54-字符串" class="hash-link" aria-label="Direct link to 5.4. 字符串" title="Direct link to 5.4. 字符串">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="541-几种字符串区别">5.4.1. 几种字符串区别<a href="#541-几种字符串区别" class="hash-link" aria-label="Direct link to 5.4.1. 几种字符串区别" title="Direct link to 5.4.1. 几种字符串区别">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - str 表示固定长度的字符串, 属 于动态大 小 类型 (DST)，保证 有效 UTF-8 , 在编译期并不能确定其大小，所以在程序中最常见到的是 str 的切片 (Slice)类型 &amp;str。  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      &amp;str 表示字符串字面量, 是引用类型; 字符串切片就是 &amp;str, 和程序代码段存储在一起(在编译期间地址就知道了), 执行的是复制语义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - String 类型, 长度可变, 可修改, 存储为由字节组成的 vector（Vec&lt;u8&gt;），但保证了它一定是一个有效的 UTF-8 序列, 字符序列分配在堆, 执行的是移动语义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     String 有一个字符开始位置属性 ptr, 和一个字符串长度属性 len, 和堆分配的容量 capacity, 这些属性位于 栈, 实际字符序列存在 堆</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     str    有  ptr 和 len, 属性, 内容都在 栈</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - CStr， 表示由C分配而被Rust借用的字符串， 一般用于和C语言交互。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - CString， 表示由 Rust 分配且可以传递给 C 函数使用的 C 字符串 ，同样用 于和 C 语言交互。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - OsStr， 表示和操作系统相关的字符串。这是为了兼容 Windows系统。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - OsString，表示 OsStr 的可变版本 。与 Rust 字符串可以相互转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Path，表示路径，定义于 std::path模块中。 Path包装了 OsS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - PathBuf. ft~ Path 配对， 是 Path 的可变版本 。 PathBuf包装了 OsString。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="542-常用方法">5.4.2. 常用方法<a href="#542-常用方法" class="hash-link" aria-label="Direct link to 5.4.2. 常用方法" title="Direct link to 5.4.2. 常用方法">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn str_string() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 字符串转义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 长字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let long_string = &quot;String literals</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        can span multiple lines.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        The linebreak and \&#x27; indentation here </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        can be escaped too!&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, long_string);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b&#x27; &#x27;  表示 空格字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let str_value: &amp;&#x27;static str = &quot;1234&quot;;// 字符串切片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //简单写法为</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let str_value = &quot;1234&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = string::new() // 此时还并未在堆上分配空间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let str1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 指定堆容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s =  String : :with_capacity (20)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 再次分配容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.reserve(lO)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let one = 1.to_string();         // 整数到字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let float = 1.3.to_string();     // 浮点数到字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let slice = &quot;slice&quot;.to_string(); // 字符串切片到字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 新增 添加</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //定义一个可变字符串，并对其进行修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut string_value: String = &quot;1111&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 或者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let string_value = String::from(&quot;222&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    string_value.push_str(&quot;333&quot;);// 添加字符串切片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    string_value.push(&#x27;!&#x27;); // 添加字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 插入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.insert(0, &#x27;f’)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s. insert_str(O,”bar”)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // String 类型的字符串也实现了 Add&lt;&amp;str&gt; 和 AddAssign&lt;&amp;str&gt;两个 trait，这意味着可以使用“+”和“+=”操作符来连接字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 操作符 右边的字符串必须为切片类型 (&amp;str)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 替换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    string.replace(&quot;old_str&quot;, &quot;new str&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s .remove (3) //指定位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.pop()//最后一个字符, 并且返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s. truncate (3)//指定位置到末尾删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s .clear( );//清空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s .drain (..beta_offset) .collect()// 截取源的指定范围并返回, 源会改变, 只留下剩下的部分</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.drain(..)// 等价 clear, 截取源的全部, 源变空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // trim 首尾去除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let chars_to_trim: &amp;[char] = &amp;[&#x27; &#x27;, &#x27;,&#x27;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 去除 string 首尾的字符, 这些字符在 chars_to_trim 中指定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 查找</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 标准库中并没有提供正则表达式支持，这是因为正则表达式算是外部DSL， 如果 直接将其引入标准库中，则会破坏 Rust的一致性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 第三方包 regex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Rust 中这里使用 的字符匹配算 法并非 KMP，而是它的变种双向( Two-Way)字符串匹配算法 ，该算法的优势在于拥有常量级的空间复杂度。它和 KMP 的共同点在于其时间复杂度也是 O(n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 存在性判断。 相关方法包括contains (支持 字符/字符串/谓词)、 starts_with (支持字符/字符串)、 ends_with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 位置匹配 。相关方法包括 find、 rfind (从右边开始搜索, 支持谓词)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 分割字符串 。相关方法包括 split、rsplit、split_terminator(去掉数组last元素的多余)、rsplit_terminator、splitn (指定分割后的数组长度)、rsplitn。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 捕获匹配, 返回数组。 相关方法包括 matchs、 rmatches、 match_indices (返回的是元组数组, 包含了索引)、 rmatch_indices。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 删除匹配。 相关方法包括 trim(删除两头空格, 不能指定 pattern 参数), trim_left, trim_right , trim_matches(可指定 pattern 参数)、trim_left_matches、trim_right_matches。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 替代匹配。 相关方法包括 replace、 replacen(指定替换字符的个数)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 统计长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 字符 字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = &quot;hello&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let len = s.len();// 5, 字节数, 每个英文字符占位1字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = &quot;你好&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let len = s.len();//6, 因为中文是 UTF-8 编码的，每个字符长 3 字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = &quot;hello你好&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let len = s.bytes().count();//提供了 bytes 和 chars 两个方法来分别返回按字节 和按字符迭代的法代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let len = s.chars().count();// 7, 统计字符数 (统计字符的速度比统计数据长度的速度慢得多)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //遍历字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for c in s.chars() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{} &quot;, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s: String = s.chars() .enumerate() .map(| (i, c) | {}).collect()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 按索引访问字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut result = s.into_bytes();//通过 into_bytes方法将字符串转换为 Vec&lt;u8&gt;序列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (0..bs.len()).for_each(|i| println!(&quot;index = {:?}, value = {:?}&quot;, i, char::from(bs[i])));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let new_s = String: :from_utf8(result).unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取单个字符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from(&quot;EN中文&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = s.chars().nth(2); //nth 函数是从迭代器中取出某值的方法，不要在遍历中这样使用！因为 UTF-8 每个字符的长度不一定相等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, a);//Some(&#x27;中&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 指定索引范围来获取字符串切片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v =  String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s: Some&lt;&amp;str&gt; = v.get(0..1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.get_mut((xxx))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert ! (!v .is_char boundary(4)) ;//验证某个索引位置是否为合法的边界, 因为可能某个字符占据了多个索引位置(string的方法默认都是按照字节来处理的, 也就是一个索引位置对应一个字节, 某些字符英文字符外的字符可能不止一个字节)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 分割</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let bool_s = s.is_char_boundary(12)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.split_at(12)// 需要先检查索引是否是合法字符边界</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 空格分割, 逆序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pangram: &amp;&#x27;static str = &quot;the quick brown fox jumps over the lazy dog&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for word in pangram.split_whitespace().rev() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;&gt; {}&quot;, word);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 字符串分割成字符，排序并移除重复值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    chars.sort();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    chars.dedup(); //去重</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取字节 遍历字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // as_bytes()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn first_word(s: &amp;String) -&gt; usize {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 字节数组, 一个英文字符占一个字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let bytes = s.as_bytes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (i, &amp;item) in bytes.iter().enumerate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if item == b&#x27; &#x27; {// 如果是空格</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.len()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    first_word(&amp;&quot;hello world&quot;.to_owned());// 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="543-字符串转换">5.4.3. 字符串转换<a href="#543-字符串转换" class="hash-link" aria-label="Direct link to 5.4.3. 字符串转换" title="Direct link to 5.4.3. 字符串转换">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 复杂类型的类型转换 相互转换 互转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // String =&gt; &amp;str</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 方法1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = &amp;s1[..]; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ssss = &amp;s1[..2];// 截取子串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 方法2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sss: &amp;str = &amp;s1.as_str();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 方法3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // *s1 是 str 类型, &amp;*s1 即为 &amp;str 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let new_str = &amp;*s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // &amp;str -&gt; String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let new_string = new_str.to_string();//to_string底层调用的String::from</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let new_string1 = s2.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;new_string = {}, new_string1 = {}&quot;, new_string, new_string1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // &amp;str -&gt; String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let string = &quot;hello&quot;.to_owned(); //最常用, 吧 &quot;hello&quot;从栈转移到堆, to_owned 方法利用 &amp;str 切片字节序列生成新的 String字符串 ， to_string方法是对 String::from 的包装, 两者性能相当</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // &amp;str -&gt; String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _s: String = &quot;hello&quot;.into();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // string -&gt; T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // std::str模块中提供的 parse泛型方法来将字符串转换为指定的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 底层是 FromStr::from_str</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //T -&gt; string</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // format!()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = format!(&quot;{}&quot;, xxx); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 和数字互相转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let int_value = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let string_value = int_value.to_string();//int to String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let back_int = string_value.parse::&lt;i32&gt;().unwrap();//String to int</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="544-格式化">5.4.4. 格式化<a href="#544-格式化" class="hash-link" aria-label="Direct link to 5.4.4. 格式化" title="Direct link to 5.4.4. 格式化">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 拼接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 新加的字符串必须是  &amp;str</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let str1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let str2 = String::from(&quot;world&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let str3 = str1 + &quot;-&quot; + &amp;str2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = format!(&quot;{} - {}&quot;, str3, str2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 格式化输出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 由一些宏(macro)负责输出，这些宏定义在std::fmt中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 原理是: 必须实现 std::fmt::Display 这个trait提供的 fmt 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // format!()：向字符串中输出格式化字符串。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // print()!：向标准输出打印字符串。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // println()!：向标准输出打印字符串，同时会打印一个换行符。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // eprint()!：向标准错误打印字符串。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // eprintln()!：向标准错误打印字符串，同时也会打印一个换行符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 占位符 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {} -&gt; Display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {:?} -&gt; Debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {:#?} -&gt; 格式化的 Debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {:o} -&gt; 八进制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {:x} -&gt; 十六进制小写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {:X}   十六进制大写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {:p}   指针地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {:b}   二进制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {:e}   数字格式, 指数小写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // {:E}   指数大写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;hello {}&quot;, &quot;world&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{0} {1}&quot;, &quot;hello&quot;, &quot;world&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{h} {w}&quot;, h = &quot;hello&quot;, w = &quot;world&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 以二进制的格式打印数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;{} of {:b} people know binary, the other half doesn&#x27;t&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1, 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 右对齐宽度为6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{number:&gt;width$}&quot;, number = 1, width = 6);// &#x27;.....1&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用字符0填充对齐的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{number:&gt;0width$}&quot;, number = 1, width = 6);// &#x27;000001&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = format!(&quot;hello {}&quot;, &quot;world&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 十六进制输出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    format!(&quot;0x{:X}&quot;, 100); //-&gt; &quot;0xDEADBEEF&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 八进制输出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    format!(&quot;0o{:o}&quot;, 100); //-&gt; &quot;0o33653337357&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="545-调试打印复合类型-debug-display">5.4.5. 调试打印复合类型 Debug Display<a href="#545-调试打印复合类型-debug-display" class="hash-link" aria-label="Direct link to 5.4.5. 调试打印复合类型 Debug Display" title="Direct link to 5.4.5. 调试打印复合类型 Debug Display">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    //调试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fmt::Debug 类似 Display 这个 trait, 但是能够由 rust 自动推导实现, 无需手动实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fmt::Debug是Rust标准库已经定义好的，我们可以通过继承的方式，获得fmt::Debug的能力, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //即定义 struct 时 添加 #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //其他的还有 #[allow(dead_code)] 用于屏蔽对未使用代码的警告</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct DebugDemo(i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let debug_demo = DebugDemo(11);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Debug - {:?}&quot;, debug_demo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{0:?}&quot;, debug_demo);// 等效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fmt::Display 自定义打印</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //是一个用于自定义格式化输出的接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对于泛型容器, 如 Vec&lt;T&gt;, 需要自己实现fmt::Display, 或者直接 用fmt::Debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct DisplayDemo(i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl fmt::Display for DisplayDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            write!(f, &quot;({})&quot;, self.0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let display_demo = DisplayDemo(11);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;display - {}&quot;, display_demo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="546-问号操作符-多次写">5.4.6. 问号操作符 多次写<a href="#546-问号操作符-多次写" class="hash-link" aria-label="Direct link to 5.4.6. 问号操作符 多次写" title="Direct link to 5.4.6. 问号操作符 多次写">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // &quot;?&quot; 问号操作符: 尝试解包, 返回值为 解包后的值, 有异常, 返回异常, 没有则继续后续代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //考虑这种场景: 对一个结构体想实现 fmt::Display，但是其中的元素需要一个接一个地写出去，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //问题在于每个 write! 都要生成一个 fmt::Result。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //解决: write!(f, &quot;{}&quot;, value)?;  多次写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对 `write!` 进行尝试（try），观察是否出错。若发生错误，返回相应的错误。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 否则（没有出错）继续执行后面的语句。 同 try!(xxx)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用元组的下标获取值，并创建一个 `vec` 的引用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let vec = &amp;self.0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        write!(f, &quot;[&quot;)?;//多次写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         // 遍历下标</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (count, v) in vec.iter().enumerate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 对每个元素（第一个元素除外）加上逗号。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用 `?` 或 `try!` 来返回错误。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if count != 0 { write!(f, &quot;, &quot;)?; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            write!(f, &quot;{}&quot;, v)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 加上配对中括号，并返回一个 fmt::Result 值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        write!(f, &quot;]&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="55-集合">5.5. 集合<a href="#55-集合" class="hash-link" aria-label="Direct link to 5.5. 集合" title="Direct link to 5.5. 集合">​</a></h2><p>std::collections 下有四种集合</p><ul><li>线性序列: Vec(向量), VecDeque (双端队列), LinkedList (链表)</li><li>映射表: hashmap(无序哈希表), BTreeMap(有序哈希表)</li><li>集合: hashset(无序集合), btreeset(有序集合)</li><li>优先队列: binaryHeap (二叉堆)</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="551-vec-动态数组">5.5.1. Vec 动态数组<a href="#551-vec-动态数组" class="hash-link" aria-label="Direct link to 5.5.1. Vec 动态数组" title="Direct link to 5.5.1. Vec 动态数组">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 向量 Vec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 动态数组, 类似 java中的 ArrayList</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///Vector数组天生就可以作 为先进后出(FILO)的栈结构使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Vector -------------------------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //一个 vector 使用 3 个词来表示：一个指向数据的指针，vector 的长度，还有它的容量。此容量指明了要为这个 vector 保留多少内存。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //vector 的长度 只要小于该容量，就可以随意增长；当需要超过这个阈值时，会给 vector 重新分配一段 更大的容量。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 扩容: 自动按照 2 倍扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let vec: Vec&lt;i32&gt; = Vec::new(); // 创建类型为 i32 的空向量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 预分配 10 个单位</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 真正分配 的堆内存 大 小 等于数组中元素类型所占字节与给定容量值 之积</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Vee::with capacity(1O)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let vector = vec![1, 2, 4, 8];     // 通过数组和宏创建向量 // v: Vec&lt;i32&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = vec![0; 10]; // ten zeroes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut vec_fixed: Vec&lt;_&gt;= (0..10).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}, v[0] = {}&quot;, vec, vec[0]);//下标必须是 usize 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // vec 转换 数组/切片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr = vec[..];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     vec.len();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 添加, 删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类似 栈</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec.push(6);//尾插</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec.push(7);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if let Some(x) = vec.pop() {// 尾部删除返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;popped: {}&quot;, x);// 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;None&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;after pop: {:?}&quot;, vec); // [6]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从 0 位置开始清除到末尾, 等同清空数据, 但是内存没有释放, 只是擦除了数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec . truncate (0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 清空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec.clear()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 释放空闲容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec.shrink_to_fit() //方法，预分配的堆内存被释放了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 交换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.swap(1, 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 全部替换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // copy_from_slice 方法可以使用一个数组切片将原 vec 数 组 中的元素全部替换, 数组切片必须和原数组等长, 只支持实现 Copy 语义的元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  clone_from slice方法的效果和 copy_仕om slice是等价的， 但它们的区别是， clone from slice 方法支持实现 Clone 的类型元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 添加另外的 vector</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v2 = vec![100, 101];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec.append(&amp;mut v2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;vec: {:?}&quot;, vec);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;v2: {:?}&quot;, v2);//v2: []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 处理下标越界</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match vec.get(7) { // 返回的是 Option&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(x) =&gt; println!(&quot;Item 7 is {}&quot;, x),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        None =&gt; println!(&quot;Sorry, this vector is too short.&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  contains、 starts with和 ends with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 迭代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 迭代出的是元素引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for ele in &amp;vec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;不可变引用: {}&quot;, ele);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可变迭代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for ele in &amp;mut vec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;可变引用: {}&quot;, ele);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 此时可以修改元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *ele *= 10;// 第一个* 表示根据地址取得值, 第二个*是运算符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 带下标迭代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i, v) in vec.iter().enumerate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}: {}&quot;, i,v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for ele in vec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;本体: {}&quot;, ele);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类型推断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因为有类型说明，编译器知道 `elem` 的类型是 u8。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let elem = 5u8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建一个空向量（vector，即不定长的，可以增长的数组）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut vec = Vec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec.push(elem);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 啊哈 聪明！现在编译器知道 `vec` 是 u8 的向量了（`Vec&lt;u8&gt;`）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, vec);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // slices 是 &amp;[u8] 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v: Vec&lt;u8&gt; = slices.to_vec()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s: String = String::from_utf8(v).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Vec&lt;String&gt; -&gt; Vec&lt;&amp;str&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v7: Vec&lt;&amp;str&gt; = v.iter().map(|s| s.as_ref()).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v4: Vec&lt;&amp;str&gt; = v.iter().map(|s| s as &amp;str).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v6: Vec&lt;&amp;str&gt; = v.iter().map(|s| { let s: &amp;str = s; s }).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v5: Vec&lt;&amp;str&gt; = v.iter().map(|s| &amp;s[..]).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v2: Vec&lt;&amp;str&gt; = v.iter().map(|s| &amp;**s).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let v3: Vec&lt;&amp;str&gt; = v.iter().map(std::ops::Deref::deref).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="552-双端队列-vecdeque">5.5.2. 双端队列 VecDeque<a href="#552-双端队列-vecdeque" class="hash-link" aria-label="Direct link to 5.5.2. 双端队列 VecDeque" title="Direct link to 5.5.2. 双端队列 VecDeque">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 是一种 同时具有 队列(先进先出)和栈 (后进先出)性质的数据 结构 。 双端队列中的元素可 以从两端弹出，插入和删除操作被限定 在队列的两端进行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 内部主要维护一个环形缓冲区 (RingBuffer), 由两个指针和 一 个可增长数组组成 。 这两个指针分别为 头指针( Head Pointer)和尾指针( Tail Pointer)。 其中头指针永远指向应该写入数据 的位置，而尾指针永 远指 向可以读取的第一个元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 缓冲区溢出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 假设缓冲区数组初始大小为8, 环形 缓冲区为空 时，两个指针都指向位置 0。当有新元素 插入时，如果 直接插入位置 0，则将用于写入数据 的 Head 指针指向位置 1， 而用于读取数据的 Tail 指针依 旧指向位置 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 当插入第 8 个元素时， Head 和 Tail 指针将再次重叠, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果这时继续给缓冲区添加新元素 ， 那么位置 。 处的数据将被 其他数据覆盖，这就会造成缓冲区溢出攻击; 为了避免这种情况，需要空出一个位置， 不能插入元素 ， 这样才可以区分头和尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 要判断环形缓冲区是否为满状态，就必须看容量和大小的差是否为 l</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="553-链表-linkedlist">5.5.3. 链表 Linkedlist<a href="#553-链表-linkedlist" class="hash-link" aria-label="Direct link to 5.5.3. 链表 Linkedlist" title="Direct link to 5.5.3. 链表 Linkedlist">​</a></h3><p>因为是双向列表， 所以提供了 push back 和 push front 两类方法，方便操作 此链表。也提供了 append 方法 ， 可以用来连接两个链表</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="554-hashmap-无序哈希表">5.5.4. hashmap 无序哈希表<a href="#554-hashmap-无序哈希表" class="hash-link" aria-label="Direct link to 5.5.4. hashmap 无序哈希表" title="Direct link to 5.5.4. hashmap 无序哈希表">​</a></h3><p>Key必须是可哈希的类型， Value必须是在编译期已知大小的类型</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5541-哈希表基本使用">5.5.4.1. 哈希表基本使用<a href="#5541-哈希表基本使用" class="hash-link" aria-label="Direct link to 5.5.4.1. 哈希表基本使用" title="Direct link to 5.5.4.1. 哈希表基本使用">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///HashMap 的键可以是布尔型、整型、字符串，或任意实现了 Eq 和 Hash trait 的其他类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///HashMap 在占据了多余空间时还可以缩小 自己</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn hash_table() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::collections::HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut map = HashMap::new();//不会预分配内 存。若始终不添加元素, 会编译报错, 编译器认为 map 没有初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HashMap::with_capacity(unit) //创建具有一定初始容量的 HashMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从 vector 构造</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let keys = vec![&quot;a&quot;, &quot;b&quot;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let values = vec![0, 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let m: HashMap&lt;_, _&gt; = keys.iter().zip(values.iter()).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 另一种初始化方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let map: HashMap&lt;char, i32&gt; = vec![</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (&#x27;I&#x27;, 1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (&#x27;V&#x27;, 5),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (&#x27;X&#x27;, 10),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (&#x27;L&#x27;, 50),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (&#x27;C&#x27;, 100),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (&#x27;D&#x27;, 500),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (&#x27;M&#x27;, 1000),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .into_iter()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 插入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果被插入的值为新内容，那么 `HashMap::insert()` 返回 `None`，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 否则返回 `Some(被覆盖的 value)`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map.insert(&quot;color&quot;, &quot;red&quot;);// 没有声明散列表的泛型，是因为 Rust 的自动判断类型机制。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map.insert(&quot;size&quot;, &quot;10 m^2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //不存在才插入值 red, 并且返回该值的可变借用, (一般的插入则是有则覆盖旧的值)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or_insert_with(FnOnce) 传递一个可计算的闭包作为要插入的值, 闭包没有参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // key()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map.entry(&quot;color&quot;).or_insert(&quot;red&quot;);// , 返回 &quot;red&quot; 的 &amp;mut T </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map.remove(&amp;(&quot;Ashley&quot;)); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 接受一个引用并返回 Option&lt;&amp;V&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let one = map.get(&amp;&quot;color&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let one = map[&quot;color&quot;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;one is a Option&lt;&amp;V&gt; ,  {}&quot;, *(one.unwrap()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可变获取(修改) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut map = HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map.insert(1, &quot;a&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if let Some(x) = map.get_mut(&amp;1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *x = &quot;b&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 是否包含</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if !book_reviews.contains_key(&quot;rust book&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;find {} times &quot;, book_reviews.len());// 长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 迭代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for p in map.iter() {//迭代元素是表示键值对的元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{:?}&quot;, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (k, v) in &amp;map {// 元素为 (&amp;&#x27;a key, &amp;&#x27;a value) 对</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}, {}&quot;, k, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过keys和values方法可以分别单独获取HashMap中的键/值的迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for key in book_reviews.keys() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for val in book_reviews.values() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       println!(&quot;{}&quot;, val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 统计句子中的单词个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let text = &quot;aa bb cc bb&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut counter = HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for word in text.split_whitespace() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let count = counter.entry(word).or_insert(0);// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *count += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (word, count) in counter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}, {}&quot;, word, count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 合并多个 HashMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 合并两个或多个 HashMap, 尽量使用 extend或其他迭代器适配器方式， 而不要用 for循环来插入 ,否则会带来性能 问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map1.extend(map2);//本质上， 在 extend方法内部也将 HashMap转换为法代器进行操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map1.into_iter().chain(map2).collect()//同样是通过 into_iter得到 Chain迭代器 然后操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 被添加的 map_ref 是个引用, 原始 map 不会丢失所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map1.extend(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map_ref.into_iter()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .map(|(k, v)| (k.clone(), v.clone()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5542-复合类型作为-key">5.5.4.2. 复合类型作为 key<a href="#5542-复合类型作为-key" class="hash-link" aria-label="Direct link to 5.5.4.2. 复合类型作为 key" title="Direct link to 5.5.4.2. 复合类型作为 key">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    // 基础类型的 浮点数, 无法作为 key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 复杂类型作为键 key, 必须实现 Hash和Eq trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //f32 和 f64 没有实现 Hash，这很大程度上是由于若使用浮点数作为 散列表的键，浮点精度误差会很容易导致错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //对于所有的集合类（collection class），如果它们包含的类型都分别实现了 Eq 和 Hash，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //那么这些集合类也就实现了 Eq 和 Hash。例如，若 T 实现了 Hash，则 Vec&lt;T&gt; 也实现了 Hash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //自定义类型可以轻松地实现 Eq 和 Hash，只需加上一行代码：#[derive(PartialEq, Eq, Hash)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Eq 要求你对此类型推导 PartiaEq。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(PartialEq, Eq, Hash)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Account&lt;&#x27;a&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        username: &amp;&#x27;a str,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        password: &amp;&#x27;a str,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct AccountInfo&lt;&#x27;a&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: &amp;&#x27;a str,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        email: &amp;&#x27;a str,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Accounts&lt;&#x27;a&gt; = HashMap&lt;Account&lt;&#x27;a&gt;, AccountInfo&lt;&#x27;a&gt;&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn try_logon&lt;&#x27;a&gt;(accounts: &amp;Accounts&lt;&#x27;a&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            username: &amp;&#x27;a str, password: &amp;&#x27;a str){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Username: {}&quot;, username);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Password: {}&quot;, password);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Attempting logon...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let logon = Account {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            username: username,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            password: password,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match accounts.get(&amp;logon) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Some(account_info) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                println!(&quot;Successful logon!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                println!(&quot;Name: {}&quot;, account_info.name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                println!(&quot;Email: {}&quot;, account_info.email);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; println!(&quot;Login failed!&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="5543-哈希碰撞攻击">5.5.4.3. 哈希碰撞攻击<a href="#5543-哈希碰撞攻击" class="hash-link" aria-label="Direct link to 5.5.4.3. 哈希碰撞攻击" title="Direct link to 5.5.4.3. 哈希碰撞攻击">​</a></h4><p>map 底层使用数组存储数据, 需要一个高效的 hash 函数均匀的将元素分散存储在 数组中 </p><p>负载因子: 当前的默认扩容策略 为负载因子达到 0.9 时则进行扩容</p><p>Rust标准库实现的 HashMap， 默认的 Hash 函数算法是 SipHashl3o 另外，标准库还实现 了 SipHash24, SipHash算法可以防止 Hash碰撞拒绝服务攻击(Hash Collision DoS)，这种
攻击是一种基于各语言 Hash 算法的随机性而精心构造出来的增强 Hash碰撞的手段，被攻击 的服务器 CPU 占用率会轻松地制升到 100%</p><p>如何解决哈希碰撞?</p><ul><li>外部拉链法: 在数组的每个元素位置, 遇到碰撞后, 生长出一个链表, 但是有退化到单链表的风险</li><li>开放定址法: 在发生冲突时直接去寻找下一个空的地址, 开放定址法的优点在于计算简单、快捷，处理方便:缺点是它会 产生聚集 现象，并且删除元 素也会变得十分复杂(因为并不能真的删除， 否则会破坏寻址的正确性)
寻找下一个空地址的行为，叫作探测 (Probe)。依次 一 个个地 寻找 叫作 续性探测( Linear Probing), rust 采用这种</li></ul><blockquote><p>在线性探测时，如果遇到空桶， 则正常插入; 如果遇到桶己 经被占用 ，那么 就要看占用这个桶的键值对是经历 过几次 探测才被插入该位置 的， 如果该键值对的探测次数比当前待插入的键值对的探测次数少，则它属于“富翁”， 就把当前的键值对插入该位置，再接着找下一个位置来安置被替换的“富翁”键值对。 正是因 为这种“劫 富济贫 ”的思路，这种 算法才被称 为罗 宾汉算法。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="555-btreemap-有序哈希表">5.5.5. BTreeMap 有序哈希表<a href="#555-btreemap-有序哈希表" class="hash-link" aria-label="Direct link to 5.5.5. BTreeMap 有序哈希表" title="Direct link to 5.5.5. BTreeMap 有序哈希表">​</a></h3><p>基于 B 树的有序映射集实现，按 Key 排序</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="556-hashset-无序集合">5.5.6. hashset 无序集合<a href="#556-hashset-无序集合" class="hash-link" aria-label="Direct link to 5.5.6. hashset 无序集合" title="Direct link to 5.5.6. hashset 无序集合">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// HashSet&lt;K&gt; BTreeSet&lt;K&gt;其实就是 HashMap&lt;K, V&gt;和 BTr巳eMap&lt;K, V&gt;把 Value 设置 为空元组的特定类型，等价于 HashSet&lt;K, ()&gt;和 BTreeSet&lt;K, ()&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //散列集 HashSet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //union（并集）：获得两个集合中的所有元素（不含重复值）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // difference（差集）：获取属于第一个集合而不属于第二集合的所有元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // intersection（交集）：获取同时属于两个集合的所有元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // symmetric_difference（对称差）：获取所有只属于其中一个集合，而不同时属于 两个集合的所有元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::collections::HashSet;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut a: HashSet&lt;i32&gt; = vec!(1i32, 2, 3).into_iter().collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut b: HashSet&lt;i32&gt; = vec!(2i32, 3, 4).into_iter().collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a.insert(4); // 如果值已经存在，那么 `HashSet::insert()` 返回 false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a.contains(&amp;4);//是否存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //并集</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c = a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="557-btreeset-有序集合">5.5.7. BTreeSet 有序集合<a href="#557-btreeset-有序集合" class="hash-link" aria-label="Direct link to 5.5.7. BTreeSet 有序集合" title="Direct link to 5.5.7. BTreeSet 有序集合">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="558-优先队列-binaryheap">5.5.8. 优先队列 BinaryHeap<a href="#558-优先队列-binaryheap" class="hash-link" aria-label="Direct link to 5.5.8. 优先队列 BinaryHeap" title="Direct link to 5.5.8. 优先队列 BinaryHeap">​</a></h3><p>使用 peek方法可以 取出堆中的最大值</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="56-类型转换">5.6. 类型转换<a href="#56-类型转换" class="hash-link" aria-label="Direct link to 5.6. 类型转换" title="Direct link to 5.6. 类型转换">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="561-基本的类型转换">5.6.1. 基本的类型转换<a href="#561-基本的类型转换" class="hash-link" aria-label="Direct link to 5.6.1. 基本的类型转换" title="Direct link to 5.6.1. 基本的类型转换">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类型转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 as 关键字进行显 式类型转换（casting）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;------类型转换--------------------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let decimal = 65.4321_f32; // 通过字面量直接声明类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 错误！不提供隐式转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let integer: u8 = decimal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 可以显式转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let integer = decimal as u8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let character = integer as char;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="562-转换相关的-trait">5.6.2. 转换相关的 trait<a href="#562-转换相关的-trait" class="hash-link" aria-label="Direct link to 5.6.2. 转换相关的 trait" title="Direct link to 5.6.2. 转换相关的 trait">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 其他转换相关的 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//from和into 方法是一对，实现了From trait就会自动反过来实现Into</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - std::convert::From 接口定义 “怎么根据另一种类型生成自己”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Into trait 就是把 From trait 倒过来而已; 使用 Into trait 通常要求指明要转换到的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//- TryFrom and TryInto trait 用于易出错的转换，也正因如此，其返回值是 Result </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//- ToString trait 要把任何类型转换成 String，只需要实现 to_string 方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//然而不要直接这么做，应该实现fmt::Display trait，它会自动提供 ToString，并且还可以用来打印类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//-  对应的有 FromStr, 只要对目标类型实现了 FromStr trait，就可以用 parse 把字符串转换成目标类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::convert::From;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Number {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    value: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl From&lt;i32&gt; for Number {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn from(item: i32) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Number { value: item }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let num = Number::from(30);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;My number is {:?}&quot;, num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let int = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let num: Number = int.into();// num 类型必须指定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;My number is {:?}&quot;, num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="57-所有权">5.7. 所有权<a href="#57-所有权" class="hash-link" aria-label="Direct link to 5.7. 所有权" title="Direct link to 5.7. 所有权">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="571-为什么需要所有权-raii机制">5.7.1. 为什么需要所有权 RAII机制<a href="#571-为什么需要所有权-raii机制" class="hash-link" aria-label="Direct link to 5.7.1. 为什么需要所有权 RAII机制" title="Direct link to 5.7.1. 为什么需要所有权 RAII机制">​</a></h3><p>所有权是对堆内存上的数据来说的, 所有权为每个数据规定了主人, 避免了数据竞争, 同时也能减少bug. </p><p>栈内存中变量的生命周期是短暂的, 随着方法调用的结束而清理, 堆内存的变量虽然可以长久存在, 但是非线程私有, 其内部的数据需要通过栈内存中的指针来使用</p><p>指针在堆上开辟内存 空 间，并拥有其所有权，通过存储于stack中的指针来管理堆内存 , 智能指针的 RAII 机制利用stack的特点，在元素被自动清空时自动调用析构函数，来释放智 能指针所管理的堆内存 空间</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="572-基本原则">5.7.2. 基本原则<a href="#572-基本原则" class="hash-link" aria-label="Direct link to 5.7.2. 基本原则" title="Direct link to 5.7.2. 基本原则">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 每种编程语言都有自己的一套内存管理的方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//有些需要显式的分配和回收内存（如C），</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 有些语言则依赖于垃圾回收器来回收不使用的内存（如Java）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 而Rust不属于以上任何一种，它有一套自己的内存管理规则，叫做Ownership。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 1.  在同一个 scope 内,&quot;值&quot;有且仅有一个 owner, 当owner超出作用域后，值会被销毁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          例如 , </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let a = 11, let b = Person {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            func(a, b); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//           因为函数调用底层实际是 将 a, b 赋值给 函数栈中的临时变量, 造成 a, b 的所有权转移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//            对于 基本类型 a, 实现了 copy trait, 所有权转移的效果是 复制, a 仍然能继续使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//            对于 符合类型b, 没有 copy trait, 所有权转移后, b 就失效了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2. 可以有多个不可变引用和唯一的可变引用 (类似读写锁)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//       在不可变借用期间，所有者不能修改资源，并且也不能再进行可变借用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//       在可变借用期间，所有者不能访问资源，并且也不能再出借所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3. references 的 lifecycle 不能超过&quot;值&quot;的 lifecycle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          reference 不能比 owner 活的时间还长 (比如通过 closure 捕获一个外部变量, 若不显式指定 move 语义, name 捕获的是 reference, 外部的 owner 可能已经被回收了, closure 内部的 reference 可能还在被使用, 这是错误的)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="573-字符串赋值的所有权">5.7.3. 字符串赋值的所有权<a href="#573-字符串赋值的所有权" class="hash-link" aria-label="Direct link to 5.7.3. 字符串赋值的所有权" title="Direct link to 5.7.3. 字符串赋值的所有权">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn ownership() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对于 basic type, 数据的互动都发生在栈上, 大小已经确定, 复制起来很快, 所以采用的是复制克隆</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y = x; // 现在栈中将有两个值 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}, {}&quot;, x, y);// 都有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //产生一个 String 对象，值为 &quot;hello&quot;。长度可变, 需要在堆中存储</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // s1 存储在栈, 结构中包含一个 ptr, 指向堆中的String 字符序列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = s1;// 拷贝 s1  本身给 s2, 堆中的数据还是同一份</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 此时, s1已经失效了, 表现的像 s1 移动到 s2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //为什么rust规定此时 s1失效?  因为如果程序在这里结束,  s1 和 s2 都被释放的话堆区中的 &quot;hello&quot; 被释放两次，会出错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 为了确保安全，在给 s2 赋值时 s1 已经无效了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;s2 = {}&quot;, s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;s1 = {}&quot;, s1); // 错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 复制克隆堆中的对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = s1.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 此时, s1 s2 都有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="574-函数参数的所有权">5.7.4. 函数参数的所有权<a href="#574-函数参数的所有权" class="hash-link" aria-label="Direct link to 5.7.4. 函数参数的所有权" title="Direct link to 5.7.4. 函数参数的所有权">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 函数 参数的所有权机制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果将变量当作参数传入函数，那么它和移动的效果是一样的 (函数外部的变量失效)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from(&quot;nihao&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = 11;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fn_basic_type(a: i32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;a = {}&quot;, a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } // 函数结束, a基本类型, 资源无需释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fn_str_type(s: String) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;s = {}&quot;, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } // 函数结束, s 资源被释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // s 被作为参数传递到函数内, 形参指向 String对象, 那么前面的 s 失效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //相当于数据被移动了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn_str_type(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 所以这里 s 无效了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(s);//error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // a 是基本类型, 实现了 copy trait, 传递时是 copy,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn_basic_type(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 所以, 此时 a 仍然有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;a = {}&quot;, a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="575-函数返回值所有权">5.7.5. 函数返回值所有权<a href="#575-函数返回值所有权" class="hash-link" aria-label="Direct link to 5.7.5. 函数返回值所有权" title="Direct link to 5.7.5. 函数返回值所有权">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 函数返回值的所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //而不会直接被无效释放。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn return_str() -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn give_and_return_str(s: String) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = return_str(); // 函数将内部返回值移动到 s1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s3 = give_and_return_str(s2); // s2 被移动失效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="576-复合类型中的所有权">5.7.6. 复合类型中的所有权<a href="#576-复合类型中的所有权" class="hash-link" aria-label="Direct link to 5.7.6. 复合类型中的所有权" title="Direct link to 5.7.6. 复合类型中的所有权">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 所有权机制会带来复杂性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        email: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut p = Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: &quot;xiaoyu&quot;.to_owned(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        email: &quot;775000738@qq.com&quot;.to_owned(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _name = p.name;// property &quot;name&quot; was been removed out of p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, p); // 编译出错 &quot;value borrowed here after partial move&quot; , 属性 name 为 string, 没有 copy trait, 被 move 掉后, 值就为 空了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p.name = &quot;xy&quot;.to_owned(); // 重新赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, p); // 这时不会报错了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 模拟动画渲染示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Buffer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buf: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Render {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        current: Buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next: Buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Render {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn update_buffer(&amp;mut self, buf: String) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 编译错误, next 没有实现 copy trait, 被 move 掉后, 就为 空了,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //一个可选方案是实现 copy trait, 但是这样就没法享受方便的 move 语义了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.current = self.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.next = Buffer {buf,};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 解决:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //需要动用 std::mem::replace(&amp;dest, src) 函数了， 这个函数把 src 的值 move 到 dest 中，然后把 dest 再返回出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.current = std::mem::replace(&amp;mut self.next, Buffer {buf});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="577-多所有权">5.7.7. 多所有权<a href="#577-多所有权" class="hash-link" aria-label="Direct link to 5.7.7. 多所有权" title="Direct link to 5.7.7. 多所有权">​</a></h3><p>需要使用智能指针</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn multi_ownership() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="58-生命周期参数">5.8. 生命周期参数<a href="#58-生命周期参数" class="hash-link" aria-label="Direct link to 5.8. 生命周期参数" title="Direct link to 5.8. 生命周期参数">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="581-什么是生命周期">5.8.1. 什么是生命周期<a href="#581-什么是生命周期" class="hash-link" aria-label="Direct link to 5.8.1. 什么是生命周期" title="Direct link to 5.8.1. 什么是生命周期">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let a = &quot;hello&quot;;//let绑定了标识符 a和存 储字符串的那块内存，从而 a对那块内存拥有了所有权, a 也可称为一个绑定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = a; // a 的所有权被转给b (a 为 &amp;str类型, 无法实现 copy trait); 其实也可以理解为对 a进行解绑，然后重新绑定给 b。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 绑定具有时效性，也就是指它的生存周期</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="582-为什么存在生命周期注释">5.8.2. 为什么存在生命周期注释<a href="#582-为什么存在生命周期注释" class="hash-link" aria-label="Direct link to 5.8.2. 为什么存在生命周期注释" title="Direct link to 5.8.2. 为什么存在生命周期注释">​</a></h3><p>因为存在生命周期检查, 生命周期注释是用来方便编译器进行生命周期检查的 , 并不能改变任何引用的生命周期长短</p><p>为什么要生命周期检查? 因为存在引用, 因为要保证引用的生命周期不能长于出借方的生命周期(防止垂悬引用), 有引用就会有生命周期检查 </p><p>为什需要引用呢? 复合类型如果克隆的话, 会有性能问题, 这种情况, 只能传递引用了.</p><blockquote><p>总结一下就是: 函数参数可 以按值传递， 也可以按 引 用传递。当参数按值 传递肘 ， 会转移所有权或者执行复制( Copy)语义。当参数按引用传递 时， 所有权不会发生 变化 ，但是需要有生命周期参数 。当 符合生命周期参数省略规 则时， 编译器可 以通过自动准 断补齐函数参数的生命周期参数，否则，需要显式地为参数标明生命周期参数</p></blockquote><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// 生命周期注释: 用来标注多个变量间生命周期的关系, 比如生命周期是否一样长</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 目的: 避免垂悬引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 生命周期注释并不改变任何引用的生命周期的长短</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 大部分情况, 生命周期都是可以自动推断的, 就像类型推断 , 没法推断时, 就需要手动标注生命周期注释了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 语法: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// &amp;’a i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// &amp;&#x27;a mut i32 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn life_cycle() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 看一个有问题的例子:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let x = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a = &amp;x; // 错误, `x` does not live long enough, 出了x 作用域, a 对 x 的借用就失效了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, a);// 此时 a 变为垂悬引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;i32        // 常规引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;&#x27;a i32     // 含有生命周期注释的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;&#x27;a mut i32 // 可变型含有生命周期注释的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 只有一个参数并且直接返回的例子</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因为编译器可以自己推导出来，函数 foo() 的参数和返回值都是一个引用，他们的生命周期是一样的，所以，也就可以编译通过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn foo (s: &amp;mut String) -&gt; &amp;String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.push_str(&quot;coolshell&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = &quot;hello, &quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, foo(&amp;mut s))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个例子就不行了 , 编译器无法在编译期间知道会返回哪个变量, 也就无法自动推导出生命周期是否符合要求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个错误例子只针对返回引用的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn longer(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {// error, 返回的引用 可能和参数定义的地方不在同一个作用域, 返回的引用孩砸使用的时候, 参数超出作用域而失效了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if s1.len() &gt; s2.len() {s1}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else {s2}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 正确的写法: 需要手动指定生命周期注释</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn longer&lt;&#x27;a&gt;(s1: &amp;&#x27;a str, s2: &amp;&#x27;a str) -&gt; &amp;&#x27;a str {//函数定义指定了签名中所有的引用必须有相同的生命周期 &#x27;a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 加上周期注释就是告诉编译器: 函数返回的引用的生命周期 &lt;= 每个传入参数的生命周期, 即返回值在使用过程中, 是安全的, 不会指向空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if s2.len() &gt; s1.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s1 = &quot;rust&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s2 = &quot;ecmascript&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r = longer(s1, s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{} is longer&quot;, r); // 此时 s1, s2 都销毁了, 为什么 r 仍然有效呢? 因为 s1, s2 都是 &amp;str 类型, 分配在 栈中, 在方法退出前, 都有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //看 String 的例子:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let string1 = String::from(&quot;long string is long&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let string2 = String::from(&quot;xyz&quot;); // 这里就有问题了, String 类型 字符序列分配在 heap, 超出 作用域自行销毁了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = longer(string1.as_str(), string2.as_str());// error, borrowed value does not live long enough</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                                //  string2 生命周期比 result 短</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The longest string is {}&quot;, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //加不加 &#x27;a 都是错误, cannot return value referencing local variable `s`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因为函数结束, s 会离开作用域, 被清理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_str&lt;&#x27;a&gt;(s: &amp;&#x27;a str) -&gt; &amp;&#x27;a str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.as_str() </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="583-函数中的生命周期参数">5.8.3. 函数中的生命周期参数<a href="#583-函数中的生命周期参数" class="hash-link" aria-label="Direct link to 5.8.3. 函数中的生命周期参数" title="Direct link to 5.8.3. 函数中的生命周期参数">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn foo&lt;’a&gt;(s: &amp;’a str, t: &amp;’a str) -&gt; &amp;’a str</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输出(借用方)的生命周期长度必须 短于/等于 输入(出借方)的生命周期长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// -》返回的引用必须和输入参数有点关系才行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="584-结构体中生命周期-省略的规则">5.8.4. 结构体中生命周期 省略的规则<a href="#584-结构体中生命周期-省略的规则" class="hash-link" aria-label="Direct link to 5.8.4. 结构体中生命周期 省略的规则" title="Direct link to 5.8.4. 结构体中生命周期 省略的规则">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 生命周期省略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 省略遵循的规则:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 只有一个生命周期参数, 可以省略, 如 fn bar&lt;&#x27;a&gt;(x: &amp;&#x27;a i32) -&gt; &amp;&#x27;a 32 等价 fn bar(x: &amp;i32) -&gt; &amp;i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 每个引用参数都有属于自己的周期参数, 如 fn foo&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32), fn bar&lt;&#x27;a&gt;(x: &amp;&#x27;a i32)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 对于 struct 的方法, 第一个参数都是 &amp;self, 那么 self 的周期被赋予所有输出生命周期参数 , 所以 返回参数可以省略周期参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 加上周期注释, 告诉编译器, 结构体的生命周期 &lt;= 成员引用的生命周期, 即成员的周期要保证结构体周期的安全, 成员的周期必须要更大</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Str&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content: &amp;&#x27;a str // 使用字符串切片引用, 之前都是使用的 String </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl&lt;&#x27;a&gt; Str&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //这里返回值并没有生命周期注释，但是加上也无妨。这是一个历史问题，早</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //期 Rust 不支持生命周期自动判断，所有的生命周期必须严格声明，但主流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //稳定版本的 Rust 已经支持了这个功能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn get_content(&amp;self) -&gt; &amp;str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.content</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //指定: 结构体方法的“引用参数”的生命周期 &gt;= 结构体的生命周期, 保证结构体周期的安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 若没有 ‘a, 会报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn replate(&amp;mut self, new: &amp;&#x27;a str) {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = Str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content: &quot;string_slice&quot; // 方便多了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;s.content = {}&quot;, s.get_content());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="585-静态生命周期注释">5.8.5. 静态生命周期注释<a href="#585-静态生命周期注释" class="hash-link" aria-label="Direct link to 5.8.5. 静态生命周期注释" title="Direct link to 5.8.5. 静态生命周期注释">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> //静态生命周期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //&#x27;static 所表示的生命周期从程序运行开始到程序运行结束。(若一个类型被限制为 &#x27;static ,则表示该类型不能是任何借用的数据, 必须是 own 的数据, 必须拥有ownership; 因为 &#x27;static 说明他的 lifecycle 最长, 若该类型接收的是借用的数据, 那么无法保证 lifecycle 最长)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //所有字符串字面量都是 &amp;&#x27;static str ，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s: &amp;&#x27;static str = &quot;hello&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 等价</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = &quot;hello&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //一个综合例子🌰</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::fmt::Display;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn longest_with_an_announcement&lt;&#x27;a, T&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str, ann: T) -&gt; &amp;&#x27;a str</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        where T: Display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Announcement! {}&quot;, ann);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if x.len() &gt; y.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="586-生命周期约束">5.8.6. 生命周期约束<a href="#586-生命周期约束" class="hash-link" aria-label="Direct link to 5.8.6. 生命周期约束" title="Direct link to 5.8.6. 生命周期约束">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// T:’a， 表示T类型中的任何引用都要“活得” 和 ’a 一样长。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// T: Trait + ‘a，表示 T类型必须实现 Trait这个 trait，并且 T类型中任何引用都要“活得”和 ’a 一样长。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="59-引用">5.9. 引用<a href="#59-引用" class="hash-link" aria-label="Direct link to 5.9. 引用" title="Direct link to 5.9. 引用">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="591-引用基本介绍">5.9.1. 引用基本介绍<a href="#591-引用基本介绍" class="hash-link" aria-label="Direct link to 5.9.1. 引用基本介绍" title="Direct link to 5.9.1. 引用基本介绍">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 借用(引用)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// &quot;&amp;&quot;符号用于从变量借用所有权, 生成一个变量的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// ref 声明某个变量为引用类型, 用来更改赋值行为, 使得普通的变量赋值行为变为给引用赋值 ; 可用于先声明某个引用类型, 后赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 引用不会获得值的所有权, 引用只能租借（Borrow）值的所有权, 所以 变量 a 的值被借用为 b 时，a 本身仍然有效。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 解引用 使用 * ---- 在等号右边 (会获得原始值的所有权)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 取地址 使用 &amp; ---- 在等右边</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 解构 使用 &amp; --- 在等号左边</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// match的模式匹配的匹配项上只能使用 ref，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 在函数声明上只能使用&amp;来表示引用类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 一个引用的作用域从声明的地方开始一直持续到最后一次使用为止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 分为可变, 不可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 一个原始值, 存在可变借用, 就无法存在其他借用了, 无论是可变借用还是不可变借用 (可变借用具有独占性)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 存在不可变借用, 还能存在其他不可变借用 (相当于内存的读写锁 ，同一时刻，只能 拥有一个写锁，或者多个读锁，不能同时拥有)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let a = 20;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = &amp;a;  // 取地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if a==*b  // true  , *号为解引用符号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;a and *b are equal&quot;);  // 将打印这句</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">else  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;they are not equal&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ref 关键字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ref a=2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = &amp;2; // 等效, 两个值都是&amp;i32类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ref b: i32; // 先声明一个引用类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //b = 1;// 错误, 类型不匹配, expected `&amp;i32`, found integer. expected &amp;i32，consider borrowing here: `&amp;1`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b = &amp;1;// 再赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 为参数声明类型的时候, 只能用 &amp;, 不能用 ref, ref 只用于变量类型声明</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct B&lt;&#x27;l&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub a: &amp;&#x27;l u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub b: ref u32, //错误, expected type, found keyword `ref`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ref a = &amp;1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b = B{ a: a };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn test(a: ref i32) {    } // 错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v_mut = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match v {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ref 会声明 val 是 &amp;i32 类型, 通过 val 接收 v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ref val =&gt; println!(&quot;val 是引用, val = {}&quot;, val),// 打印, *val 也可, 打印时可以省略 *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match v_mut {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ref mut val =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 需要 val 声明为 mut</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            *val = 3; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;val 是可变引用, val = {}&quot;, val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 解引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r=&amp;1;// r 是引用类型 &amp;i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let &amp;a=r;// a 是普通类型, i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c=*r; // c 同 a, 是 i32 (解引用)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // match 中使用解引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r = &amp;1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match r {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;val =&gt; println!(&quot;通过解引用获取值: {}&quot;, val), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match r {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *val =&gt; println!(&quot;使用 * 解引用: {}&quot;, val),// 错误, * 不能用来做声明</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 需要先解引用, 再内部使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match *r {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val =&gt; println!(&quot;匹配前先解引用: {}&quot;, val),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::mem:size_of&lt;&amp;[u32; 5]&gt;() //函数可以返回类型的字节数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // &amp;[u32;5]类型为普通指针 (因为数组的元素类型, 元素个数确定了, 无需额外的容量来存储数据的长度)，占8个字节:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // &amp;mut[u32]类型为胖指针 (宽度是双宽度的, 数组的元素个数不确定, 除了要保存指向起始位置的地址外, 还要保存数据的长度  )，占16 个字节。 可见， 整整多出了一倍的占用空间，这也是称其为胖指针的原因</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="592-不可变引用">5.9.2. 不可变引用<a href="#592-不可变引用" class="hash-link" aria-label="Direct link to 5.9.2. 不可变引用" title="Direct link to 5.9.2. 不可变引用">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;------------------引用/借用---------------------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = &amp;s1; // 获取引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;s1 is {}, s2 is {}&quot;, s1, s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 函数调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn calculate_length(s: &amp;String) -&gt; usize {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.len()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let len = calculate_length(&amp;s1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;The length of &#x27;{}&#x27; is {}.&quot;, s1, len);// s1 还有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = &amp;s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 错误, 执行这句, s1 会移动而失效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 造成 s2 对 s1 的租借也失效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s3 = s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, s2);//error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s2 = &amp;s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s3 = s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s2 = &amp;s3; // // 重新从 s3 租借所有权, 要求 s2 是 mut 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;s2 = {}&quot;, s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 引用的所有权是租借的, 不允许修改值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = String::from(&quot;run&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = &amp;s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s2.push_str(&quot;oob&quot;); // 错误，禁止修改租借的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="593-可变引用">5.9.3. 可变引用<a href="#593-可变引用" class="hash-link" aria-label="Direct link to 5.9.3. 可变引用" title="Direct link to 5.9.3. 可变引用">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn borrow() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可修改值的租借</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s1 = String::from(&quot;run&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // s1 是可变的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = &amp;mut s1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // s2 是可变的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s2.push_str(&quot;oob&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;可变引用, s2 = {}&quot;, s2);//runoob</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;s1 = {}&quot;, s1);//runoob</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //可变引用不允许多重引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //一个值被可变引用时不允许再次被任何引用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r1 = &amp;mut s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 错误, 因为 两个可变引用指向了 s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r2 = &amp;mut s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类似的多重引用问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r1 = &amp;s; // 没问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r3 = &amp;mut s; // 大问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, r1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="594-垂悬引用问题dangling-references">5.9.4. 垂悬引用问题（Dangling References)<a href="#594-垂悬引用问题dangling-references" class="hash-link" aria-label="Direct link to 5.9.4. 垂悬引用问题（Dangling References)" title="Direct link to 5.9.4. 垂悬引用问题（Dangling References)">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //垂悬引用（Dangling References）---- 如何解决 -&gt; 生命周期注释</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 垂悬引用（Dangling References): 没有实际指向一个真正能访问的数据的指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //在 Rust 语言里不允许出现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn dangle() -&gt; &amp;String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //函数的结束，其局部变量的值本身没有被当作返回值，被释放了。但它的引用却被返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 再比如:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let x = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r = &amp;x; //`x` does not live long enough,  r 所引用的值已经在使用之前被释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;r = {}&quot;, r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 再比如:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn longer(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if s2.len() &gt; s1.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // //上个函数错误, 无法编译, 原因是返回值引用可能会返回过期的引用, 例如这样使用:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s1 = &quot;rust&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s2 = &quot;ecmascript&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        r = longer(s1, s2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{} is longer&quot;, r); // r 被使用的时候源值 s1 和 s2 都已经失效了, 需要使用生命周期注释, 为返回值声明一个注释, 贴到 参数上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="510-裸指针">5.10. 裸指针<a href="#510-裸指针" class="hash-link" aria-label="Direct link to 5.10. 裸指针" title="Direct link to 5.10. 裸指针">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 原生 指针是指形如* const T 和*mut T 这样的类型 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 可以通过 as操作符随意转换为原生指针，例如 &amp;T as *constT 和 &amp;mut T as *mutT。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 场景:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 在需要的时候跳过 Rust 安全检查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 与 C 语言“打交道&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 内置函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • std::ptr::null 函数和 is_null 方法 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • offset方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • read/write方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • replace/swap 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 解引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = &quot;hello&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r1 = &amp;s as *const String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r2 = &amp;mut s as *mut String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(r1, r2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let address = 0x7fff1d72307d;// 随便指定的地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r3 = address as *const String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;r1 is: {}&quot;, *r1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       println!(&quot;r2 is: {}&quot;, *r2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       // Segmentation fault  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       assert_eq!(*r1, *r3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建空指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let p: *const u8 = std::ptr::null();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 判断是否为空指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(p.is_null());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s: &amp;str = &quot;hello&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获得不可变原生指针 (指向具体数据/数据内部的元素)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 指针 ptr 的类型为*const u8， 这 是因为字符串是以字节为单位存储的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ptr: *const u8 = s.as_ptr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(!ptr.is_null());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //对比 通过 as_ptr()获取指针:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 通过 as_ptr 得到的指针是指向存放数据堆/栈 内存的指针，而引用则是对字符串或数组本身的引用(比前者单纯的指针包含更多数据)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut x = &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let y = &amp;mut x as *mut &amp;str;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       assert_eq!(y.read(), &quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = [1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获得可变原生指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ptr: *mut u32 = s.as_mut_ptr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(!ptr.is_null());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// offset() 可以指定相对于指针地址的偏移字节数，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s: &amp;str = &quot;Rust&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ptr: *const u8 = s.as_ptr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // offset方法不能保证传入的偏移量合法，故为unsafe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{:?}&quot;, *ptr.offset(1) as char); // u</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{:?}&quot;, *ptr.offset(3) as char); // t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{:?}&quot;, *ptr.offset(255) as char); // ÿ 有UB风险</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// read/write  可以读取或写入指针相应 内存中的 内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = &quot;hello&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y: *const u8 = x.as_ptr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert_eq!(y.read() as char, &#x27;h&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = [0, 1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里的原生指针类 型是带长度的，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果将类型改为* const [u32;3] ，则通过 read 方法只能读取到前三个元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y = x[0..].as_ptr() as *const [u32; 4];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       assert_eq!(y.read(), [0,1,2,3]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let x = vec![0, 1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let y = &amp;x as *const Vec&lt;i32&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert_eq!(y.read(), [0,1,2,3]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut x = &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let y = &amp;mut x as *mut &amp;str;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let z = &quot;hello&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       y.write(z);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       assert_eq!(y.read(), &quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// replace/swap   替换指定位置 的内存 数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut v: Vec&lt;i32&gt; = vec![1, 2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let v_ptr : *mut i32 = v.as_mut_ptr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   unsafe{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       let old_v = v_ptr.replace(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       assert_eq!(1, old_v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       assert_eq!([5, 2], &amp;v[..]);    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut v: Vec&lt;i32&gt; = vec![1, 2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let v_ptr  = &amp;mut v as *mut Vec&lt;i32&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  unsafe{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      let old_v = v_ptr.replace(vec![3,4,5]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assert_eq!([1, 2], &amp;old_v[..]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assert_eq!([3, 4, 5], &amp;v[..]);   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let mut array = [0, 1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let x = array[0..].as_mut_ptr() as *mut [u32; 2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let y = array[1..].as_mut_ptr() as *mut [u32; 2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assert_eq!([0, 1], x.read());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assert_eq!([1, 2], y.read());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      x.swap(y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      assert_eq!([1, 0, 1, 3], array);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="511-智能指针">5.11. 智能指针<a href="#511-智能指针" class="hash-link" aria-label="Direct link to 5.11. 智能指针" title="Direct link to 5.11. 智能指针">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5111-智能指针介绍-工作机制">5.11.1. 智能指针介绍 工作机制<a href="#5111-智能指针介绍-工作机制" class="hash-link" aria-label="Direct link to 5.11.1. 智能指针介绍 工作机制" title="Direct link to 5.11.1. 智能指针介绍 工作机制">​</a></h3><p>智能指针就是一个结构体，其行为类似于引用, 指向一块内存的地址, 此外还有存储的有附带的元数据</p><p>智能指针区别于常规结构体的特性在于，它实现了 Deref (所以有了指针语义, 而且使用时, 可以自动解引用) 和 Drop (所以能够自动管理内存释放) ; 比如: String 和 Vec 类型 也是一种智能指针, 它们也都实现了 Deref和Drop (这就是智能指针智能的所在)</p><p>智能指针拥有资源的所有权，而普通引用 只 是对所有权 的借用 。</p><ul><li>线程安全的: Arc, RwLock, Mutex</li><li>线程不安全的: Box , Cell, RefCell, Rc</li></ul><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let x =Box::new(”hello”);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let y = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// error, 因为智能指针拥有原始值的所有权, x已经被转移了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于box&lt;T&gt;, 若包含的 T是移动语义, 则box 也是, 若T是复制语义, 则box 也是复制语义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println1(”(:?}”, x);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5112-raii机制-实现内存回收">5.11.2. RAII机制 实现内存回收<a href="#5112-raii机制-实现内存回收" class="hash-link" aria-label="Direct link to 5.11.2. RAII机制 实现内存回收" title="Direct link to 5.11.2. RAII机制 实现内存回收">​</a></h3><p>RAII: 智能指针在堆内存上开辟空间存储数据, 自身存储在栈上, 在函数调用结束时, 指针变量被清理, 指针执行自身的drop方法, 来释放智 能指针所管理的堆内存 空间</p><p>RAII , 智能指针, 均起源于现代 C++</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5113-自定义智能指针-自动解引用-deref-和-drop">5.11.3. 自定义智能指针 自动解引用 Deref 和 Drop<a href="#5113-自定义智能指针-自动解引用-deref-和-drop" class="hash-link" aria-label="Direct link to 5.11.3. 自定义智能指针 自动解引用 Deref 和 Drop" title="Direct link to 5.11.3. 自定义智能指针 自动解引用 Deref 和 Drop">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">手动显式解引用: *x  &lt;=&gt;   *(x.deref()), deref() 是编译器帮忙加的 (deref() 返回内部数据的引用)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;.&quot;调用 or 在函数参数位置上, 会对x 自动解引用, 等价于 x.deref()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自定义智能指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct MyBox&lt;T&gt;(T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl&lt;T&gt; MyBox&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn new(x: T) -&gt; MyBox&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MyBox(x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //实现 Deref trait 允许我们重载 解引用运算符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::ops::Deref;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl&lt;T&gt; Deref for MyBox&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        type Target = T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn deref(&amp;self) -&gt; &amp;T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;self.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let y = MyBox::new(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;y = {}&quot;, *y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 隐式解引用 (解引用多态)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn hello(name: &amp;str) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Hello, {}!&quot;, name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let m = MyBox::new(String::from(&quot;Rust&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hello(&amp;m);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //在 MyBox&lt;T&gt; 上实现了 Deref trait，Rust 可以通过 deref 调用将 &amp;MyBox&lt;String&gt; 变为 &amp;String。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //Rust 再次调用 deref 将 &amp;String 变为 &amp;str，这就符合 hello 函数的定义了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5114-box-无痛使用堆内存">5.11.4. Box 无痛使用堆内存<a href="#5114-box-无痛使用堆内存" class="hash-link" aria-label="Direct link to 5.11.4. Box 无痛使用堆内存" title="Direct link to 5.11.4. Box 无痛使用堆内存">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51141-box基本使用">5.11.4.1. Box基本使用<a href="#51141-box基本使用" class="hash-link" aria-label="Direct link to 5.11.4.1. Box基本使用" title="Direct link to 5.11.4.1. Box基本使用">​</a></h4><p>类似 cpp 的 unique_ptr;</p><p>通过 Box，用于在堆上分配值</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 为什么使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Rust 中的值默认被分配到stack内存, stack 内存需要知道值的具体大小, 对于 递归类型 和 trait object, 编译时并不知道大小, 而 Box&lt;T&gt; 的大小是已知的。 可以通过 Box &lt;T&gt;将值装箱, 在堆内存中分配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///核心作用就是可以定义动态大小的类型, 实际大小要到运行期才能确定, 如 用在 递归中 and 用在包装 trait 中 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 当箱子实例离开作用域时，它的析构函数会被调用，内部的对象会被 销毁，堆上分配的内存也会被释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  Box&lt;T&gt;指针对所管理的堆内存有唯一拥有权， 所以并不共享</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 使用 * 运算符进行解引用；这会移除掉一层装箱</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn box_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;-------------box_demo--------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b = Box::new(5);//使用 box 在堆上储存一个 i32 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;b = {}&quot;, b);//5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;*b = {}&quot;, *b);//5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 尝试构造链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum List {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Cons(i32, List),// error, 无限递归, 编译器检测出了无限大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Nil,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 正确: (这种方法存在限制, 构造出的 链表无法存在多个引用, 使用一次就失效了, 没法给第二个使用者使用了, 解决: Rc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum List {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Cons(i32, Box&lt;List&gt;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Nil,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use List::Cons;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use List::Nil;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let l = Cons(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box::new(Cons(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Box::new(Cons(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                3,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Box::new(Nil),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, l);//Cons(1, Cons(2, Cons(3, Nil)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51142-包装动态大小类型-dst">5.11.4.2. 包装动态大小类型 DST<a href="#51142-包装动态大小类型-dst" class="hash-link" aria-label="Direct link to 5.11.4.2. 包装动态大小类型 DST" title="Direct link to 5.11.4.2. 包装动态大小类型 DST">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    // 动态大小类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 编译期间无法知道大小, 只有到运行时才知道</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 动态大小类型的值必须通过指针访问 , 如 Box&lt;str&gt;, Rc&lt;str&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - str 在编译期无法知道大小, &amp;str 的大小可以在编译期知道 (&amp;str 存储了 str 的地址 和长度)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - trait , 任何 trait 都是动态大小类型, 应该这么使用: Box&lt;XXXTrait&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Sized trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实现了这个 trait 的类型, 在编译期即可确定大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn xxx_fn&lt;T&gt;(t: T) {} // T 为编译期知道大小的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 等价:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn xxx_fn&lt;T: Sized&gt;(t: T) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 放宽限制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn xxx_fn&lt;T: ?Sized&gt;(t:T) {}// T 可能是 sized 的, 也可能不是 sized 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5115-rc-和-weak-共享堆内存">5.11.5. Rc 和 Weak 共享堆内存<a href="#5115-rc-和-weak-共享堆内存" class="hash-link" aria-label="Direct link to 5.11.5. Rc 和 Weak 共享堆内存" title="Direct link to 5.11.5. Rc 和 Weak 共享堆内存">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51151-rc-强引用">5.11.5.1. Rc 强引用<a href="#51151-rc-强引用" class="hash-link" aria-label="Direct link to 5.11.5.1. Rc 强引用" title="Direct link to 5.11.5.1. Rc 强引用">​</a></h4><p>类似 cpp 的 shared_ptr</p><p>引用计数指针, 其数据可以有多个所有者, 内部包含的数据是不可变的,</p><p>只能用于单线程中, 因为内部操作不是原子性的, rust 也为 其实现了 !send trait , 表示无法在线程间移动; 可以使用多线程版本: Arc</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// Rc&lt;T&gt; 的类型。其名称为 引用计数（reference counting）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Rc&lt;T&gt; 主要用于同一堆上所分配的数据区域需要有多个只读访问的情况, 比起使用 Box&lt;T&gt; 然后创建多个不可变引用的方法更优雅也更直观一些</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 允许 &quot;不可变数据&quot; 有多个所有者, 数据本身无法修改 (将多个所有权共享给多个变量)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 内部维护着一个引用计数器，每clone一次(共享一次)， 计数器加1, 返回不可变引用， 当它们都离开作用域肘， 计 数器会被清零，对应的堆内存也会被自动释放。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 常用方法:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let x =Rc::new(45)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let yl = x .clone() ; //增加强引用计数, 并非 克隆, 只是增加计数, 然后返回一个引用 (即共享所有权)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let y2 = x.clone(); //增加强引用计数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">priηtln!(”{:?}”, Rc::strong_count(&amp;x));//3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">letw= Rc::downgrade(&amp;x); //增加弱引用计数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(” {:?) ”, Rc : :weak_count(&amp;x));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let y3 = &amp;*x; //不增加计数</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51152-构造链表">5.11.5.2. 构造链表<a href="#51152-构造链表" class="hash-link" aria-label="Direct link to 5.11.5.2. 构造链表" title="Direct link to 5.11.5.2. 构造链表">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 通过 box 构造链表存在问题: 链表只能被使用一次, 演示:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum List {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Cons(i32, Box&lt;List&gt;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Nil,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use List::{Cons, Nil};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let a = Cons(5,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Box::new(Cons(10,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Box::new(Nil))));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = Cons(3, Box::new(a)); //a 被移动到了 b 内部</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let c = Cons(4, Box::new(a));//  error 错误, value used here after move</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 Rc 解决</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum List {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Cons(i32, Rc&lt;List&gt;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Nil,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use List::{Cons, Nil};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::rc::Rc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//每次调用 Rc::clone，Rc&lt;List&gt; 中数据的引用计数都会增加，Rc::strong_count(&amp;a) 获取 a 的被引用个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 直到有零个引用之前其数据都不会被清理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//也可以调用 a.clone() 而不是 Rc::clone(&amp;a), 两者意思是一样的, 只会增加引用计数，不会作深度复制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里, b, c 共享 a 的所有权, a 中的数据不可修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = Cons(3, Rc::clone(&amp;a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let c = Cons(4, Rc::clone(&amp;a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// #### 对内部值进行修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///如果你要修改 Rc 里的值，Rust 会给你两个方法，一个是 get_mut()，一个是 make_mut() ，这两个方法都有副作用或是限制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - get_mut() 需要做一个“唯一引用”的检查，也就是没有任何的共享才能修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///- make_mut() 则是会把当前的引用给clone出来，再也不共享了， 是一份全新的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 更好的修改方法:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// RefCell&lt;T&gt; 能够在对象被认为是不可变的情况下修改内部字段; (并非编译器检查, 二是运行期进行检查, 不是很好)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// Cell&lt;T&gt;，它类似 RefCell&lt;T&gt; 但有一点除外：它并非提供内部值的引用，而是把值拷贝进和拷贝出 Cell&lt;T&gt;。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//修改引用的变量 - get_mut 会返回一个Option对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//但是需要注意，仅当（只有一个强引用 &amp;&amp; 没有弱引用）为真才能修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if let Some(val) = Rc::get_mut(&amp;mut strong) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *val = 555;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 或者:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//此处可以修改，但是是以 clone 的方式，也就是让strong这个指针独立出来了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*Rc::make_mut(&amp;mut strong) = 555;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51153-weak-弱引用">5.11.5.3. Weak 弱引用<a href="#51153-weak-弱引用" class="hash-link" aria-label="Direct link to 5.11.5.3. Weak 弱引用" title="Direct link to 5.11.5.3. Weak 弱引用">​</a></h4><p>类似 cpp 的 weak_ptr</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 弱引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 弱引用: Weak&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Weak 共享的指针没有所有权, 称为弱引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 通过 Rc::downgrade 传递 Rc 实例的 reference, 得到 Weak 类型的指针, 同时将 weak_count +1, 不是 strong_count +1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 即使 weak_count 不为零, 也可能使得 Rc 实例被清理, 只要 strong_count == 0 就行了 (解决循环链表造成的内存泄漏)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 可以通过 Rc::upgrade 返回 Option&lt;Rc&lt;T&gt;&gt; 升级成强引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 这么麻烦，我们为什么还要 Weak ? 这是因为强引用的 Rc 会有循环引用的问题……</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 基本使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::rc::Rc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::rc::Weak;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let weak: Weak&lt;i32&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let strong: Rc&lt;i32&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let five = Rc::new(5); //局部变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    strong = five.clone(); //进行强引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    weak = Rc::downgrade(&amp;five); //对局部变量进行弱引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//此时，five已析构，所以 Rc::strong_count(&amp;strong)=1， Rc::weak_count(&amp;strong)=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//如果调用 drop(strong)，那个整个内存就释放了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//drop(strong);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//如果要访问弱引用的值，需要把弱引用 upgrade 成强引用，才能安全的使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//这个升级可能会不成功，因为内存可能已经被别人清空了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">match  weak_five.upgrade() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Some(r) =&gt; println!(&quot;{}&quot;, r),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    None =&gt; println!(&quot;None&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 解决循环引用的内存泄漏问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cell::RefCell,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rc::{Rc, Weak},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Node {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        head: Option&lt;Weak&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Drop for Node {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;dropping&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let one = Rc::new(RefCell::new(Node {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        head: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let two = Rc::new(RefCell::new(Node {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        head: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let three = Rc::new(RefCell::new(Node {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        head: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    one.borrow_mut().next = Some(two.clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    two.borrow_mut().next = Some(three.clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    three.borrow_mut().head = Some(Rc::downgrade(&amp;one));// 弱引用, 即使计数没有归零, 仍然可回收内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5116-refcell-和-cell-提供内部可变性">5.11.6. RefCell 和 Cell 提供内部可变性<a href="#5116-refcell-和-cell-提供内部可变性" class="hash-link" aria-label="Direct link to 5.11.6. RefCell 和 Cell 提供内部可变性" title="Direct link to 5.11.6. RefCell 和 Cell 提供内部可变性">​</a></h3><p>内部可变性: 将可变的数据包装在不可变的结构中, 而无需显式声明 mut</p><p>需要注意的是 Cell 和 RefCell 不是线程安全的。在多线程下，需要使用Mutex进行互斥。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51161-cell">5.11.6.1. Cell<a href="#51161-cell" class="hash-link" aria-label="Direct link to 5.11.6.1. Cell" title="Direct link to 5.11.6.1. Cell">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Cell&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 规避 borrow check: Cell&lt;T&gt; 其实和 Box&lt;T&gt; 很像，但后者同时不允许存在多个对其的可变引用，如果我们真的很想做这样的操作，在需要的时候随时改变其内部的数据，而不去考虑 Rust 中的不可变引用约束，就可以使用 Cell&lt;T&gt;。Cell&lt;T&gt; 允许多个共享引用对其内部值进行更改，实现了「内部可变性」</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 提供了一种内部可变性, 如, 某个 struct 是不可变的, 但是 内部某个字段需要可变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct P {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        y: Cell&lt;i32&gt;,// 这里定义的是 Cell的不可变类型, 但是 内部的数确实可以修改的, 合法的避开的借用检查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let p = P { x: 0, y: Cell::new(11)};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p.y.set(1); // set() 对内部数据的类型没有要求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, p.y.get());// 内部的数据必须是 copy trait 才能使用 get(), 这里实际是获取拷贝, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        //  若是非 copy类型, 提供 get_mut() 获取内部数据的可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51162-refcell">5.11.6.2. RefCell<a href="#51162-refcell" class="hash-link" aria-label="Direct link to 5.11.6.2. RefCell" title="Direct link to 5.11.6.2. RefCell">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// RefCell&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 它类似 Cell&lt;T&gt;,  但有一点除外：提供内部值的引用, 而不是拷贝了, 因此对于内部数据的类型没有 copy trait 要求 (Cell 的内部数据有 copy trait 要求)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 既然不能在读写数据时简单的 Copy 出来进去了，该咋保证内存安全呢?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      borrow chec 放到了运行时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      虽然没有分配空间， 但它是有运行时开销的，因为它自己维护着一个运行时借用检查器, 比如获取多个可变引用, 会Panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 主要两个方法:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// borrow_mut() 获取可变引用 (RefMut&lt;T&gt;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// borrow(), 获取不可变引用 (Mut&lt;T&gt;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// refcell 更常用, 省内存, cell 的 get() 是获取拷贝, 浪费内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = RefCell::new(vec![1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, v.borrow());//1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.borrow_mut().push(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, v.borrow());//1, 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = RefCell::new(vec![1, 2, 3, 4]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, *x.borrow()); //[1, 2, 3, 4]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut my_ref = x.borrow_mut();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        my_ref.push(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若上面的可变借用不另开一个 作用域, 这里报错: 可变借用后, 不允许再次不可变借用了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 另开一个作用域的效果: my_ref 这个可变借用到这里的时候已经被释放了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, *x.borrow()); //[1, 2, 3, 4, 1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // RefCell&lt;T&gt; 的一个常见用法是与 Rc&lt;T&gt; 结合构造链表, rc 允许多重引用, 抱在外层, refcel 获取可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //他们提供了 set()/get() 以及 borrow()/borrow_mut() 的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum List1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List1&gt;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Nil,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use List1::{Cons, Nil};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let value = Rc::new(RefCell::new(5));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *value.borrow_mut() += 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;a after = {:?}&quot;, a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;b after = {:?}&quot;, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;c after = {:?}&quot;, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实例:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 定义一个 trait, 定义发送方法 send, 这里 self 是不可变的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 后续会通过 这个不可变 self 得到可变的成员变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait MsgSender {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn send(&amp;self, msg: &amp;str); // 这个 trait 已经固定, &amp;self 不允许改成 &amp;mut self</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 监控器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct LimitTracker&lt;&#x27;a, S: MsgSender&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sender: &amp;&#x27;a S,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        max: usize, // 最大限量阈值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value: usize, // 已经使用了多少</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl&lt;&#x27;a, T&gt; LimitTracker&lt;&#x27;a, T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        T: MsgSender,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn new(sender: &amp;&#x27;a T, max: usize) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LimitTracker {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sender,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                max,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                value: 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn set_value(&amp;mut self, value: usize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let percent = self.value as f64 / self.max as f64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if percent &gt;= 1.0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.sender.send(&quot;&gt;= 1.0&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if percent &gt;= 0.8 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                self.sender.send(&quot;&gt;= 0.8&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::cell::RefCell;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //消息发送模拟器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct MsgSenderMock {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 为什么要包装?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //后面需要通过 不可变的 &amp;self 拿到可变的 msg_send (不可变 &amp;self 是在 trait 中定义的, send方法获取的是 self不可变引用)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果不包装一下, 则这里无法修改 msg_send 来记录发送的消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        msg_send: RefCell&lt;Vec&lt;String&gt;&gt;,// 记录发送的信息, 发送的消息会存储到这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl MsgSenderMock {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn new() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MsgSenderMock {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg_send: RefCell::new(vec![]),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl MsgSender for MsgSenderMock {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn send(&amp;self, msg: &amp;str) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 改为 refcell后, 通过 borrow_mut 得到可变引用, 类型 Ref, 类似普通引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.msg_send.borrow_mut().push(msg.to_string());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mock_sender = MsgSenderMock::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut tracker = LimitTracker::new(&amp;mock_sender, 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tracker.set_value(8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, mock_sender.msg_send.borrow()[0]); // 获取不可变引用</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5117-rc-box-refcell-cell-几种指针的区别对比-组合使用">5.11.7. Rc Box RefCell Cell 几种指针的区别对比 组合使用<a href="#5117-rc-box-refcell-cell-几种指针的区别对比-组合使用" class="hash-link" aria-label="Direct link to 5.11.7. Rc Box RefCell Cell 几种指针的区别对比 组合使用" title="Direct link to 5.11.7. Rc Box RefCell Cell 几种指针的区别对比 组合使用">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 区别:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - owner 个数: Rc&lt;T&gt; 允许数据有多个所有者；Box&lt;T&gt; 和 RefCell&lt;T&gt; 只能允许有单一所有者。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - borrow checker 时期: Box&lt;T&gt; 在编译时执行借用检查；Rc&lt;T&gt;也在编译时执行借用检查；RefCell&lt;T&gt; 允许在运行时执行借用检查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 运行时开销: Cell&lt;T&gt;无运行 时开销，并且永远不会在运行 时引发 panic 错误。 refcell 要在运行时执行借用检查，所以有运行时开销</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 提供内部可变性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  - Cell&lt;T&gt;使用 set/get 方法直接操作包裹的值 (底层是将内部值拷贝出, 修改后在拷贝进去, 适合于实现Copy的类型即复制语义类型)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  - RefCell&lt;T&gt;通过 borrow/borrow_mut 返回 包装过的引用 Ref&lt;T&gt;和 RefMut&lt;T&gt;来操作包裹的值 (适合没有实现Copy的类型, 即移动语义类型。)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果遇到要实现一个同时存在多个不同所有者，但每个所有者又可以随时修改其内容，且这个内容类型 T 没有实现 Copy 的情况该怎么办</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let shared_vec: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(Vec::new()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output: []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{:?}&quot;, shared_vec.borrow());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b = Rc::clone(&amp;shared_vec);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b.borrow_mut().push(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b.borrow_mut().push(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">shared_vec.borrow_mut().push(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output: [1, 2, 3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{:?}&quot;, shared_vec.borrow());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5118-pin-和-unpin">5.11.8. Pin 和 Unpin<a href="#5118-pin-和-unpin" class="hash-link" aria-label="Direct link to 5.11.8. Pin 和 Unpin" title="Direct link to 5.11.8. Pin 和 Unpin">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// 使用 Pin&lt;P&gt; 则代表将数据的内存位置牢牢地“钉”在原地，不让它移动 。(作用的类型是指针) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    是为了解决自我引用的数据结构( 典型如: 内部包含指针 p 和数据 data, p 指向 data)在内存中做地址移动后, p 的值还是原来的值, 但是 data 有了新的地址, 因此整个数据结构就不能使用了, 如在做 swap 操作时容易出现循环引用 (类比 &quot;刻舟求剑&quot;的故事)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 自引用结构有啥用处啊?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 主要是为了支持Rust的异步编程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Unpin 则正好和 Pin 的解药， 代表被“钉”住的数据，可以安全地移动。大多数类型都自动实现了 Unpin。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      若 P 是 !Unpin 类型, Pin&lt;P&gt; 无法 deref_mut, 也就是无法拿到 P 的可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      Unpin 是 auto trait, 会自动实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      impl Future 是 !Unpin 类型, 因为 Future 是典型的 自引用结构 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// tokio 下的 AsyncRead AsyncWrite</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// futures 下的 Stream 和 Sink</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5119-cow-写时复制">5.11.9. Cow 写时复制<a href="#5119-cow-写时复制" class="hash-link" aria-label="Direct link to 5.11.9. Cow 写时复制" title="Direct link to 5.11.9. Cow 写时复制">​</a></h3><p>写时复制( Copy on Write)技术是一种程序中的优化策略, 翻译成人话就是 拖延到需要对数据进行写操作时才复制一份拷贝, 比如 Linux 中父进程创建于进程时 ， 并不是立刻让子进程复制一份进程空间，而是先让子进程共享父进 程的进程空间 ， 只有等到子进程真正需要写入的时候才复制进程空间。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 是一个枚举体的智能指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Borrowed， 用于包裹引用。表示是对数据的借用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Owned， 用于包裹所有者。表示是对数据的拥有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 以不可变的方式访问借用内容，以及在需要可变借用或所有权 的时候再克隆一份数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//旨在减少复制操作，提高性能， 一般用于读多写少的场景</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Cow&lt;T&gt;实现了 Deref， 这意味着可以直接调用其包含数据的不可变 方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - to_mut 方法来获取可变借用. </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      若 T 是 借用, 该方法会产生克隆，但仅克隆一次 ， 如果多次调用，则只会使用第一次的克隆对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      如果 T 本身拥有所有权，则此时调用 to_mut不会发生克隆. 所有权转移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// into_owned方法来获取一个拥有所有权的对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      若 T 是借用, 发生克隆，井创建新的所有权对 象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      如果 T 是所有权对象， 则会将所有权转移到新的克隆对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::borrow::Cow;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 求元素绝对值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn abs_all(input: &amp;mut Cow&lt;[i32]&gt;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in 0..input.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let v = input[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if v &lt; 0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //to_mut 方法会在第一次调用时克隆一个新的对象，在后续的 for 循环中 继续用新的克隆对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            input.to_mut()[i] = -v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 求和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn abs_sum(ns: &amp;[i32]) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut lst = Cow::from(ns);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    abs_all(&amp;mut lst);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lst.iter().fold(0, |acc, &amp;n| acc + n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s1 = [1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i1 = Cow::from(&amp;s1[..]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // i1 中的元素都为正, 不会进入if逻辑, 不涉及到可变需求，所以不会克隆</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    abs_all(&amp;mut i1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;IN: {:?}&quot;, s1);//1,2,3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;OUT: {:?}&quot;, i1);//1,2,3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s2 = [1,2,3, -45, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i2 = Cow::from(&amp;s2[..]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里有可变需求，且穿进cow 的数据是个引用, 没有所有权, 所以会克隆, i2 实际是克隆出的新对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    abs_all(&amp;mut i2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;IN: {:?}&quot;, s2);//[1, 2, 3, -45, 5]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;OUT: {:?}&quot;, i2);//[1, 2, 3, 45, 5]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里不会克隆，因为数据本身拥有所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v1 = Cow::from(vec![1,2,-3,4]);//v1是本身就是可变的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    abs_all(&amp;mut v1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;IN/OUT: {:?}&quot;, v1);//[1, 2, 3, 4]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 另一个用处是统一实现规范</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::borrow::Cow;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Token&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    raw: Cow&lt;&#x27;a, str&gt;,//该用&amp;str类型还是 String类型呢?为了寻求统一，这里使用了 Cow&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a&gt; Token&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn new&lt;S&gt;(raw: S) -&gt; Token&lt;&#x27;a&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        S: Into&lt;Cow&lt;&#x27;a, str&gt;&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Token { raw: raw.into() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let token = Token::new(&quot;abc123&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let token = Token::new(&quot;api.example.io&quot;.to_string());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 还可以跨线程安全传递</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   thread::spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       println!(&quot;token: {:?}&quot;, token);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }).join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    使用动态字符串切片，则会因为生命周期的问题而无法跨线程安全传递</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let raw = String::from(&quot;abc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = &amp;raw[..];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let token = Token::new(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    thread::spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;token: {:?}&quot;, token);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }).join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="512-函数">5.12. 函数<a href="#512-函数" class="hash-link" aria-label="Direct link to 5.12. 函数" title="Direct link to 5.12. 函数">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5121-函数基本语法">5.12.1. 函数基本语法<a href="#5121-函数基本语法" class="hash-link" aria-label="Direct link to 5.12.1. 函数基本语法" title="Direct link to 5.12.1. 函数基本语法">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// 如果不指定返回值类型, 默认 返回类型为 () 空元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 同名函数在存在于多个作用域(比如 main 外, main 内, main 内的新作用域 分别有三个同名函数), 会发生屏蔽</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn sum(aa: i8, bb: i8) -&gt; i8 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回值明确指定类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若带 return, 就是语句, 需要分号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // return aa +bb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 不带 return, 就是表达式, 没有分号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    aa + bb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let sum = sum(3, 9);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;sum = {}&quot;, sum);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 函数参数支持模式匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn a(mut b: [i32; 2]) { // 参数为数组可变类型, 不是引用类型 (mut 无法放在冒号后面)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5122-函数体表达式">5.12.2. 函数体表达式<a href="#5122-函数体表达式" class="hash-link" aria-label="Direct link to 5.12.2. 函数体表达式" title="Direct link to 5.12.2. 函数体表达式">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let x = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 函数体表达式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 块末尾是表达式, 不是语句, 没有分号, 没有 return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // return x + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;x = {}&quot;, x); //1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;b = {}&quot;, b); //3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5123-函数作为参数">5.12.3. 函数作为参数<a href="#5123-函数作为参数" class="hash-link" aria-label="Direct link to 5.12.3. 函数作为参数" title="Direct link to 5.12.3. 函数作为参数">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 函数作为参数传递</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn inc1(num: i32) -&gt; i32 { num + 1}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn print_num(num: i32, func: fn(i32) -&gt;i32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, func(num));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print_num(1, inc1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// mut 参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里形式参数类型并非引用, 所以传入实际参数时, 会转移所有权, 实际参数是不是 mut 都可以</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn modify (mut v: Vec&lt;u32&gt; ) - &gt; Vec&lt;u32&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里形参为引用, 所以实际参数必须为 &amp; mut</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn modify(v: &amp;mut [u32]) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 函数参数支持模式匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// (函数中的参数等价于一个隐式的 let绑定，而 let绑定本身是一个模式匹配的行为)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S { i: i32 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//表示 参数为不可变引用, 相对的, ref mut 表示参数为可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn f(ref _s: S) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:p}&quot;, _s); //0x7ffdd1364b80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = S { i: 42 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // error, 所有权转移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 利用了模式匹配来解构元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn swap((x, y) : (&amp;str, i32)) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5124-result-返回值">5.12.4. Result 返回值<a href="#5124-result-返回值" class="hash-link" aria-label="Direct link to 5.12.4. Result 返回值" title="Direct link to 5.12.4. Result 返回值">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 即便是没有显式返回值的函数，其实 也相当于返回了一个单元值()。如果需要返回多个值，亦可使用元组类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 函数返回值 Result&lt;T, E&gt; 见 error_handling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5125-编译期函数执行-cfe">5.12.5. 编译期函数执行 cfe<a href="#5125-编译期函数执行-cfe" class="hash-link" aria-label="Direct link to 5.12.5. 编译期函数执行 cfe" title="Direct link to 5.12.5. 编译期函数执行 cfe">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 编译时函数执行, 简称 cfe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //函数会在编译期被执行, 计算出常量结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const fn const_fn() -&gt; u8 {2};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr = [0u8, const_fn()];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5126-发散函数">5.12.6. 发散函数<a href="#5126-发散函数" class="hash-link" aria-label="Direct link to 5.12.6. 发散函数" title="Direct link to 5.12.6. 发散函数">​</a></h3><p>感叹号 惊叹号</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 发散函数: 返回值类型为 &quot;!&quot; (never type), 标识函数永远不会返回值, 比如 函数包含死循环, 或者 panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     发散函数可以作为任何类型. 应用:可以在正常有返回值函数中 panic, 在if 判断中 panic (因为 panic 返回类型为 never type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     https://www.zhihu.com/question/54540714/answer/146231560</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5127-泛型函数">5.12.7. 泛型函数<a href="#5127-泛型函数" class="hash-link" aria-label="Direct link to 5.12.7. 泛型函数" title="Direct link to 5.12.7. 泛型函数">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//调用时, 编译器来进行自动推断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 无法自动推断, 则需要显式指定, 如为接收的变量指定类型, 或者方法调用的时候, 使用 turbofish操作符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let a: i32 = square(37 , 41) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let a= square::&lt;u32&gt;(37, 41)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5128-高阶函数">5.12.8. 高阶函数<a href="#5128-高阶函数" class="hash-link" aria-label="Direct link to 5.12.8. 高阶函数" title="Direct link to 5.12.8. 高阶函数">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51281-函数指针">5.12.8.1. 函数指针<a href="#51281-函数指针" class="hash-link" aria-label="Direct link to 5.12.8.1. 函数指针" title="Direct link to 5.12.8.1. 函数指针">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 函数指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 函数可以作为参数进行传递</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实现这一切的基础在于 Rust支持类似 CIC++语言中的函数指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn math(op: fn(i32, i32) -&gt; i32, a: i32, b: i32) -&gt; i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn hello(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;hello function pointer&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 必须显式指定函数指针类型 fn()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let fn_ptr: fn() = hello;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:p}&quot;, fn_ptr); // 0x562bacfb9f80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若没指定函数指针类型, 就不是指针, other_fn 的类型实际上是 fn() {hello}，这其实是函数 hello 本身的类型，而非函数指针类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let other_fn = hello;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:p}&quot;, other_fn);  // not function pointer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hello();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   other_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   fn_ptr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   (fn_ptr)();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于函数指针类型，可以使用 type 关键字为其定义别名 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type MathOp = fn (i32 ， i32) - &gt; i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn math(op: MathOp, a: i32, b: i32) -&gt; i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn math(op: &amp;str) -&gt; MathOp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51282-禁止函数捕获外部环境中变量">5.12.8.2. 禁止函数捕获外部环境中变量<a href="#51282-禁止函数捕获外部环境中变量" class="hash-link" aria-label="Direct link to 5.12.8.2. 禁止函数捕获外部环境中变量" title="Direct link to 5.12.8.2. 禁止函数捕获外部环境中变量">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// error, // 因为函数不能捕捉动态环境中的变量i, 变量 绑定 i 会随着帧的释放而释放，需要闭包才可以捕获</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn counter(i: i32) -&gt; fn(i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn inc(n: i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n + i  // error[E0434]: can&#x27;t capture dynamic environment in a fn item</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = counter(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(3, f(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 正确, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn counter() -&gt; fn(i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn inc(n: i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        n + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = counter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(2, f(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 若果一定要捕获环境变量, 需要闭包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2015 edition:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn counter(i: i32) -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {//放到了 Box&lt;T&gt;中， 因为闭包的大 小在编译期是未知的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box::new(move |n: i32| n + i )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// or 2018:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 以大写字母 F 开头的 Fn 并不是函数指针类型 Fn(i32)-&gt;i32， 它是一个trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn counter(i: i32) -&gt; impl Fn(i32) -&gt; i32 {//动态大小类型  impl Trait, 这样就不需要使用 Box&lt;T&gt;了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    move |n: i32|{ n + i }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="513-闭包">5.13. 闭包<a href="#513-闭包" class="hash-link" aria-label="Direct link to 5.13. 闭包" title="Direct link to 5.13. 闭包">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5131-闭包基本使用">5.13.1. 闭包基本使用<a href="#5131-闭包基本使用" class="hash-link" aria-label="Direct link to 5.13.1. 闭包基本使用" title="Direct link to 5.13.1. 闭包基本使用">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">///闭包 (匿名函数): 是一个持有外部环境变量的函数。 外部环境是指闭包定义时所在的词法作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 延迟执行 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 捕获环境变量 。闭包会获取其定义时所在作用域中的自由变 量 ，以供之后调用时使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 两个定义一模一样的闭包 也并不一定属于同 一种类型, 无法将它们保存到一个数组中。因为数组只能保 存相同类型的元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn closure_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;------------------------ closure demo&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let inc = |num: i32| -&gt; i32 { ////返回值类型推导: 无论后面是否被调用, 返回值都可省略, 但是无法两次推导不同的参数/返回值类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        num + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // num 的参数类型可以省略, 返回值类型可以省略, 花括号可以省略; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这是因为后面 print_num 函数中已经有类型信息了, 单独定义闭包, 没有后面的调用信息, 则参数类型不能省</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let inc0 = |num| num+1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn inc1(num: i32) -&gt; i32 { num + 1} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 函数作为参数传递</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn print_num(num: i32, func: fn(i32) -&gt;i32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, func(num));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print_num(1, inc1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print_num(1, inc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print_num(1, inc0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5132-rust-实现闭包的原理">5.13.2. rust 实现闭包的原理<a href="#5132-rust-实现闭包的原理" class="hash-link" aria-label="Direct link to 5.13.2. rust 实现闭包的原理" title="Direct link to 5.13.2. rust 实现闭包的原理">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 在 Rust 中，闭包是一种语法糖, 是在基本语法功能之上又提供的一层方便开发者编程的语法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 最初闭包是通过  装箱( Boxed) 闭包 实现的, 性能差, LLVM 难以对其进行内联和优化。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如: 闭包 || {a+b} 的实现可以通过函数指针 和捕获变量指针组合来实现。指针放stack上，捕获变量放到堆上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 非装箱 CUnboxed) 闭包 (现在的实现方式): 支持闭包按值和按引用绑定环境变量 ; 支持三种不同的闭包访问， 对应 self、&amp;self和&amp;mut self三种方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 将函数调用抽象为三种, 新增三个 trait 表示</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这样, 方法调用 a(b, c, d)变为一下三种执行方式:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Fn::call(&amp;a, (b, c, d))          - 调用 参数为 &amp;self， 这意味着它会对方法接收者进行不可变借用 ，也就是说，这种方法调用可以被调用多次。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// FnMut::callmut(&amp;muta, (b, c, d)) - 调用参数为&amp; mut self，这意味着它会对方法接收者进行可变借用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// FnOnce::call once(a, (b, c, d)) - 调用参数为 self，这意味着它会转移方法接收者的所有权。换句话说，就是这 种方法调用只能被调用 一次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 现在实现闭包就简单了, 直接定义一个 struct 表示 闭包, 内部使用一个字段表示捕获的自由变量, 在调用的时候使用这个变量即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实际上, 闭包表达式会由编译器自动翻译为结构体实例，并为其实现 Fn、FnMut、FnOnce三个 trait 中的 一个</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 手动实现如下:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#![feature(unboxed_closures, fn_traits)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Closure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    env_var: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl FnOnce&lt;()&gt; for Closure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Output = u32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将函数参数中的元 组类型做动态扩展，以便支持可变长参数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因为在 Fn、 FnMut、 FnOnce 这三个 trait 里的方 法要接收闭包的参数，而编译器本身并不可能知道开发者给闭包设定的参数个数，所以这里 只能传元组，然后由 rust-callABI在底层做动态扩展</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 需要 unboxed closures特性支持</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    extern &quot;rust-call&quot; fn call_once(self, args: ()) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;call it FnOnce()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.env_var + 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl FnMut&lt;()&gt; for Closure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: ()) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;call it FnMut()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.env_var + 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Fn&lt;()&gt; for Closure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    extern &quot;rust-call&quot; fn call(&amp;self, args: ()) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;call it Fn()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.env_var + 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let env_var = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut c = Closure { env_var: env_var };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 结构体实例可以像函数那样被调用, 因为 定义方法时候, 使用了 extern 关键字，表示使用指定的 ABI (Application Binary Interface， 程 序二进制接口)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c.call(());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c.call_mut(());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c.call_once(());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5133-捕获环境变量-and-三种闭包类型">5.13.3. 捕获环境变量 and 三种闭包类型<a href="#5133-捕获环境变量-and-三种闭包类型" class="hash-link" aria-label="Direct link to 5.13.3. 捕获环境变量 and 三种闭包类型" title="Direct link to 5.13.3. 捕获环境变量 and 三种闭包类型">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// 闭包中可以捕获外部环境中的变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //捕获环境变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 有三种方式, 根据捕获变量方式不同, 将闭包定义为三种 trait:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Fn，表示闭包以不可变借用的方式来捕获环境中的自由变 量 ，同时也表示 该闭 包没有 改变环境的能力 ， 并且可以多次调用。闭包接收者是不可变引用, 对应 &amp;self。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                  等号右侧闭包表达式  没加 move, 内部无写操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //              未捕获任何环境变量的闭包会自动实现 Fn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //              捕获的自由变量若为复制语义类型, 则闭包实现了 Fn (不需要对外部变量进行写操作)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //              使用 move 关键字则自动实现 Fn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // FnMut，表示闭包以可变借用的方式来捕获环境中的自由变 量 ，同时意味 着该 闭包有 改变环境的能力 ，也可以 多次 调用 。 闭包接收者是可变引用, 对应&amp;mut self。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                      没加 move, 内部有写操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                     修改环境变量以自动实现 FnMut</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // FnOnce， 表示闭包通过转移所有权来捕获环境中的自由变量，同时意味着该闭包没 有改变环境的能力，只能调用一次，因为该闭包会消耗自身。闭包接收者是值, 并非引用, 对应 self。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                      加了 move</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //              由于所有所有闭包都可以至少调用一次, 所以涉及到捕获环境变量 的所有闭包都实现了 FnOnce </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 三种 trait 包含关系: fn 属于(继承于) fnmut 属于(继承于) fnonce;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ，如果要实现 Fn， 就必须实现 FnMut和 FnOnce;如果要实现 FnMut, 就必须实现 FnOnce; 如果只需要实现 FnOnce， 就不需要实现 FnMut 和 Fn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 闭包捕获其环境变量的方式:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对于复制语义类型 ，若 表达式加了 move , 以 copy 的形式进行捕获</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //                  若未加 move, 以 引用/可变引用 的形式进行捕获</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对于移动语义类型 ，转移所有权来进行捕获 (无论加没加 move)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //              移动语义类型自动实现了 FnOnce</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对于可变绑定，并且在闭包中包含对其进行修改的操 作，则以可 变引用 (&amp;mut T) 来进行捕获 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 修改了 自由变量, 没加 move, 闭包为 FnMut, 需要声明为 可变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut func =  || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i+=1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    func();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, i);//2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut plus_one = move || {// move 可选, 涉及到多线程并发, 一定要加 move, i 所有权移动到闭包, 对于基本类型, 相当于复制了一份, 在闭包内的操作不影响外部的 i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i += 1;                // 但是  , 若有返回值, 就变为复制引用了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    plus_one(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;i = {}&quot;, i); //1,  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 对于复杂类型的 捕获</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = vec![1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let eq = move |x| x==v; // v的所有权移动到了闭包内部, 外部的 v 失效了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;eq? {}&quot;, eq(vec![1,2,3]));//true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;v = {:?}&quot;, v);// 错误, borrow of moved value: `v`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 更多示例对比</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut i = 11;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 没有 move, 闭包内部是 引用, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut fu1 = || i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fu1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, i) //12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//-----------Move的情况----------- (对于基本类型, 实现了 copy trait, 是 copy, 对于 符合类型, 若没有实现 copy trait, 则所有权转移)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 存在 move, 闭包内是复制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut fu1 = move || i += 1; // 局部变量被丢弃</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fu1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, i);//11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 存在返回值的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut fu = || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fu();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, i)//12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//-----------Move的情况-----------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut fu = move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fu();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, i)//11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//对于没有实现 Copy 的 复合类型，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在闭包中可以调用其方法，是“借用”，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 存在返回值, 返回值了就发生所有权转移, 因为 返回值有可能在别的地方使用, 为了安全, 所有权转移了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let s = String::from(&quot;coolshell&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let take_str = || s; // 移动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, s); //ERROR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;,  take_str()); // OK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut s1 = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut change_s1 = || s1.push(&#x27;!&#x27;);// 没有返回值, 不会移走, 只会可变借用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, s1);// error, 单独出现没错, 但是和下面函数调用一起出现出错了, 可变借用后, 没法进行不可变借用了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">change_s1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, s1);// hello!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    age: u8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let p = Person{name: &quot;xiaoyu&quot;.to_string(), age: 11};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let age = |p: Person| p.age; // 存在返回值, 所有权移动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, age(p));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let name = |p: Person| p.name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, name(p));// name(p)编译错误, p 丢失所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 改为 引用版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于 基本类型 的属性, 存在 copy trait, 返回的是 copy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let age = |p: &amp;Person| p.age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 现在可以重复使用了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, age(&amp;p));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, age(&amp;p));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 错误, 因为name 为 string 类型, 没有 copy trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 函数结束, p.name 被释放, 出错, 若存在 copy trait, 会返回 复制, 没有 copy trait, 只能通过返回引用解决</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let name = |p: &amp;People| p.name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 解决: 生命周期, 延缓 p.name  被释放的时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let name: for &lt;&#x27;a&gt; fn(&amp;&#x27;a Person) -&gt; &amp;&#x27;a String = |p: &amp;Person| &amp; p.name;// 闭包返回值必须为引用, 不能把 name move 走</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//or ; 参数类型省略了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let name: for&lt;&#x27;a&gt; fn(&amp;&#x27;a People) -&gt; &amp;&#x27;a String = |p| &amp;p.name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5134-闭包作为返回值-or-参数">5.13.4. 闭包作为返回值 or 参数<a href="#5134-闭包作为返回值-or-参数" class="hash-link" aria-label="Direct link to 5.13.4. 闭包作为返回值 or 参数" title="Direct link to 5.13.4. 闭包作为返回值 or 参数">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51341-逃逸闭包-非逃逸闭包">5.13.4.1. 逃逸闭包 非逃逸闭包<a href="#51341-逃逸闭包-非逃逸闭包" class="hash-link" aria-label="Direct link to 5.13.4.1. 逃逸闭包 非逃逸闭包" title="Direct link to 5.13.4.1. 逃逸闭包 非逃逸闭包">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Box&lt;Fn()&gt;是一个 trait对象, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// trait对象是动态分发的，在运行时通过查找虚表( vtable〕来确定调用哪个闭包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn boxed_closure(c: &amp;mut Vec&lt;Box&lt;Fn()&gt;&gt;){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = &quot;second&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c.push(Box::new(|| println!(&quot;first&quot;)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 需要将 s copy 一份, 在方法外使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c.push(Box::new(move || println!(&quot;{}&quot;, s)));//逃逸闭包 (escapeclosure): 在函数栈帧结束后才使用的闭包, 如果是跟随函数一起调用的闭包， 则 是非逃逸闭包 (non-escape closure)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c.push(Box::new(|| println!(&quot;third&quot;)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut c: Vec&lt;Box&lt;Fn()&gt;&gt; = vec![];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boxed_closure(&amp;mut c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for f in c {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        f(); // first / second / third</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51342-闭包作为参数">5.13.4.2. 闭包作为参数<a href="#51342-闭包作为参数" class="hash-link" aria-label="Direct link to 5.13.4.2. 闭包作为参数" title="Direct link to 5.13.4.2. 闭包作为参数">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 实现 vec.any 条件匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 通过泛型, 实现静态分发</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::ops::Fn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Any {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn any&lt;F&gt;(&amp;self,  f: F) -&gt; bool where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Self: Sized,//当Any被作为 trait 对象使用时，该方法不能被动态调用, 只能静态分发，这属于一种优化策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        F: Fn(u32) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Any for Vec&lt;u32&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn any&lt;F&gt;(&amp;self, f: F) -&gt; bool where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Self: Sized,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   F: Fn(u32) -&gt; bool</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       for &amp;x in self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           if f(x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let  v = vec![1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b = v.any(|x| x == 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 通过将闭包作为 trait 对象的方式, 实现动态分发</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 代码更加简练, 动态分发比静态分发的性能 低 一些, 但完全可以接受</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Any {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  fn any(&amp;self,  f: &amp;(Fn(u32) -&gt; bool)) -&gt; bool;// &amp;(Fn(u32) -&gt; bool) 即为 trait object</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Any for Vec&lt;u32&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn any(&amp;self, f: &amp;(Fn(u32) -&gt; bool)) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for &amp;x in self.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if f(x) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let  v = vec![1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let b = v.any(&amp;|x| x == 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   println!(&quot;{:?}&quot;, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51343-闭包作为返回值">5.13.4.3. 闭包作为返回值<a href="#51343-闭包作为返回值" class="hash-link" aria-label="Direct link to 5.13.4.3. 闭包作为返回值" title="Direct link to 5.13.4.3. 闭包作为返回值">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 作为返回值, 必须使用 trait对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn square() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box::new(|i| i*i )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于编译期无法确定大小的值，不能移动其所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果要调用闭包 Box&lt;Fn0nce(i32)-&gt;i32&gt;， 就必须先把 Fn0nce(i32)-&gt;i32 从 Box&lt;T&gt;中移出 来。而此时 Box&lt;T&gt;中的 T无法在编译期确定大小，不能移动所有权，所以就报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn square() -&gt; Box&lt;FnOnce(i32) -&gt; i32&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box::new( |i| {i*i })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 正确</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 impl trait 的方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn square() -&gt; impl FnOnce(i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |i| {i*i }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//返回的闭包还必须使用 move 关键字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          它表明闭包内所有的捕获都是通过值进行的(是一份拷贝, 是安全独立的)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          因为若果没有 move, 闭包是按引用捕获变量，函数结束, 闭包将引用返回, 但是引用指向的数据将被释放, 在闭包中留下无效的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn create_fn() -&gt; impl Fn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let text = &quot;Fn&quot;.to_owned();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    move || println!(&quot;This is a: {}&quot;, text)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn create_fnmut() -&gt; impl FnMut() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let text = &quot;FnMut&quot;.to_owned();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    move || println!(&quot;This is a: {}&quot;, text)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let fn_plain = create_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut fn_mut = create_fnmut();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn_plain();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn_mut();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51344-闭包参数中的生命周期">5.13.4.4. 闭包参数中的生命周期<a href="#51344-闭包参数中的生命周期" class="hash-link" aria-label="Direct link to 5.13.4.4. 闭包参数中的生命周期" title="Direct link to 5.13.4.4. 闭包参数中的生命周期">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait DoSomething&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn do_sth(&amp;self, value: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 为&amp;usize类型实现了该 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a, T: Debug&gt; DoSomething&lt;T&gt; for &amp;&#x27;a usize {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn do_sth(&amp;self, value: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{:?}&quot;, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 泛型 trait 作为 trait object时需要标注生命周期参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里生命周期参数让编译器误解: 把 foo 的生命周期和内部 s 的生命周期关联起来, 即在 foo()调用的 生命周期内, s 必须始终有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//然而 b 内部的 &amp;usize引用 本来应该和 foo 函数没有任何关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn foo&lt;&#x27;a&gt;(b: Box&lt;DoSomething&lt;&amp;&#x27;a usize&gt;&gt;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s: usize = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // s 在 foo 函数调用结束后就会被析构，从而&amp;s就会变 成悬垂指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b.do_sth(&amp;s) // error[E0597]: `s` does not live long enough</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 正确</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 高阶生命周期 (Higher-Ranked Lifetime)语法: for&lt;&#x27;f&gt; , 表示此生命周期参数只针对其后面所跟 着 的“对象&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里在 box 内部声明一个周期注释, 标注 &amp;usize, 和 外层的bar 函数无关</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn bar(b: Box&lt;for&lt;&#x27;f&gt; DoSomething&lt;&amp;&#x27;f usize&gt;&gt;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s: usize = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b.do_sth(&amp;s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x  = Box::new(&amp;2usize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    foo(x); // 相当于 let _a = foo(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bar(x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 模拟闭包的行为</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Pick&lt;F&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data: (u32, u32),// 存储闭包参数 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    func: F, // 存储逻辑行为</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;F&gt; Pick&lt;F&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // trait限定中使用了 引用类型, 编译器自动为其补齐了生命周期参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where F: Fn(&amp;(u32, u32)) -&gt; &amp;u32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 显式指定周期参数:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where F: for&lt;&#x27;f&gt; Fn(&amp;&#x27;f (u32, u32)) -&gt; &amp;&#x27;f u32, // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 生命周期参数可省略    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn call(&amp;self) -&gt; &amp;u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (self.func)(&amp;self.data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若要添加周期参数, 这种是错误的:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn call&lt;&#x27;a&gt;(&amp;’a self)一〉&amp;’a u32, //不能让 call方法自身的生命周期和 self.func方法的生命周期相关联, 因为闭包 的捕获引用是从外部环境获取的，和 call 方法没有关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn max(data: &amp;(u32, u32)) -&gt; &amp;u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if data.0 &gt; data.1{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;data.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;data.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let elm = Pick { data: (3, 1), func: max };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   println!(&quot;{}&quot;, elm.call());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5135-迭代器">5.13.5. 迭代器<a href="#5135-迭代器" class="hash-link" aria-label="Direct link to 5.13.5. 迭代器" title="Direct link to 5.13.5. 迭代器">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51351-什么是迭代器">5.13.5.1. 什么是迭代器<a href="#51351-什么是迭代器" class="hash-link" aria-label="Direct link to 5.13.5.1. 什么是迭代器" title="Direct link to 5.13.5.1. 什么是迭代器">​</a></h4><p>闭包最常见的应用场景是， 在遍历集合容器中的元素的同时，按闭包内 指定的逻辑进行操作, 即迭代器</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 迭代器是惰性的, 调用方法使用迭代器前, 不会有任何效果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 每个迭代器都实现 Iterator trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// trait Iterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     // 这里为什么不使用 泛型呢? 若用泛型语法, 会造成这样的结果: 使用者可以通过泛型, 为一个 struct 实现多种 Iterator trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     // 调用时, 编译器无法知道使用哪个 trait 实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     type Item;// 关联元素类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     // 需要实现的方法 (要包含两个要点: 1. 到达某个条件返回 none; 2. 返回 cur; 3. 计算下一步的值, 赋给 cur)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// for 结构会使用 .into_iterator() 方法将一些集合类型 转换为迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 外部迭代器 (External Iterator): 在容器外部, 可以控制整个迭代过程 (如手动调用 next() 获取下一个元素)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 内部迭代器 (internal Iterator):通过迭代器自身来控制迭代下一个元素，外部无法干预, 一旦开始, 必须全部迭代完毕才能结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 外部迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = vec![1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // for循环是一个典型的外部迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 其实是一个语法糖, 底层实现是 into_iter方法声明了一个可变迭代器 iterator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in v {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 等价于</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = vec![1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {  // 等价于for循环的scope</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut _iterator = v.into_iter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            match _iterator.next() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Some(i) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    println!(&quot;{}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               None =&gt; break,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Stepper {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cur: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    step: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    max: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Iterator for Stepper {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Item = i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.cur &gt; self.max {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return None;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let resp = self.cur;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.cur += self.step;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(resp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let stepper = Stepper {cur: 0, step: 1, max: 9};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stepper.into_iter().for_each(|it| println!(&quot;{}&quot;, it)); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 自定义内部迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait InIterator&lt;T: Copy&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn each&lt;F: Fn(T) -&gt; T&gt;(&amp;mut self, f: F);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Copy&gt; InIterator&lt;T&gt; for Vec&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn each&lt;F: Fn(T) -&gt; T&gt;(&amp;mut self, f: F) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while i &lt; self.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self[i] = f(self[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v = vec![1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.each(|i| i * 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!([3, 6, 9], &amp;v[..3]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51352-iterator-trait">5.13.5.2. Iterator trait<a href="#51352-iterator-trait" class="hash-link" aria-label="Direct link to 5.13.5.2. Iterator trait" title="Direct link to 5.13.5.2. Iterator trait">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn iter_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 获取迭代器时, 根据对源容器的处理, 可以分为几类迭代器:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Intolter，转移所有权，对应 self。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Iter， 获得不可变借用 ， 对应&amp;self。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - IterMut，获得可变借用，对应&amp; mut self。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Iter和 IterMut迭代器的典型应用就是 slice </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 特殊的: Drain 迭代器, String类型和 HashMap 特有, 可以迭代删除指定范围内的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 相应的就有多个获取迭代器的方法:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// iter() 迭代出引用, 迭代出的类型为 &amp;T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// iter_mut() 迭代出可变引用, 类型为  &amp;mut T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// into_iter() 迭代出值, 不是引用, 原始数据源的元素所有权变更 (推荐)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//size_hint() (usize, Option&lt;usize&gt;)，此元组表示迭代器剩余长度的边界信息, 元素 1: 下限, 元素 2: 上限, 默认返回 (0, None)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//       用来和容器合作时, 精确的拓展容器容量, 从而避免不必要的容量检查，提高性能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          对于数组, 上下限是相同的, 代表迭代器当前指针到末尾指针的距离</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v = vec![1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for ele in v.iter() { //等同于</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, ele);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 迭代出的类型为 &amp;i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut it = v.iter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _ in 0..3 {//`for` 遍历 `Iterator` 直到返回 `None`，每个 `Some` 值都被解包（unwrap），然后绑定给一个变量, 这里是 &quot;_&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, it.next().unwrap());// 需要 it 可变, 解引用可省略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 迭代出可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut it_mut = v.iter_mut();// 需要 v 为 可变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ele_first = it_mut.next().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *ele_first = 100; // 需要写操作, 先解引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;v = {:?}&quot;, v); // [100,2,3]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 迭代器的上下限, 表示</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a : [i32; 3]= [1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut iter = a.iter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!((3, Some(3)), iter.size_hint());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    iter.next();//的剩余长度就会减少， 直到减为 0为止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!((2, Some(2)), iter.size_hint());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用迭代器追加字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut message = &quot;Hello&quot;.to_string(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    message . extend (&amp;[&#x27; &#x27;, &#x27;R&#x27;, &#x27;u&#x27;, &#x27;s&#x27;, &#x27;t&#x27;]) ; // 这个方法里面就用到了 size_hint 用于 String 扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq ! (” Hello Rust” ,&amp; message );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Intolterator trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr = [1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 并没有为[T]类型实现 IntoIterator，需要调用 iter() 生成迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in arr.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, *i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 为&amp;’a [T]和&amp;’a mut [T]类型实现 了 Intoiterator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in &amp;arr {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, *i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 求和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let total: i32 = v.iter().sum();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;total = {}&quot;, total);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `take(n)` 方法提取 `Iterator` 的前 `n` 项。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `skip(n)` 方法移除前 `n` 项，从而缩短了 `Iterator` </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51353-迭代器适配器-收集器-函数式风格">5.13.5.3. 迭代器适配器 收集器 函数式风格<a href="#51353-迭代器适配器-收集器-函数式风格" class="hash-link" aria-label="Direct link to 5.13.5.3. 迭代器适配器 收集器 函数式风格" title="Direct link to 5.13.5.3. 迭代器适配器 收集器 函数式风格">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 迭代器的适配器, 适配器都会返回新的集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • Map，通过对原始注代器中的每个元素调用指定 闭包来产生一个新的迭代器。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • Chain，通过连接两个迭代器来创建一个新的迭代器。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • Cloned，通过拷贝原始迭代器中全部元素来创建新的迭代器。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • Cycle，创建一个永远循环迭代的迭代器，当完毕后 ，再返回第一个元素开始法代。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • Enumerate，创建一个包含计数的迭代器，它会返回 一个元组(i,val)， 其中 i 是 usize 类型 ，为迭代的 当前索 引， val 是迭代器返回 的值 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • Filter，创建一个基于谓词判断式( predicate，产生布尔值的表达式)过滤元素的迭代器 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • FlatMap，创建一个类似 Map 的结构的法代器，但是其中不会含有任何嵌套。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • FilterMap，相当于 Filter和 Map两个法代器依次使用后的效果。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • Fuse，创建一个可 以快速结束遍历 的迭代器。在遍历迭代器时，只 要返回过一次 None,那么之后所有的遍历结果都为 None。该迭代器适配器可以用于优化。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // • Rev，创 建一 个可以反向遍历的迭代器 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // map, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Map是一个泛型结构体，它只有两个成员字段，一个是iter， 一个f， 分别存 储的是迭代器和传入的闭包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实现了 Iterator trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = [1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut iter =a.into_iter() .map(|x| 2 * x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr1 = [1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c1 = arr1.iter().map(|x| 2 * x).collect::&lt;Vec&lt;i32&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(&amp;c1[..], [2, 4, 6, 8, 10]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr2 = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;h&quot;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c2 = arr2.iter().filter_map(|x| x.parse().ok()).collect::&lt;Vec&lt;i32&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(&amp;c2[..], [1,2,3]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr3 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for (idx, val) in arr3.iter().enumerate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       println!(&quot;idx: {:?}, val: {}&quot;, idx, val.to_uppercase());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = vec![1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let scaled : Vec&lt;i32&gt; = v.iter().map(|&amp;x| x * 10).collect(); // 返回新的 vec, 原始 vec 不受影响, x 不加&amp;亦可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;scaled = {:?}&quot;, scaled);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let scaled1: Vec&lt;_&gt; = v.iter_mut().map(|&amp;mut x| x* 10).collect(); //等效, 返回新的 vec, 不改变原始 v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;scaled1 = {:?}&quot;, scaled1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;v = {:?}&quot;,v);//不变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let plused: Vec&lt;_&gt; = scaled.into_iter().map(|x| x +1).collect();// 获取scaled 所有权,  直接在原始值上修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;plused = {:?}&quot;, plused);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // filter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let filtered: Vec&lt;_&gt; = v.into_iter().filter(|&amp;x| x &gt; 3).collect();// 直接在原始 vec 上修改, v 所有权失效 // 存疑, 为什么需要 &amp;x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;filtered = {:?}&quot;, filtered); // [100]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;v = {:?}&quot;, v); // 错误, into_iter() 使得 v 失去值得所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 逆序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut iter= a.iter().rev()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    iter.next();//从反向开始迭代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过 普通迭代器的 next_back() 方法反向迭代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // next() 和 next_back() 有各自独立的指针, 互不影响, 但是当指针相遇时, 就迭代不出值了, 返回 none</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 收集器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // any 谓词, 判断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 闭包参数为 引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = vec![1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let contain = v.iter().any(|&amp;x| x == 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;contains 2?  : {}&quot;, contain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let contain = v.into_iter().any(|x| x == 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;contains 3?  : {}&quot;, contain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = [1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(a.iter().any(|&amp;x| x != 2), true);// 存在不为 2 的元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr = [1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result1 = arr.iter().any(|&amp;x| x != 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result2 = arr.iter().any(|x| *x != 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // error:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // the trait bound `&amp;{integer}: std::cmp::PartialEq&lt;{integer}&gt;` is not satisfied</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result2 = arr.iter().any(|x| x != 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(result1, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(result2, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fold</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 闭包参数为引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr = vec![1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sum1 = arr.iter().fold(0, |acc, x| acc + x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sum2 = arr.iter().fold(0, |acc, x| acc + *x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sum3 = arr.iter().fold(0, |acc, &amp;x| acc + x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sum4 = arr.into_iter().fold(0, |acc, x| acc + x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(sum1, 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(sum2, 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(sum3, 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   assert_eq!(sum4, 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // find 查找</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = vec![1,2,3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let find2 = v.iter().find(|&amp;&amp;x| x == 2).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;find2 = {}&quot;, find2);//2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let find3 = v.into_iter().find(|&amp;x| x == 3).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;find2 = {}, find3 = {}&quot;, find2, find3);// 出错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;find3 = {}&quot;, find3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 函数式风格</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let upper = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sum: u32 =(0..).map(|n| n * n)             // 所有自然数取平方</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             .take_while(|&amp;n| n &lt; upper) // 取小于上限的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             .filter(|&amp;n| is_odd(n))     // 取奇数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             .fold(0, |sum, i| sum + i); // 最后加起来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;sum = {}&quot;, sum);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 处理迭代中的错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let possible_numbers: Vec&lt;_&gt; = strings</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .into_iter()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(|s| s.parse::&lt;i32&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .filter_map(Result::ok) // 过滤出成功的result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Results: {:?}&quot;, possible_numbers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 另外的处理方式:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //Result 实现了 FromIter, Vec&lt;Result&lt;T, E&gt;&gt;可以转为 Result&lt;Vec&lt;T&gt;, E&gt;, 一旦找到一个 Result::Err ，遍历就被终止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .into_iter()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(|s| s.parse::&lt;i32&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Results: {:?}&quot;, numbers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //分组收集</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .into_iter()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(|s| s.parse::&lt;i32&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .partition(Result::is_ok);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Numbers: {:?}&quot;, numbers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Errors: {:?}&quot;, errors);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51354-自定义迭代器">5.13.5.4. 自定义迭代器<a href="#51354-自定义迭代器" class="hash-link" aria-label="Direct link to 5.13.5.4. 自定义迭代器" title="Direct link to 5.13.5.4. 自定义迭代器">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自定义 iterator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Counter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        count: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        max: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Counter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn new(max: u32) -&gt; Self {// new 方法不能放到下面的 iterator 实现中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Counter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count: 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                max</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Iterator for Counter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        type Item = u32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.count += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if self.count &lt;= self.max {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Some(self.count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut counter = Counter::new(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if let Some(count) = counter.next() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;count = {}&quot;, count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51355-自定义适配器-收集器">5.13.5.5. 自定义适配器 收集器<a href="#51355-自定义适配器-收集器" class="hash-link" aria-label="Direct link to 5.13.5.5. 自定义适配器 收集器" title="Direct link to 5.13.5.5. 自定义适配器 收集器">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 第三方包Itertools 亦可实现自定义适配器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::iter::FromIterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct MyVec(Vec&lt;i32&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl MyVec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new() -&gt; MyVec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyVec(Vec::new())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn add(&amp;mut self, elem: i32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.0.push(elem);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实现FromIterator就可以拥有Collect的能力</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl FromIterator&lt;i32&gt; for MyVec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   fn from_iter&lt;I: IntoIterator&lt;Item = i32&gt;&gt;(iter: I) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       let mut c = MyVec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       for i in iter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           c.add(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let iter = (0..5).into_iter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    直接调用 MyVec::from_iter方法和使用 collect方法的效果是一样的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let c = MyVec::from_iter(iter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   assert_eq!(c.0, vec![0, 1, 2, 3, 4]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let iter = (0..5).into_iter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let c: MyVec = iter.collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   assert_eq!(c.0, vec![0, 1, 2, 3, 4]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let iter = (0..5).into_iter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let c = iter.collect::&lt;MyVec&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   assert_eq!(c.0, vec![0, 1, 2, 3, 4]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 自定义适配器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 按指定步数迭代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Clone, Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[must_use = &quot;iterator adaptors are lazy and do nothing unless consumed&quot;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Step&lt;I&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    iter: I,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    skip: usize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;I&gt; Iterator for Step&lt;I&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where I: Iterator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Item = I::Item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn next(&amp;mut self) -&gt; Option&lt;I::Item&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let elt = self.iter.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.skip &gt; 0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.iter.nth(self.skip - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       elt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 产生 Step适配器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn step&lt;I&gt;(iter: I, step: usize) -&gt; Step&lt;I&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where I: Iterator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(step != 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Step {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        iter: iter,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            skip: step - 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 定义了一个继承自 Iterator 的子 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub trait IterExt: Iterator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn step(self, n: usize) -&gt; Step&lt;Self&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        where Self: Sized,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        step(self, n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: ?Sized&gt; IterExt for T where T: Iterator {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arr = [1,2,3,4,5,6];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sum = arr.iter().step(2).fold(0, |acc, x| acc + x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(9, sum); // [1, 3, 5]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="514-条件循环">5.14. 条件循环<a href="#514-条件循环" class="hash-link" aria-label="Direct link to 5.14. 条件循环" title="Direct link to 5.14. 条件循环">​</a></h2><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn condition_loop() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if a &gt; 0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b = 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if a &lt; 0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        b = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;b = {}&quot;, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // if 用在 let 句子中, 返回值类型相同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c = if a &gt; 0 { true } else { false };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;c = {}&quot;, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // while 循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 死循环不要使用 while true, 因为若在 循环体中 return xx; 编译器会认为无效, 编译器只会认为 while true 会返回空即 &quot;()&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut d = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while d &gt; 0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;d = {}&quot;, d);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d -= 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // for 循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = [3, 4, 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for ele in a.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;a[{}] = {}&quot;, i, ele);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in 0..3 {// 不包括尾巴, 0..3 是一个 Range 类型, 是一个 iterator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;a[{}] = {}&quot;, i, a[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //loop 循环 死循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = [&#x27;R&#x27;, &#x27;U&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;O&#x27;, &#x27;B&#x27;];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let ch = s[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ch == &#x27;O&#x27; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;O index = {}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 带返回值的 loop 循环, 用break</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let location = loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if s[i] == &#x27;O&#x27; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;O index = {}&quot;, location);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="515-泛型">5.15. 泛型<a href="#515-泛型" class="hash-link" aria-label="Direct link to 5.15. 泛型" title="Direct link to 5.15. 泛型">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5151-单态化">5.15.1. 单态化<a href="#5151-单态化" class="hash-link" aria-label="Direct link to 5.15.1. 单态化" title="Direct link to 5.15.1. 单态化">​</a></h3><p>单态化是编译器 进行静态分发 的一种策略, 编译器要将一个泛型函数生 成多个具体类型对应的函数</p><p>好处是性能好 ， 没有运行 时开销;缺点是容易造成编译后生成的二进制文件膨胀 (如 果变得太 大，可以根 据具体的情况重构代码来解决问题)</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5152-多重约束-加号">5.15.2. 多重约束 加号<a href="#5152-多重约束-加号" class="hash-link" aria-label="Direct link to 5.15.2. 多重约束 加号" title="Direct link to 5.15.2. 多重约束 加号">​</a></h3><p>trait Bound</p><p>包含 trait 限定的泛型属于静态分发，在编译期通过单态化分别生成具体类型的实例，所以调用 trait 限定中的方法也都是运行时零成本的，因为不需要在运行时再进行方法查找 。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 泛型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn generic() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T { // 多重约束使用 + 号 (且的关系)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut largest = list[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for &amp;ele in list.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if largest &lt; ele {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                largest = ele;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        largest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::ops::Add;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn sum&lt;T: Add&lt;T, Output=T&gt;&gt;(a: T, b: T) -&gt; T{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a + b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 结构体中的泛型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Point&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        y: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl&lt;T&gt; Point&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn x(&amp;self) -&gt; &amp;T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;self.x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //有条件的实现方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct A&lt;T&gt; {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这段代码声明了 A&lt;T&gt; 类型必须在 T 已经实现 B 和 C 特性的前提下才能有效实现此 impl 块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl&lt;T: B + C&gt; A&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn d(&amp;self) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用 where 重构 trait 约束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn foo&lt;T, K, R&gt;(a: T, b: K, c: R) where T: A, K: B+C, R: D {. .}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5153-默认泛型参数-and-关联类型">5.15.3. 默认泛型参数 and 关联类型<a href="#5153-默认泛型参数-and-关联类型" class="hash-link" aria-label="Direct link to 5.15.3. 默认泛型参数 and 关联类型" title="Direct link to 5.15.3. 默认泛型参数 and 关联类型">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 默认泛型参数, 如 std中的 Add trait:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // (为什么要使用关联类型的方式而不在泛型中指定两个参数呢?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //      使用单泛型参数更灵活, 可传可不传, 使得代码更精简)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // sometype 表示符号右边的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait Add&lt;SomeType=Self&gt; {// Self 表示为泛型参数指定默认值 Self (Self是每个trait都带有的隐式类型参数, 代表实现当前 trait 的具体类型); 若实现 add 方法没有指定具体泛型, 则默认为 Self</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        type Output; // 关联类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn add(self, xx: SomeType) -&gt; Self::Output ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // string 也实现了 Add trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s  = &quot;hello&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ns = s + &quot;world&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5154-空约束">5.15.4. 空约束<a href="#5154-空约束" class="hash-link" aria-label="Direct link to 5.15.4. 空约束" title="Direct link to 5.15.4. 空约束">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 空约束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Cardinal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct BlueJay;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Turkey;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait Red {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait Blue {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Red for Cardinal {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Blue for BlueJay {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这些函数只对实现了相应的 trait 的类型有效。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;&#x27;static str { &quot;red&quot; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;&#x27;static str { &quot;blue&quot; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let cardinal = Cardinal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let blue_jay = BlueJay;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _turkey   = Turkey;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 由于约束，`red()` 不能作用于 blue_jay （蓝松鸟），反过来也一样。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));// 错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5155-turbofish-操作符-and-返回值自动推导">5.15.5. turbofish 操作符 and 返回值自动推导<a href="#5155-turbofish-操作符-and-返回值自动推导" class="hash-link" aria-label="Direct link to 5.15.5. turbofish 操作符 and 返回值自动推导" title="Direct link to 5.15.5. turbofish 操作符 and 返回值自动推导">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // turbofish操作符 类型推导</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当 Rust 无法从上下文中自动推导出类型的时候, 可以手动指定类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = &quot;1&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(”{:?}”, x.parse() .unwrap()) //error, parse() 是个泛型方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 手动指定类型 rust 会自动类型推导</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let intx:i32= x.parse().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 或者, 通过 turbofish 操作符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 语法: ::&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!( x.parse::&lt;i32&gt;().unwrap(), 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="516-trait">5.16. trait<a href="#516-trait" class="hash-link" aria-label="Direct link to 5.16. trait" title="Direct link to 5.16. trait">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5161-trait-概念">5.16.1. trait 概念<a href="#5161-trait-概念" class="hash-link" aria-label="Direct link to 5.16.1. trait 概念" title="Direct link to 5.16.1. trait 概念">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51611-trait-基本使用">5.16.1.1. trait 基本使用<a href="#51611-trait-基本使用" class="hash-link" aria-label="Direct link to 5.16.1.1. trait 基本使用" title="Direct link to 5.16.1.1. trait 基本使用">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///特性（trait）概念接近于 Java 中的接口（Interface）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn trait_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait Descriptive {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn describe(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 默认 trait, 类似 java 接口默认实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn fn1(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String::from(&quot;default impl trait&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        age: u8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // user.show() 等价于 User: :show(&amp;user)这样的 函数调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Descriptive for Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn describe(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            format!(&quot;{} {}&quot;, self.name, self.age)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let p = Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: String::from(&quot;xiaoyu&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        age: 11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, p.describe());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, p.fn1());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51612-孤儿规则-通过fundamental规避">5.16.1.2. 孤儿规则 通过fundamental规避<a href="#51612-孤儿规则-通过fundamental规避" class="hash-link" aria-label="Direct link to 5.16.1.2. 孤儿规则 通过fundamental规避" title="Direct link to 5.16.1.2. 孤儿规则 通过fundamental规避">​</a></h4><p>orphan rule: 要为 struct b 实现某个 trait a, 则 a, b 至少有一个必须在当前 crate 中定义 (不能a, b 都是在别处定义的比如都是在 std 中定义的)</p><p>目的: 防止对别人 crate 中的类型行为进行破坏性改写</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 如 要为 u32 类型实现  add, 使得可以加上 u64 类型数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 直接实现 标准库中的 Add 不行, 因为 u32 和 Add 都在其他 crate 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 需要自己定义 在当前 crate : ˚Add trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 当然，除了在本地定义 Addtrait这个方法，还可以在本地创建一个新的类型，然后为此 新类型实现Add</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 局限性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于一些本地类型， 如果将其放到一些容器中，比如Rc&lt;T&gt;或Option&lt;T&gt;， 那么这些本地类型就会变成远程类型 (因为这些容器类型都是在标准库中定义的 ， 而非本地。)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// rust 使用 #[fundamental]的属性标识，来为特定的trait 规避孤儿限制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  Box&lt;T&gt;，还有 Fn、 FnMut、 FnOnce、 Sized 等都上了#[fundamental]属性</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51613-特化-specialization">5.16.1.3. 特化 Specialization<a href="#51613-特化-specialization" class="hash-link" aria-label="Direct link to 5.16.1.3. 特化 Specialization" title="Direct link to 5.16.1.3. 特化 Specialization">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 问题: 重叠规则：不能为重叠的类型实现同一个trait </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; AnyTrait for T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; AnyTrait for T where T: Copy // Copy 和上面的 T 重叠了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; AnyTrait for String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 解决: 特化 (类似 java 中的方法重写/覆盖)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#![feature(specialization)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Diver&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inner: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Swimmer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 带有默认实现的 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn swim(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;swimming&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 先为 Diver&lt;T&gt;实现该 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; Swimmer for Diver&lt;T&gt; {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 为Diver&lt;&amp;’static str&gt;实现了 该 trait (也就是 特殊类型, 特殊处理)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Swimmer for Diver&lt;&amp;&#x27;static str&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn swim(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;drowning, help!&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let x = Diver::&lt;&amp;&#x27;static str&gt; { inner: &quot;Bob&quot; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x.swim();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let y = Diver::&lt;String&gt; { inner: String::from(&quot;Alice&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">y.swim();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51614-trait-作为参数-需要-impl-前缀">5.16.1.4. trait 作为参数 需要 impl 前缀<a href="#51614-trait-作为参数-需要-impl-前缀" class="hash-link" aria-label="Direct link to 5.16.1.4. trait 作为参数 需要 impl 前缀" title="Direct link to 5.16.1.4. trait 作为参数 需要 impl 前缀">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 特性做参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn print(p: impl Descriptive) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, p.describe())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 写法2: (风格类似泛型的语法糖)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn output&lt;T: Descriptive&gt;(object: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, object.describe());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn output_two&lt;T: Descriptive&gt;(arg1: T, arg2: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, arg1.describe());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, arg2.describe());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//特性作类型表示时如果涉及多个特性，可以用 + 符号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn notify(item: impl Summary + Display)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn notify&lt;T: Summary + Display&gt;(item: T)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//复杂的实现关系可以使用 where 关键字简化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//如: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//可以简化成：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where T: Display + Clone,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        U: Clone + Debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 取最大值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Comparable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn compare(&amp;self, object: &amp;Self) -&gt; i8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn max&lt;T: Comparable&gt;(array: &amp;[T]) -&gt; &amp;T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut max_index = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while i &lt; array.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if array[i].compare(&amp;array[max_index]) &gt; 0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            max_index = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;array[max_index]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Comparable for f64 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn compare(&amp;self, object: &amp;f64) -&gt; i8 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if &amp;self &gt; &amp;object { 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if &amp;self == &amp;object { 0 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else { -1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let arr = [1.0, 3.0, 5.0, 4.0, 2.0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;maximum of arr is {}&quot;, max(&amp;arr));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51615-trait-作为-返回值-返回动态类型">5.16.1.5. trait 作为 返回值 返回动态类型<a href="#51615-trait-作为-返回值-返回动态类型" class="hash-link" aria-label="Direct link to 5.16.1.5. trait 作为 返回值 返回动态类型" title="Direct link to 5.16.1.5. trait 作为 返回值 返回动态类型">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     //特性做返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn person() -&gt; impl Descriptive {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            name: String::from(&quot;Cali&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            age: 24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在同一个函数中所有可能的返回值类型必须完全一样</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果希望返回不同的struct, 使用  Box&lt;dyn Animal&gt; 作为返回值 ----- 多态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 错误, 因为 A, B 虽然都实现了 Descriptive, 但是 A B 是不同的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn some_function(bool bl) -&gt; impl Descriptive {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if bl {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return A {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return B {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 那么如何返回不同的 struct?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用 Box&lt;dyn xxx&gt;, box 是一种数据结构, 效果类似引用,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {// 返回类型内存大小确定了, 编译可以通过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if random_number &lt; 0.5 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Box::new(Sheep {})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Box::new(Cow {})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51616-trait-继承">5.16.1.6. trait 继承<a href="#51616-trait-继承" class="hash-link" aria-label="Direct link to 5.16.1.6. trait 继承" title="Direct link to 5.16.1.6. trait 继承">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait Person1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn name(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Implementing Student requires you to also impl Person.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait Student: Person1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn university(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait Programmer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn fav_language(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait CompSciStudent: Programmer + Student {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn git_username(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        format!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;My name is {} and I attend {}. My Git username is {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            student.name(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            student.university(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            student.git_username()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 菱形继承问题: 某个 struct 实现两个 trait, 需要实现两个同名方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 完全限定语法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;Descriptive as Person&gt;::xxx_fn() //类似于强制转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 看例子</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait UsernameWidget {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn get(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait AgeWidget {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn get(&amp;self) -&gt; u8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Form {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        username: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        age: u8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl UsernameWidget for Form {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn get(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.username.clone()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl AgeWidget for Form {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn get(&amp;self) -&gt; u8 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.age</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let form = Form{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        username: &quot;rustacean&quot;.to_owned(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        age: 28,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // error, &quot;multiple `get` found&quot;. Because, after all, there are multiple methods named `get`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, form.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(&quot;rustacean&quot;.to_owned(), username);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(28, age);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51617-静态分发-动态分发">5.16.1.7. 静态分发 动态分发<a href="#51617-静态分发-动态分发" class="hash-link" aria-label="Direct link to 5.16.1.7. 静态分发 动态分发" title="Direct link to 5.16.1.7. 静态分发 动态分发">​</a></h4><p>impl Trait代表静 态分发 ， dyn Trait 代表动态分发 。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">      trait Fly {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn can_fly(&amp;self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Duck;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Pig;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Fly for Duck {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn can_fly(&amp;self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Fly for Pig {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn can_fly(&amp;self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用泛型, 定义静态分发的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 编译阶段, 泛型已经被展开 为具体类型的代码, 没有抽象开销</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or 可以使用 impl trait 改写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fly_static&lt;T: Fly&gt;(t: &amp;T) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.can_fly()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用 dyn 定义动态分发的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 运行期决定到底是什么类型, 有额外开销</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fly_dyn(t: &amp;dyn Fly) -&gt; bool { // 抽象类型是 trait object, 是有要求的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.can_fly()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pig = Pig;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let duck = Duck;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, fly_static::&lt;Pig&gt;(&amp;pig));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, fly_dyn(&amp;duck));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51618-使用抽象类型">5.16.1.8. 使用抽象类型<a href="#51618-使用抽象类型" class="hash-link" aria-label="Direct link to 5.16.1.8. 使用抽象类型" title="Direct link to 5.16.1.8. 使用抽象类型">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="516181-trait对象">5.16.1.8.1. trait对象<a href="#516181-trait对象" class="hash-link" aria-label="Direct link to 5.16.1.8.1. trait对象" title="Direct link to 5.16.1.8.1. trait对象">​</a></h5><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// AbstractType ExistentialType</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 相对于具体类型而言，抽象类型无法直接实例化， 但是它的每个实例都 是具体类型的实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 编译器可能无法确定其确切的功能和所占的空间大 小 。 所以 Rust 目前有两种方法来处理抽象类型: trait 对象和 impl Trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 方式 1: trait 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Foo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Bar {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn baz(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Bar for Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn baz(&amp;self) { println!(&quot;{:?}&quot;, self) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn static_dispatch&lt;T&gt;(t: &amp;T) where T:Bar {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t.baz();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 动态分发, 有性能开销</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn dynamic_dispatch(t: &amp;Bar) { // 这里参数是一个 trait object, 无法确定大小, 必须使用 引用 &amp; or box</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t.baz();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let foo = Foo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static_dispatch(&amp;foo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dynamic_dispatch(&amp;foo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 为什么 将 trait对象称为动态 分发?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// std 中  为 trait object 定义了一个 struct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 包含连个指针:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 1. data ptr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          指向 类型数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2. vtable ptr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          指向 virtual table (cpp 中的概念), 就是一个结构体, 包含 析构函数, 大小, 方法...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在编译期 ， 编译器只知道 TraitObject 包含指 针 的信息 ， 并且指针的大 小 也是确定的 ，并 不知道 要 调用哪个 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//在运行期 ， 当有 trait_object.method()方法被调 用时， TraitObject 会 根据虚表指针从虚表中查出正确的指针，然后再进行动态调用 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="516182-trait对象安全问题-sized-trait">5.16.1.8.2. trait对象安全问题 Sized trait<a href="#516182-trait对象安全问题-sized-trait" class="hash-link" aria-label="Direct link to 5.16.1.8.2. trait对象安全问题 Sized trait" title="Direct link to 5.16.1.8.2. trait对象安全问题 Sized trait">​</a></h5><p>对象安全的本质就是为 了让 trait 对象可以安全地调用相应的方法</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 并不是每个 trait都可以作为 trait对象被使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//每个 trait, Self默认有一个隐式的 trait 限定 ?Sized, 形如&lt;Self: ?Sized&gt; , ?Sized trait 包括了所有的动态大小类型和所有可确定大小 的类型。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Rust 中大部分类型都默认是可确定大小的类型，也就是&lt;T: Sized&gt;，这也是泛型代 码可以正常编译的原因 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 当 trait对象在运行期进行动态分发，也必须确定大小，否则无法为其正确分配内存空 间 。所 以必须同时满足以下两条规则的 trait 才可以作为 trait 对象使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  trait对象 能够编译通过的要求是, trait 必须是对象安全的, 满足:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 1.  trait 的 Self类型参数不能被限定为 Sized, 必须是 默认的 ?Sized (因为 trait objec 在编译期无法确定具体类型, 大小未知)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2.  trait 中所有的方 法都必须是对象安全的, 满足三点之一</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          - 方法受 Self: Sized 约束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          - trait 中 不能包含关联常 量( Associated Constant, 其定义方法和关联类型差不多， 只不过需要使用 const关键字)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//          - 方法满足没有额外 Self类型参数的非泛型成员方法(分解开来就是三点)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //          - 必须不包含任何泛型参数 (因为如果包含泛型 ，trait 对 象在 虚表Vtable中查找方法时将不确定该调用哪个方法)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //          - 第一个参数必须为 Self 类型或可以解引用为 Self 的类型 (比如 self、 &amp;self、&amp;mutself和 self: Box&lt;Selt&gt;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //          - Self不能出现在除第一个参数之外的地方， 包括返回值中 (因为如果出现 Self,那就意味着 Self和 self、 &amp;self或&amp;mutself的类型能够相匹配。 但是对于 trait对象来说， 根本无法做到保证类型匹配)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个trait 就无法作为 trait object在动态分发中使用, 不是对象安全的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Foo: Sized {...}//表示要为某类型实现 Foo，必须先实现 Sized, Foo 中 的隐式 Self被设定为是 Sized 的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 标准的对象安全的 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Bar {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn bax(self, x: u32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     fn bay (&amp;self) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     fn baz (&amp;mut self) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 典型的对象不安全的 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对象不安全的 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn bad&lt;T&gt;(&amp;self, x: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new() -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//对象安全的 trait ， 将不安全 的方法拆 分 出 去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn bad&lt;T&gt;(&amp;self, x: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Bar:Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new() -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//对象安全的trait，使用where子句</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 只不过在 traitFoo作为 trait对象且有?Sized限定时， 不允许调用该 new方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn bad&lt;T&gt;(&amp;self, x: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new() -&gt; Self where Self: Sized;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="516183-impl-trait">5.16.1.8.3. impl trait<a href="#516183-impl-trait" class="hash-link" aria-label="Direct link to 5.16.1.8.3. impl trait" title="Direct link to 5.16.1.8.3. impl trait">​</a></h5><p>可 以静态分发的抽象类型 impl Trait, 可以用来替代泛型约束, 可以使用加号 (impl Fly+Debug)</p><p>目前 impl Trait 只可以在输入的参敬和返回值这两个位置使用</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ’static 是一种生命周期参数 ， 它限定了 impl Fly+Debug 抽象类 型不可能是引用类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn dyn_can_fly( s : impl Fly+Debug+ ’static) -&gt; Box&lt;dyn Fly&gt; {}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51619-trait的类型转换">5.16.1.9. trait的类型转换<a href="#51619-trait的类型转换" class="hash-link" aria-label="Direct link to 5.16.1.9. trait的类型转换" title="Direct link to 5.16.1.9. trait的类型转换">​</a></h4><p>隐式类型转换 (Implicit Type Conversion)和显式类型转 换 (ExplicitType Conversion)</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 隐式类型转换基本上只有 自动解 引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 引用使用&amp;操作符， 而解引用使用*操作符。可以通过实现Deref trait来自定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// as 操作符 最常用的场景就是转换 Rust 中的基本数据类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let a: i64 = 11 as i64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 短(大小)类型转换为长(大小)类型的时候是没有问题的， 但 是如果反过来，则会被 截断处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 当从有符号类型 向无符号类型转换 的时候， 最好使用标准库中提供的专门的方法，而不要直接使用 as操作符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 类型和子类型相互转换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 生命周期标记可看作子类型。 比如&amp;’static str类型是&amp;’a str类型的子类 型; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//’a 和 &#x27;static 都是生命周期标记，其中’a 是泛型标记， 是 &amp;str的通用形式， 而’static则是特指静态生命周期的&amp;str字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5162-可自动推导的trait">5.16.2. 可自动推导的trait<a href="#5162-可自动推导的trait" class="hash-link" aria-label="Direct link to 5.16.2. 可自动推导的trait" title="Direct link to 5.16.2. 可自动推导的trait">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 推导 派生 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 下面以下是可以自动推导的 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Eq, PartialEq, Ord, PartialOrd (比较类的 trait)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Clone, 用来从 &amp;T 创建副本 T。当处理资源时，默认的行为是在赋值或函数调用的同时将它们转移。但是我们有时候也需要 把资源复制一份。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 包括 clone, colon_from 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 如果一个类型是 Copy的， 它的clone方法仅需要返回*self即可 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 使用需要显式调用 clone(), 若希望rust 碰到 等号赋值了就自动隐式调用 clone() , 需要给结构体加上 derive(Clone, Copy), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Copy，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        copy trait 无法单独使用, 必须在 Clone trait 存在的情况下才能使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Hash，从 &amp;T 计算哈希值（hash）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Debug，使用 {:?} formatter 来格式化一个值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Serialize Deserialize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug, Clone, Copy)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Nil;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `Centimeters`，可以比较的元组结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(PartialEq, PartialOrd)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Centimeters(f64);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `Inches`，可以打印的元组结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Inches(i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Inches {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn to_centimeters(&amp;self) -&gt; Centimeters {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let &amp;Inches(inches) = self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Centimeters(inches as f64 * 2.54)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let foot = Inches(12);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;One foot equals {:?}&quot;, foot);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let meter = Centimeters(100.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let cmp =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if foot.to_centimeters() &lt; meter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;smaller&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;bigger&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;One foot is {} than one meter.&quot;, cmp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `Seconds`，不带附加属性的元组结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Seconds(i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _one_second = Seconds(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 报错：`Seconds` 不能打印；它没有实现 `Debug` trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;One second looks like: {:?}&quot;, _one_second);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 报错：`Seconds`不能比较；它没有实现 `PartialEq` trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _this_is_true = (_one_second == _one_second);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5163-运算符重载相关的trait">5.16.3. 运算符重载相关的trait<a href="#5163-运算符重载相关的trait" class="hash-link" aria-label="Direct link to 5.16.3. 运算符重载相关的trait" title="Direct link to 5.16.3. 运算符重载相关的trait">​</a></h3><p>操作符重载</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 很多运算符可以通过 trait 来重载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这些运算符可以根据它们的 输入参数来完成不同的任务。这之所以可行，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //是因为运算符就是方法调用的语法糖。例 如，a + b 中的 + 运算符会调用 add 方法（也就是 a.add(b)）。这个 add 方 法是 Add trait 的一部分</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Add trait  重载 + 运算符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Deref trait 重载解引用符号, 就是 &quot;*&quot; 号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //在 std::ops 下有全部重载的 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在std::cmp 下则是比较操作的操作符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 例子: 对象排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 有四个Trait : Ord、PartialOrd 、Eq 和 PartialEq  。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::cmp::{Ord, PartialOrd, PartialEq, Ordering};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Employee {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name : String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        salary : i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Ord for Employee {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn cmp(&amp;self, rhs: &amp;Self) -&gt; Ordering {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.salary.cmp(&amp;rhs.salary)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl PartialOrd for Employee {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn partial_cmp(&amp;self, rhs: &amp;Self) -&gt; Option&lt;Ordering&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Some(self.cmp(rhs))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Eq for Employee {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl PartialEq for Employee {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn eq(&amp;self, rhs: &amp;Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.salary == rhs.salary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v = vec![</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Employee {name : String::from(&quot;Bob&quot;),     salary: 2048},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Employee {name : String::from(&quot;Alice&quot;),   salary: 3208},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Employee {name : String::from(&quot;Tom&quot;),     salary: 2359},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Employee {name : String::from(&quot;Jack&quot;),    salary: 4865},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Employee {name : String::from(&quot;Marray&quot;),  salary: 3743},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Employee {name : String::from(&quot;Hao&quot;),     salary: 2964},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Employee {name : String::from(&quot;Chen&quot;),    salary: 4197},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //用for-loop找出薪水最多的人</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut e = &amp;v[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in 0..v.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if *e &lt; v[i] { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = &amp;v[i]; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;max = {:?}&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用标准的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;min = {:?}&quot;, v.iter().min().unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;max = {:?}&quot;, v.iter().max().unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //使用标准的排序方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.sort();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5164-from-和-into">5.16.4. From 和 Into<a href="#5164-from-和-into" class="hash-link" aria-label="Direct link to 5.16.4. From 和 Into" title="Direct link to 5.16.4. From 和 Into">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 定义于 std::convert 模块中的两个 trait。 它们定义了 from 和 into 两个方 法，这两个方法互为反操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let s = String: :from(”hello”);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    name, String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //允许传入的参数是&amp;str类型或 String 类型 ，方便进行开发 (&amp;str和 String类型都实现了 Into, 当参数是&amp;str类型时，会通过 into转换为 String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new&lt;T: Into&lt;String&gt;&gt;(name: T) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person {name: name.into()}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果类型 U实现了 From&lt;T&gt;，则 T类型实例调用 into方 法就可以转换为类型 U (rust 自动帮我们实现了 Into)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 所以 ， 一般情况下 ， 只需要实现 From 即可 ， 除非 From 不容易实现，才需要考虑实 现 Into</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let a = &quot;hello&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b:String = a.into();//String 类型实现了 From&lt;&amp;str&gt;，所以可以使用 into 方法将 &amp;str 转换为 String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// TryFrom 和 TryInto 两种 trait，是 From 和 Into 的错误处理版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5165-derefmut-和-deref">5.16.5. DerefMut 和 Deref<a href="#5165-derefmut-和-deref" class="hash-link" aria-label="Direct link to 5.16.5. DerefMut 和 Deref" title="Direct link to 5.16.5. DerefMut 和 Deref">​</a></h3><p>用于自定义解除引用运算符(*)的行为</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  let a = 11;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let b = Box::new(a);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  print!(&quot;Value of *b is {}&quot;,*b); //11, box 可以像普通引用一样解引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 构造自己的 box</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct MyBox&lt;T&gt;(T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; MyBox&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn new(v: T) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return MyBox(v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::ops::Deref;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Target = T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn deref(&amp;self) -&gt; &amp;Self::Target {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;self.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = MyBox::new(32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{:?}&quot;, b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;b inner = {}&quot;, *b); //32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;b inner2 = {}&quot;, *b.deref());// 32, deref() 返回内部数据的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//自动解包 , deref 的强制效果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn prin(v: &amp;i32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">prin(&amp;b) // 自动将 &amp;MyBox 包装解除, 成为 &amp;i32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 如果一个类型 T 实现了 Deref&lt;Target=U&gt;， 则该类型 T 的引用 (或智能指针)在应用的时候会被 自动转换为类型 U</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// String类型实现了 Deref</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let a = &quot;hello&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = &quot; world&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let c = a+&amp;b;//&amp;b，它应该是一个&amp;Sting类型，而 String类型实现的 add方法的右值参数必须是&amp;str类型, 但现在它是可 以正常运行的。原因就是 String 类型实 现了 Deref&lt;Target=str&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(”{:?)’”, c); // &quot;hello world&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 标准库中常用的其他类型都实现了 Deref， 比如 Vec&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn foo(s : &amp;[i32]){}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let v= vec![1,2,3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">foo(&amp;v);//所以&amp;Vec&lt;T&gt; 会被自动转换为 &amp;[T]类型，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Box&lt;T&gt;、 Rc&lt;T&gt;、 Arc&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let x = Rc::new(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println1 (”{:?}”, x.chars());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 当某类型和其解引用目标类型中包含了相同的方法时，编译器不知道该用哪一个了,此时就需要手动解引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  clone方法在Rc和&amp;str类型中都被实现了，所以调用时会直接调用 Rc 的 clone 方法，如果想调用 Rc 里面 &amp;str 类型的 clone 方法，则需要使用“解 引用”操作 符 手动解引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let x= Rc::new(”hello”),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let y=x.clone(); //Rc&lt;&amp;str&gt;的 clone 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let z = (*x) .clone() ; // &amp;str 的 clone 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// match 引用时也需要手动解引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let x = &quot;hello&quot;. to_string (); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">match &amp;x {//手动解引用把&amp; String 类型转换成&amp; str</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // match x.deref()，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //match x.as_ref()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //match x.borrow()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //match &amp;*x 使用“解引用 ”操作符，将 String转换为 str，然后再用“引用”操作符转为&amp; str</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //match&amp;x[..]，这是因为String类型的index操作可以返回&amp;由类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;hello&quot; =&gt; {println! (&quot;xxx&quot;)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// DerefMut和 Deref类似， 只不过它是返回可变引用的。 Deref中包含关联类型 Target, 它表示解引用之后的目标类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5166-asref-asmut">5.16.6. AsRef AsMut<a href="#5166-asref-asmut" class="hash-link" aria-label="Direct link to 5.16.6. AsRef AsMut" title="Direct link to 5.16.6. AsRef AsMut">​</a></h3><p> 可以将值分别转换为不可变引用和 可变引用</p><p> AsRef和标准库的另外一个 Borrow trait功能有些类似，但是 AsRef比较轻量级， 它只是简单地将值转换为引用，而 Borrow trait 可以用来将某个复合类型抽象为拥有借用语义 的类型</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5167-borrow-trait">5.16.7. Borrow trait<a href="#5167-borrow-trait" class="hash-link" aria-label="Direct link to 5.16.7. Borrow trait" title="Direct link to 5.16.7. Borrow trait">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5168-drop-资源释放">5.16.8. Drop 资源释放<a href="#5168-drop-资源释放" class="hash-link" aria-label="Direct link to 5.16.8. Drop 资源释放" title="Direct link to 5.16.8. Drop 资源释放">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 释放资源 Drop trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Drop trait 只有一个方法：drop，当对象离开作用域时系统会进行资源释放, 同时会自动调用该 方法, 用于释放类似于文件或网络连接的资源。, 这个方法不允许手动调用, 编译器会自动调用, 用于释放类似于文件或网络连接的资源, 或者释放 box 所指向的堆空间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    也可以 drop(a) 手动调用释放, 使用 std::mem::drop(xxx)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box，Vec，String，File，以及 Process 是一些实现了 Drop trait 来释放 资源的类型。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 析构顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 本地变量遵循先声明的变量后析构的规则 (这也缘于桔结构先进后 出的特性)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 元组整体来说也属于本地变量, 所以析构顺序和局部变量的析构顺序一致</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         但内部元素是按元素的出现顺序依次进行析构的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 结构体和枚举体 内部元素按照定义时的次序析构 (类似元组的析构)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 闭包捕获变 量 的析构顺序和闭包内该变量的排列顺序 一致, 与捕获变 量声 明的顺序是没有关系的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct PrintDrop(&amp;&#x27;static str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Drop for PrintDrop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;Dropping {}&quot;, self.0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 顺序: y, x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let x = PrintDrop(&quot;x&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let y = PrintDrop(&quot;y&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 顺序: x, y, z, a,b,c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let tup1 = (PrintDrop(&quot;a&quot;), PrintDrop(&quot;b&quot;), PrintDrop(&quot;c&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let tup2 = (PrintDrop(&quot;x&quot;), PrintDrop(&quot;y&quot;), PrintDrop(&quot;z&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 顺序: y,x, a,b,c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let tup1 = (PrintDrop(&quot;a&quot;), PrintDrop(&quot;b&quot;), PrintDrop(&quot;c&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let tup2 = (PrintDrop(&quot;x&quot;), PrintDrop(&quot;y&quot;), panic!());//线程的崩愤触发了 tup2 的提前析构, 这 种提前析构的顺序正好和局部变量的析构顺序一致: 先声明的元素后析构。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 屏蔽 规避 drop 检查(跳过 内存自动释放)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct B;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: A,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b: B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn take(self) -&gt; (A, B) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // error[E0509]: cannot move out of type `Foo`, which implements the `Drop` trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 因为 drop 方法中可能还需要用到这两个字段, 所以不能将他们的所有权移动到外部</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (self.a, self.b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 正确:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 重新实现take</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn take(mut self) -&gt; (A, B) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 通过std::mem::uninitialized()进行伪初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 用于跳过Rust的内存初始化检查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果此时对a或b进行读写，则有UB(引发未定义行为)风险，一般只用于 FFI和 C语言交五</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let a = std::mem::replace(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             &amp;mut self.a, unsafe { std::mem::uninitialized() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let b = std::mem::replace(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;mut self.b, unsafe { std::mem::uninitialized() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       // 通过forget避免调用结构体实例的drop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    这样, 析构函数就不会被自动调用, 需要我们在某个地方手动释放内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       std::mem::forget(self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       (a, b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 若不实现 Drop 则上面代码不会报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 另外的手动释放内存的方式 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ManuallyDrop&lt;T&gt;是一个联合体，Rust不会为联合体自动实现Drop。 因为联合体是所有字段共用内存，不能随便被析构，否则会引起未定义行为</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// (std::mem::forget&lt;T&gt;函数的实现就是用了ManuallyDrop::new方法)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::mem::ManuallyDrop;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Peach;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Banana;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Melon;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct FruitBox {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    peach: ManuallyDrop&lt;Peach&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    melon: Melon,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    banana: ManuallyDrop&lt;Banana&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for FruitBox {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           ManuallyDrop::drop(&amp;mut self.peach);// 手动释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           ManuallyDrop::drop(&amp;mut self.banana);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5169-标签-trait">5.16.9. 标签 trait<a href="#5169-标签-trait" class="hash-link" aria-label="Direct link to 5.16.9. 标签 trait" title="Direct link to 5.16.9. 标签 trait">​</a></h3><p>即 内部没有任何内容的 trait, 只是作为一个标签, 起到标识作用</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51691-send-和-sync">5.16.9.1. Send 和 Sync<a href="#51691-send-和-sync" class="hash-link" aria-label="Direct link to 5.16.9.1. Send 和 Sync" title="Direct link to 5.16.9.1. Send 和 Sync">​</a></h4><p>一般编译器帮我们自动实现了</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 可以安全地跨线程传递和访 问 的类型用 Send 和 Sync 标记，否则用! Send 和!Sync 标记 , 这样编译器在编译时就能检出数据竞争的隐患， 而不需要等到运行时再排查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实现了 Send 的类型 ，可以安全地在线程间传递所有权, 即可以跨线程移动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实现了 Sync 的类型 ，可以跨线程安全地传递不可变引用 , 即可以跨线程共享。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 之所以可以正常地move变量，也是因为数组x中的元素均为原生数据类型， 默认都实现了 Send 和 Sync 标签 trait，所以它们跨线程传递和访问都很安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut x=vec![1, 2, 3, 4] ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thread::spawn(move || x.push(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Rc 没有实 现 Send 和 Sync，所以不能在线程之间传递变 量 x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 因为 Rc是用于引用计数的智能指针， 如果把 Rc类型的变量 x传递到另一个线程中，会 导致不同线程的 Rc 变量引用同一块数据， Rc 内 部实现并没有做任何线程同步的处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let x = Rc::new(vec! [1, 2, 3, 4]);//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thread::spawn( move || x[1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于自定义的数据类型，如果其成员类型全部实现 Send 和 Sync，此类型才会被自 动实现 Send 和 Sync</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51692-copy-trait">5.16.9.2. Copy trait<a href="#51692-copy-trait" class="hash-link" aria-label="Direct link to 5.16.9.2. Copy trait" title="Direct link to 5.16.9.2. Copy trait">​</a></h4><p>区分值语义和引用语义</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Copy trait，用来标识 可 以按位 复制其值 的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Copy 告诉编译器这个类型默认采用 copy 语义，而不是 move 语义; 在执行变量绑定、函数参数传递、函数返回等场景下, 执行的是内存拷贝操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 引用类型无法实现 copy trait, 虽然引用语义类型不能实现 Copy， 但可以实现 Clone 的 clone 方法， 以 实现深复制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Copy trait继承自 Clone trait, 要实现 Copy trait 的类型，必须实现 Clone trait 中定义的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  Rust 提供了更方便的 derive 属性供我们完成这项重复的工作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive (Copy , Clone)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct xxx {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 某个类型标注为 Copy后, 就不能随便实现 Clone 的 clone 方法了, 调用 t.clone() 时, 执行的操作必须等同于“简单内存拷贝”;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 所以 一般使用 #[derive(Copy, Clone)] 这种方式，这种情况下它们俩最好一起出现，避免手工实现 Clone 导致错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Rust 为很多基本数据类型实现了 Copy trait，比如常用的数字类型、字符( Char)、布尔 类型、单元值、不可变引用等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 检测哪些类型实现 了 Copy trait:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn test copy&lt;T: Copy&gt;(t : T) { //如果实现了Copy trait的类型， 则可以正常编译: 如果没有实现，则会报错。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(”hhh”);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 并非所有类型都可以 实现 Copy trait。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于自定义类型来说，必须让所有的成员都实现 了 Copy trait， 这个类型才有资格 实现 Copy trait。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果是数组类型 ， 且其内部元素都是 Copy 类型， 则数组本身就是 Copy 类型;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果是元组类型，且其内部元素都是 Copy 类型， 则该元 组会自动实现Copy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51693-sized-trait--和-动态类型dst">5.16.9.3. Sized trait  和 动态类型DST<a href="#51693-sized-trait--和-动态类型dst" class="hash-link" aria-label="Direct link to 5.16.9.3. Sized trait  和 动态类型DST" title="Direct link to 5.16.9.3. Sized trait  和 动态类型DST">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// sized trait 用来标识编译期可确定大小的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Unsize trait， 目前该 trait 为实验特性，用于标识动态大小类型 (DST)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Dynamical sized type -&gt; DST</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 运行期才知道大小的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如 str (不是 &amp;str 哦), 编译器不可知大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //      &amp;str 这个类型的值包含两个部分, str 的地址, str 的长度, 所以 &amp;str 的大小类型可以确定 即 2*usize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如 trait object, 都是动态类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如[T],  未知类型的数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如 包含 DST 的 struct/tuple</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 所以为了能够编译通过, 必须将动态类型放到指针背后, 指针时 &quot;fat pointe&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// compiler默认为 类型加上了 Sized trait, 如:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn xxx&lt;T: Sized&gt;(t: T); // 指定 t 为可知大小类型, Sized 可省略, 编译器默认添加了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ?Sized 包含 Sized 和 unsized</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn xxx&lt;T: ?Sized&gt; (t: T);// t 为 编译期间不可知大小的类型 or 为 可知大小类型, 告诉 编译器, 到底是那种类型不确定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 但是动态大小类型不能随意使用，还需要遵循如下三条限制规则:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 1. 只可以通过胖指针来操作 Unsize类型，比如&amp;[T]或&amp;Trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2. 变量、参数和枚举变量不能使用动态大小类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3. 结构体中只有最后一个字段可以使用动态大小类型，其他字段不可以使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="51610-default-trait">5.16.10. Default trait<a href="#51610-default-trait" class="hash-link" aria-label="Direct link to 5.16.10. Default trait" title="Direct link to 5.16.10. Default trait">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 为 struct 提供默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fgcolor: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bgcolor: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Default for ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn default() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            input: String::default(),// 这样使用即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fgcolor: String::new(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bgcolor: String::new(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="51611-extend-trait">5.16.11. Extend trait<a href="#51611-extend-trait" class="hash-link" aria-label="Direct link to 5.16.11. Extend trait" title="Direct link to 5.16.11. Extend trait">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 通过 iterator中的元素, 扩充集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 包含方法:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// fn extend&lt;T: IntoIterator&lt;Item = A&gt;&gt;(&amp;mut self, iter: T);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut s = &quot;Hello&quot;.to_owned();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s.extend(&amp;[&#x27; &#x27;, &#x27;R&#x27;, &#x27;u&#x27;, &#x27;s&#x27;, &#x27;t&#x27;]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, s);//Hello Rust</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// String 刚好实现了这个 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="51612-any-trait">5.16.12. Any trait<a href="#51612-any-trait" class="hash-link" aria-label="Direct link to 5.16.12. Any trait" title="Direct link to 5.16.12. Any trait">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// use std::any::Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="51613-和比较排序相关的trait">5.16.13. 和比较排序相关的trait<a href="#51613-和比较排序相关的trait" class="hash-link" aria-label="Direct link to 5.16.13. 和比较排序相关的trait" title="Direct link to 5.16.13. 和比较排序相关的trait">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// PartialEq、 Eq、 PartialOrd 和 Ord</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - PartialEq代表部分等价关系，其中定义了 eq和 ne (不等, 有默认实现)两个方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Eq 代表等价关系，该 trait 继承自 PartialEq， 但是其中没有定义任何方法 。 它实际上 相当于标记实现了 Eq 的类型拥有等价关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - PartialOrd对应于偏序，其中定义了 partial_cmp (必须实现)、 lt、 le(小于等于)、 gt和 ge五个方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Ord对应于全序，其中定义了 cmp、 max和 min三个方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 枚举体为 Ordering， 用于表示 比较结果，其中定义了 小于、等于和大于三种状态。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut v = [-5i32, 4, 1, -3, 2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    默认升序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.sort();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(v == [-5, -3, 1, 2, 4]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 而 sort_by 是按 a 和 b 的比较结果是否等于 Less 的规则进行排序 的， 若等于 less, 则 a 小于 b，为升序排列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.sort_by(|a, b| a.cmp(b));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(v == [-5, -3, 1, 2, 4]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.sort_by(|a, b| b.cmp(a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(v == [4, 2, 1, -3, -5]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.sort_by_key(|k| k.abs());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   assert!(v == [1, 2, -3, 4, -5]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let result = 1.0.partial_cmp(&amp;2.0);//浮点数，只能用偏序比较</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(result, Some(Ordering::Less));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result = 1.cmp(&amp;1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(result, Ordering::Equal);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result = &quot;abc&quot;.partial_cmp(&amp;&quot;Abc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(result, Some(Ordering::Greater));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v: [f32; 5] = [5.0, 4.1, 1.2, 3.4, 2.5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.sort_by(|a, b| a.partial_cmp(b).unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(v == [1.2, 2.5, 3.4, 4.1, 5.0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.sort_by(|a, b| b.partial_cmp(a).unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(v == [5.0, 4.1, 3.4, 2.5, 1.2]);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="517-元组">5.17. 元组<a href="#517-元组" class="hash-link" aria-label="Direct link to 5.17. 元组" title="Direct link to 5.17. 元组">​</a></h2><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 元组,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //类型可以不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const tup: (i32, f64, u8, &amp;&#x27;static str) = (500, 6.4, 1, &quot;holla&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // tup.0 等于 500</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // tup.1 等于 6.4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // tup.2 等于 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 结构元组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (x, y, z, w) = tup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // y 等于 6.4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当元组中只有一个值的时候，需要加逗号，即(0,)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 空元组 / 单元类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 零大小类型(Zero Sized Type, ZST), 不占空间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用场景:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 在开发时, 查看数据类型; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a: () = vec![();10];// error, 提示 expected (), foundstruct 、std: :vec·:Vee, 这样就知道了右值 vec![(); 10]是向量类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2. 在需要循环指定次数的位置, 用来提高性能 (因为 Vee 内部迭代器中 会针对 ZST 类型做一些优化)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v: Vee&lt;()&gt;= vec![(); 10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in v {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // xxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3. 官方标准库 中的 HashSet&lt;T&gt; 和 BTreeSet&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 其实只是把 HashMap&lt;K, T&gt;换成了 HashMap&lt;K, ()&gt;， 然后就可 以共用 HashMap&lt;K, T&gt;之前的代码，而不需要再重新实现一遍 HashSet&lt;T&gt;了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="518-结构体">5.18. 结构体<a href="#518-结构体" class="hash-link" aria-label="Direct link to 5.18. 结构体" title="Direct link to 5.18. 结构体">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5181-结构体基本使用">5.18.1. 结构体基本使用<a href="#5181-结构体基本使用" class="hash-link" aria-label="Direct link to 5.18.1. 结构体基本使用" title="Direct link to 5.18.1. 结构体基本使用">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 结构体（Struct）与元组（Tuple）都可以将若干个类型不一定相同的数据捆绑在一起形成整体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 但是结构体可以给每个数据起个名字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 这样访问它成员的时候就不用记住下标了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 和 c 不同,  Rust 里 struct 语句仅用来定义，不能声明实例，结尾不需要 ; 符号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 和 go 不同, rust 的 struct 无法嵌套, 只能分成多个 struct 来定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 结构体必须掌握字段值所有权，因为结构体失效的时候会释放所有字段, 所以字符串字段使用 String 不用 &amp;str (因为 &amp;str 是借用的所有权)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 没有身体的结构体为单元结构体（Unit Struct）, 如 struct UnitStruct;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn struct_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)] // 在定义 struct 时导入调试库, 才能 print</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Site {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        domain: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nation: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        found: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实例化, 若是空 struct,     let inner_a = InnerA {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let domain = String::from(&quot;xiaoyureed.github.io&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let st = Site {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        domain, // 有字段名称和现存变量名称一样的，可以简化书写, 类似 JavaScript</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: String::from(&quot;xiaoyu&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nation: String::from(&quot;China&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        found: 2013,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 部分更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因为没有实现了 Copy trait, 所有 st 所有权会转移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let st1 = Site {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        domain: String::from(&quot;new domain&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ..st</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 输出结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 需要定义 struct 时导入调试库 #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;st = {:?}&quot;, st1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 格式化输出 {:#?}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;st = {:#?}&quot;, st1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 只有 成员都为 复制语义,  struct 才能自动 Copy derive </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug,Copy,Clone)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Book&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    name: &amp;&#x27;a str,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    isbn: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    version: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let book = Book {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: &quot;Rust编程之道&quot; , isbn: 20181212, version: 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let book2 = Book { version: 2, ..book};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;,book);// book 由于 实现 了 Copy trait, 所有权没有转移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;,book2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5182-元组结构体-and-单元结构体">5.18.2. 元组结构体 and 单元结构体<a href="#5182-元组结构体-and-单元结构体" class="hash-link" aria-label="Direct link to 5.18.2. 元组结构体 and 单元结构体" title="Direct link to 5.18.2. 元组结构体 and 单元结构体">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 元组结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 简化的结构体, 没有字段名称, 只有字段类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Color(u8, u8, u8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Point(f64, f64);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let black = Color(0, 0, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let origin = Point(0.0, 0.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用和元组一样, 通过下标访问字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;black = ({}, {}, {})&quot;, black.0, black.1, black.2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;origin = ({}, {})&quot;, origin.0, origin.1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 直接打印结构体 错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 要打印, 两种方法:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 定义 struct 时继承 #[derive(Debug)], 然后 使用 {:?} or {:#?} 打印</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2. 为 struct 实现 fmt::Display 接口, 然后使用 {} 即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // println!(&quot;tuple struct - {}&quot;, black);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 单元结构体 即 空的结构体, 零大小类型(Zero Sized Type, ZST), 不占空间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在Debug编译模式下, 多个 空结构体 实例是不同 的对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在在Release编译模式下, 会被优化为同一个 对象 (内存地址相同)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 标准库中表示全范围()的 RangeFull， 就是一个单元结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5183-结构体方法">5.18.3. 结构体方法<a href="#5183-结构体方法" class="hash-link" aria-label="Direct link to 5.18.3. 结构体方法" title="Direct link to 5.18.3. 结构体方法">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 结构体方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Site {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // &amp;self 关键字 总是第一个参数, 类似 Python</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn to_string(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // self 表示 struct 实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            format!(&quot;to string -&gt; {:?}&quot;, self)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;st.to_string() = {}&quot;, st.to_string());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 结构体关联函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //类似 Java 中的静态方法, 调用不依赖 struct 实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //没有 &amp;self 参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Site {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn create() -&gt; Site { // Site 可用 Self 替代</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Site {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                domain: String::from(&quot;new domain create()&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                name: String::from(&quot;xiaoyu&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                nation: String::from(&quot;nation&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                found: 2020,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let create_site = Site::create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;create_site = {:?}&quot;, create_site);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5184-new-type-模式-和-类型别名-self别名">5.18.4. new type 模式 和 类型别名 Self别名<a href="#5184-new-type-模式-和-类型别名-self别名" class="hash-link" aria-label="Direct link to 5.18.4. new type 模式 和 类型别名 Self别名" title="Direct link to 5.18.4. new type 模式 和 类型别名 Self别名">​</a></h3><p>当一个元组结构体只有一个字段的时候，称之为 New Type 模式</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 使用场景:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 明确语义: 为同类型的数据分别定义新的类型进行区分, 如 为 i32 类型分别定义 Hour, Second 类型 (这是为了能保证在编译时，编译期间即可发现错误。), 包装了一层</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 使复制语义的 类型具有移动语义; 比如 f64 本来是复制语义 ，而包装为 Miles(f64)之 后，因为结构体本身不能被自动实现 Copy，所以 Miles(f64)就成了移动语义。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 隐藏实际类型， 限制功能; 使用 Newtype模式包装的类型并不能被外界访问，除非提 供相应方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 给标准库中的结构实现标库中的 trait, 如给 Vector 实现 Display trait.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         由于孤儿规则, 这明显不行, 可以通过给 Vector 包装一层来达到目的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Wrapper(Vec&lt;String&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl std::fmt::Display for Wrapper {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn .....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //new type 惯用法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Years(i64);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Days(i64);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Years {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn to_days(&amp;self) -&gt; Days {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Days(self.0 * 365)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl Days {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /// 舍去不满一年的部分</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub fn to_years(&amp;self) -&gt; Years {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Years(self.0 / 365)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn old_enough(age: &amp;Years) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        age.0 &gt;= 18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let age = Years(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let age_days = age.to_days();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));// 只能传年单位的数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days)); //出错, 编译期间即可发现 // 不能传天单位的数字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类型别名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 也可以使用 type关键字为一个类型创建别名，如代码第 2行为 i32类型创建了一个别名 Int， 但是其本质还是 i32 类型，它所拥有的行为和 i32 是一样 的 。相 比之下， New Type 模式 属于 自定义类型，更加灵活</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //别名的主要用途是避免写出冗长的模板化代码（boilerplate code）。如 IoResult&lt;T&gt; 是 Result&lt;T, IoError&gt; 类型的别名。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum VeryVerboseEnumOfThingsToDoWithNumbers {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Add,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Subtract,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Creates a type alias</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = Operations::Add; // 能这么用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl VeryVerboseEnumOfThingsToDoWithNumbers {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn run(&amp;self, x: i32, y: i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            match self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Self 别名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Self::Add =&gt; x + y,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Self::Subtract =&gt; x - y,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `NanoSecond` 是 `u64` 的新名字。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type NanoSecond = u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Inch = u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过这个属性屏蔽警告。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[allow(non_camel_case_types)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type u64_t = u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `NanoSecond` = `Inch` = `u64_t` = `u64`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let nanoseconds: NanoSecond = 5 as u64_t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let inches: Inch = 2 as u64_t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5185-案例-彩色命令行输出">5.18.5. 案例 彩色命令行输出<a href="#5185-案例-彩色命令行输出" class="hash-link" aria-label="Direct link to 5.18.5. 案例 彩色命令行输出" title="Direct link to 5.18.5. 案例 彩色命令行输出">​</a></h3><p>main.rs </p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mod color;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use color::Colorized;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s=  &quot;hello&quot;.red().on_yellow();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>color.rs </p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::fmt::Display;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input: String, // 内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fg: String,    // 前景</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bg: String,    // 背景</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实现默认值, 对 color string 进行初始填充</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Default for ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn default() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            input: String::default(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fg: String::default(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bg: String::default(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub trait Colorized {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 关联常量, 和联类型类似， 由实现该 trait 的类型来指定常量的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里指定了默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const FG_RED: &amp;&#x27;static str = &quot;31&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const BG_YELLOW: &amp;&#x27;static str = &quot;43&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn red(self) -&gt; ColorString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_yellow(self) -&gt; ColorString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Colorized for ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn red(self) -&gt; ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fg: String::from(Self::FG_RED),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ..self</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_yellow(self) -&gt; ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bg: String::from(Self::BG_YELLOW),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ..self</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const FG_RED: &amp;&#x27;static str = &quot;31&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const BG_YELLOW: &amp;&#x27;static str = &quot;43&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a&gt; Colorized for &amp;&#x27;a str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn red(self) -&gt; ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            input: String::from(self),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fg: String::from(Self::FG_RED),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ..ColorString::default()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_yellow(self) -&gt; ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            input: String::from(self),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bg: String::from(Self::BG_YELLOW),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ..ColorString::default()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const FG_RED: &amp;&#x27;static str = &quot;31&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const BG_YELLOW: &amp;&#x27;static str = &quot;43&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl ColorString{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 组装 ansi 码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // \xlB[43;31m, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn compute_style(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut res = String::from(&quot;\x1B[&quot;);// ansi 码起始</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut has_wrote = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if !self.bg.is_empty() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.push_str(&amp;self.bg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            has_wrote = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if !self.fg.is_empty() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if has_wrote {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.push(&#x27;;&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.push_str(&amp;self.fg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res.push(&#x27;m&#x27;);// ansi 码结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Display for ColorString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#x27;_&gt;) -&gt; std::fmt::Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        f.write_str(&amp;self.compute_style())?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        write!(f, &quot;{}&quot;, self.input)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        write!(f, &quot;\x1B[0m&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="519-枚举">5.19. 枚举<a href="#519-枚举" class="hash-link" aria-label="Direct link to 5.19. 枚举" title="Direct link to 5.19. 枚举">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5191-枚举基本使用">5.19.1. 枚举基本使用<a href="#5191-枚举基本使用" class="hash-link" aria-label="Direct link to 5.19.1. 枚举基本使用" title="Direct link to 5.19.1. 枚举基本使用">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 枚举类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 枚举元素可以各不相同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn enum_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;-------------enum demo-----------------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       enum Resp&lt;T, E&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Obj(T),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Err(E),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn divide(a: i32, b: i32) -&gt; Resp&lt;i32, String&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if b == 0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return Resp::Err(&quot;分母不能为零&quot;.to_owned());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Resp::Obj(a / b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let a = divide(4, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let b = divide(4, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match a {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Resp::Obj(n) =&gt; println!(&quot;n: {}&quot;, n),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match b {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Resp::Err(msg) =&gt; println!(&quot;msg: {}&quot;, &amp;msg),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum Book {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Papery,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Book1(i32),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Book2(String),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Book3 {field1: String, field2: String},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let book = Book::Papery;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot; enum book = {:?}&quot;, book);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实例化带属性的枚举类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let boot1 = Book::Book1(11);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 错误, 没这个语法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;book1.0 = {}&quot;, boot1.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 正确</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;book1 = {:?}&quot;, boot1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 访问枚举类的属性, 必须借助 match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let book3 = Book::Book3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        field1: String::from(&quot;hello&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        field2: String::from(&quot;world&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match book3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Book::Papery =&gt; println!(&quot;book&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对于 元组, 由于没有字段名称, 需要临时指定一个形参</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Book::Book1(i) =&gt; println!(&quot;book1.i = {}&quot;, i),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Book::Book2(s) =&gt; println!(&quot;book2.s = {}&quot;, s),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Book::Book3{field1, field2} =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;book3.field1 = {}, book3.field2 = {}&quot;, field1, field2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt;  println!(&quot;no match&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5192-option">5.19.2. Option<a href="#5192-option" class="hash-link" aria-label="Direct link to 5.19.2. Option" title="Direct link to 5.19.2. Option">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Option 枚举类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //是 Rust 标准库中的枚举类，这个类用于填补 Rust 不支持 null 引用的空白</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // enum Option&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    Some(T),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用场景:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 初始化值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 作为函数的返回值, 表示空, or 出现的简单错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 作为函数可选参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 作为结构体的可选字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 作为结构体中可借出/载入的字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - 代表空指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 解开可以通过 match 模式匹配, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过 unwrap 系列方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - expect(&quot;error message&quot;) 解开 Some, 若 None, 则 panic!(&quot;error message&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // -  unwrap()    解开 Some, 若碰到 None, 则 panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - unwrap_or(T)  解开 Some, 若碰到 None, 则 返回指定的默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // - unwrap_or_else(FnOnce()-&gt;T) 解开 Some, 碰到 None, 则执行一段闭包 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let opt = Option::Some(&quot;Hello&quot;); // opt 允许为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match opt {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Option::Some(something) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;{}&quot;, something);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Option::None =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;opt is nothing&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 直接定义一个 &amp;str 类型的空值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //Option 是 Rust 编译器默认引入的，在使用时可以省略 Option:: 直接写 None 或者 Some()。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let opt: Option&lt;&amp;str&gt; = None;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match opt {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(something) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;{}&quot;, something);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        None =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;opt is nothing&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 流式处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 组合算子 combinator: 简化 match 处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // map()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // map_or() 可以为 None 指定默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // map_or_else()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 接受一个函数f, 返回一个option, 这个函数f:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  - 参数为option包含的元素, 返回值为处理后的元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 要求处理的option中元素可以是不同类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)] enum Food { Apple, Potato, Banana}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)] struct Peeled(Food);//削皮的食物</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)] struct Chopped(Food);//切块的食物</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)] struct Cooked(Food);// 烹煮的食物</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        food.map(|foo| Peeled(foo))// 闭包参数是Food 类型, 这里是解开了 Option, 返回 Option&lt;Peeled&gt; 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .map(|Peeled(foo)| Chopped(foo)) // 参数是 Peeled 类型, 这里解开了Option, Peeled</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .map(|Chopped(foo)| Cooked(foo))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match process(Some(Food::Apple)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(cooked) =&gt; println!(&quot;cooked: {:?}&quot;, cooked),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; println!(&quot;error&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // and_then() </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //接受一个函数f作为参数, 返回option, 函数f满足: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //- 参数为 option 包含的元素, 返回为option</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 要求处理的option中元素是相同类型, 比如都属于某个枚举类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn to_potato(food: Food) -&gt; Option&lt;Food&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(Food::Potato)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn to_banana(food: Food) -&gt; Option&lt;Food&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(Food::Banana)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match to_potato(Food::Apple).and_then(to_banana) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some(banana) =&gt; println!(&quot;banana: {:?}&quot;, banana),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; println!(&quot;error&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5193-c-风格的枚举">5.19.3. c 风格的枚举<a href="#5193-c-风格的枚举" class="hash-link" aria-label="Direct link to 5.19.3. c 风格的枚举" title="Direct link to 5.19.3. c 风格的枚举">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 拥有隐式辨别值（implicit discriminator，从 0 开始）的 enum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum Number {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Zero,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        One,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Two,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // c 风格枚举</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 拥有显式辨别值（explicit discriminator）的 enum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum Color {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Red = 0xff0000,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Green = 0x00ff00,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Blue = 0x0000ff,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `enum` 可以转成整形。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;zero is {}&quot;, Number::Zero as i32);//0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;one is {}&quot;, Number::One as i32);//1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;roses are #{:06x}&quot;, Color::Red as i32);//ff0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;violets are #{:06x}&quot;, Color::Blue as i32);//0000ff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5194-案例-彩色命令行输出优化">5.19.4. 案例 彩色命令行输出优化<a href="#5194-案例-彩色命令行输出优化" class="hash-link" aria-label="Direct link to 5.19.4. 案例 彩色命令行输出优化" title="Direct link to 5.19.4. 案例 彩色命令行输出优化">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::convert::From;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::str::FromStr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::string::String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::fmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Clone, Copy, Debug, PartialEq, Eq)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Color {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Red,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Yellow,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Blue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Color {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn to_fg_str(&amp;self) -&gt; &amp;str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match *self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Color::Red =&gt; &quot;31&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Color::Yellow =&gt; &quot;33&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Color::Blue =&gt; &quot;34&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn to_bg_str(&amp;self) -&gt; &amp;str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match *self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Color::Red =&gt; &quot;41&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Color::Yellow =&gt; &quot;43&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Color::Blue =&gt; &quot;44&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a&gt; From&lt;&amp;&#x27;a str&gt; for Color {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn from(src: &amp;str) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // parse 方法，要求目标类型必须实现 FromStr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        src.parse().unwrap_or(Color::Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl From&lt;String&gt; for Color {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn from(src: String) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        src.parse().unwrap_or(Color::Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl FromStr for Color {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Err = ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  from s仕 方法包含了 错误处理相关的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn from_str(src: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let src = src.to_lowercase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match src.as_ref() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;red&quot; =&gt; Ok(Color::Red),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;yellow&quot; =&gt; Ok(Color::Yellow),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;blue&quot; =&gt; Ok(Color::Blue),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; Err(()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Clone, Debug, PartialEq, Eq)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fgcolor: Option&lt;Color&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bgcolor: Option&lt;Color&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn compute_style(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut res = String::from(&quot;\x1B[&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut has_wrote = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if let Some(ref bgcolor) = self.bgcolor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if has_wrote {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.push(&#x27;;&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.push_str(bgcolor.to_bg_str());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            has_wrote = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if let Some(ref fgcolor) = self.fgcolor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if has_wrote {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.push(&#x27;;&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res.push_str(fgcolor.to_fg_str());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res.push(&#x27;m&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Default for ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn default() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            input: String::default(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fgcolor: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bgcolor: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// impl&lt;&#x27;a&gt; From&lt;&amp;&#x27;a str&gt; for ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//     fn from(s: &amp;&#x27;a str) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         ColoredString { input: String::from(s), ..ColoredString::default() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Colorize {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn red(self) -&gt; ColoredString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn yellow(self) -&gt; ColoredString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn blue(self) -&gt; ColoredString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Color实现了 From，所以对于 String和&amp;’a str类型的字符串均可通 过 into 方法转换为 Color</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_red(self) -&gt; ColoredString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_yellow(self) -&gt; ColoredString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_blue(self) -&gt; ColoredString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Colorize for ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn red(self) -&gt; ColoredString {self.color(Color::Red)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn yellow(self) -&gt; ColoredString {self.color(Color::Yellow)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn blue(self) -&gt; ColoredString {self.color(Color::Blue)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColoredString { fgcolor: Some(color.into()), ..self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_red(self) -&gt; ColoredString {self.on_color(Color::Red)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_yellow(self) -&gt; ColoredString {self.on_color(Color::Yellow)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_blue(self) -&gt; ColoredString {self.on_color(Color::Blue)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColoredString { bgcolor: Some(color.into()), ..self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a&gt; Colorize for &amp;&#x27;a str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn red(self) -&gt; ColoredString {self.color(Color::Red)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn yellow(self) -&gt; ColoredString {self.color(Color::Yellow)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn blue(self) -&gt; ColoredString {self.color(Color::Blue)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fgcolor: Some(color.into()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            input: String::from(self),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ..ColoredString::default()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_red(self) -&gt; ColoredString {self.on_color(Color::Red)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_yellow(self) -&gt; ColoredString {self.on_color(Color::Yellow)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_blue(self) -&gt; ColoredString {self.on_color(Color::Blue)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn on_color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bgcolor: Some(color.into()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            input: String::from(self),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ..ColoredString::default()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl fmt::Display for ColoredString {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut input = &amp;self.input.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try!(f.write_str(&amp;self.compute_style()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try!(f.write_str(input));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try!(f.write_str(&quot;\x1B[0m&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let red = &quot;red&quot;.red();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, red);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let yellow = &quot;yellow&quot;.yellow().on_blue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, yellow);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let blue = &quot;blue&quot;.blue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, blue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let red = &quot;red&quot;.color(&quot;red&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, red);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let yellow = &quot;yellow&quot;.on_color(&quot;yellow&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, yellow);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5195-实例-创建链表">5.19.5. 实例 创建链表<a href="#5195-实例-创建链表" class="hash-link" aria-label="Direct link to 5.19.5. 实例 创建链表" title="Direct link to 5.19.5. 实例 创建链表">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // enum 的一个常见用法就是创建链表（linked-list）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use List::*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum List {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Cons：元组结构体，包含链表的一个元素和一个指向下一节点的指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Cons(u32, Box&lt;List&gt;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Nil：末结点，表明链表结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Nil,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可以为 enum 定义方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl List {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建一个空的 List 实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn new() -&gt; List {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Nil</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理一个 List，在其头部插入新元素，并返回该 List</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // self 不加 &amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn prepend(self, elem: u32) -&gt; List {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // `Cons` 同样为 List 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Cons(elem, Box::new(self))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回 List 的长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn len(&amp;self) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // `self` 为 `&amp;List` 类型，`*self` 为 `List` 类型，匹配一个具体的 `T`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 类型要好过匹配引用 `&amp;T`。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            match *self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 不能得到 tail 的所有权，因为 `self` 是借用的；所以要使用引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 因此使用一个对 tail 的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Cons(_, ref tail) =&gt; 1 + tail.len(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // （递归的）基准情形（base case）：一个长度为 0 的空列表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Nil =&gt; 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回列表的字符串表示（该字符串是堆分配的）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn stringify(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            match *self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Cons(head, ref tail) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // `format!` 和 `print!` 类似，但返回的是一个堆分配的字符串，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    format!(&quot;{}, {}&quot;, head, tail.stringify())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Nil =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    format!(&quot;Nil&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // // 创建一个空链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // let mut list = List::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // // 追加一些元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // list = list.prepend(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // list = list.prepend(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // list = list.prepend(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // // 显示链表的最后状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // println!(&quot;linked list has length: {}&quot;, list.len());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // println!(&quot;{}&quot;, list.stringify());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="520-match-模式匹配">5.20. match 模式匹配<a href="#520-match-模式匹配" class="hash-link" aria-label="Direct link to 5.20. match 模式匹配" title="Direct link to 5.20. match 模式匹配">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5201-模式匹配简单使用">5.20.1. 模式匹配简单使用<a href="#5201-模式匹配简单使用" class="hash-link" aria-label="Direct link to 5.20.1. 模式匹配简单使用" title="Direct link to 5.20.1. 模式匹配简单使用">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// match 模式匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 类似 Java 中的 switch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 必须穷尽所有分支 (使用 _ 忽略某个情况), 每个分支返回同个类型 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn match_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;------------------------ match demo ------------------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可以对枚举类, 对整数、浮点数、字符和字符串切片引用（&amp;str）类型的数据进行分支选择,    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // match 返回的变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = match &quot;hello&quot;.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        5 =&gt; &quot;len = 5&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0 =&gt; &quot;len = 0&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; &quot;unkonwn len&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 作为函数返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实现一个缓存, 保存第一次处理后的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Cache&lt;T&gt; where T: Fn(i32) -&gt; i32 {  // 函数类型作为泛型, Fn 是一个 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        calc: T, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value: Option&lt;i32&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl&lt;T: Fn(i32) -&gt; i32&gt; Cache&lt;T&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn new(caculator: T) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Cache {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                caculator: caculator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                value: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn value(&amp;mut self, arg: i32) -&gt; i32 { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 外层 match 没有 return, 没有 分号 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            match self.value {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Some(v) =&gt; v, // 返回值只是返回给 match 表达式, 不是直接返回给了外层的函数, 若想直接返回给函数, 需要 return 关键字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                None =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    println!(&quot;第一次, arg = {}&quot;, arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    let v = (self.caculator)(arg);// 必须有括号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    self.value = Some(v);// self 必须可变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    v</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut ca = Cache::new(|x| x+1);// 这里可以省略参数类型是因为类型信息定义在前面的泛型中了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;arg = 1, v = {}&quot;, ca.value(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;arg = 1, v = {}&quot;, ca.value(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 和 if 合用的匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match value.log2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       x if x.is_normal() =&gt; Some(x),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       _                      =&gt; None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5202-if-lef-while-let-语法糖">5.20.2. if lef while let 语法糖<a href="#5202-if-lef-while-let-语法糖" class="hash-link" aria-label="Direct link to 5.20.2. if lef while let 语法糖" title="Direct link to 5.20.2. if lef while let 语法糖">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    // if let 语法糖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //适用于只区分两种情况的 match 语句</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 语法:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // if let 匹配值 = 源变量 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    语句块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum Book {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Papery(u32),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Electronic(String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let book = Book::Electronic(String::from(&quot;url&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if let Book::Papery(index) = book {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Papery {}&quot;, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Not papery book&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类似的还有 while let 语法糖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while let Some(v) = xx_vec.pop() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="521-错误处理">5.21. 错误处理<a href="#521-错误处理" class="hash-link" aria-label="Direct link to 5.21. 错误处理" title="Direct link to 5.21. 错误处理">​</a></h2><p><a href="https://www.v2ex.com/t/843118#reply6" target="_blank" rel="noopener noreferrer">https://www.v2ex.com/t/843118#reply6</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5211-断言">5.21.1. 断言<a href="#5211-断言" class="hash-link" aria-label="Direct link to 5.21.1. 断言" title="Direct link to 5.21.1. 断言">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// assert 系列宏在调试( Debug)和发布( Release)模式下均可用， 并且不能被禁用。 debug_assert系列宏只在调试模式下起作用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 尽量使用 debug_assert 系列宏较小性能开销</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 底层实际也是使用 panic! 宏引发线程恐慌</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • assert!， 用于断言布尔表达式在运行时一定返回 true。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • assert_eq!， 用于断 言两个表达式是否相等(使用 PartialEq)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • assert_ne!， 用于断言两个表达式是否不相等(使用 PartialEq)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • debug_assert!， 等价于 asse此!，只能用于调试模式。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • debug assert_eq!， 等价于 asse此一eq!，只能用于调试模式。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • debug_assert_ne!， 等价于 assert ne!，只能用于调试模式 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 均会引发线程恐慌, 同时输出错误信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">assert! (x,&quot;x wasn’t true&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">debug_assert!(a + b == 30,&quot;a={), b = {}&quot;, a, b);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5212-panic-和-abort">5.21.2. panic 和 Abort<a href="#5212-panic-和-abort" class="hash-link" aria-label="Direct link to 5.21.2. panic 和 Abort" title="Direct link to 5.21.2. panic 和 Abort">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// panic 为线程恐慌, 会造成应用程 序以非零退出码退出进程， 也就是发生崩溃</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Abort 为线程终止, 将进程 正常中止 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// RUST_BACKTRACE=1 cargo run 这种方式运行带有回溯, 碰到 panic!(&quot;xxx&quot;) 会显示 backtrace</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 如果想使一个可恢复错误按不可恢复错误处理(类比java 中 将 exceptin 转为 runtime exception)，Result 类提供了两个办法：unwrap() 和 expect(message: &amp;str) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// https://rust-cli.github.io/book/tutorial/errors.html</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn error_handling() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用 panic!() 宏: 对于不可恢复错误使用 panic! 宏来处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = File::open(&quot;hello.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match f {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(file) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;File opened successfully.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(err) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;Failed to open the file.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            panic!(&quot;{:?}&quot;, err);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // if let 语法糖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = File::open(&quot;hello.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if let Ok(file) = f {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;File opened successfully.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Failed to open the file.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       panic!(&quot;error&quot;); // panic 会中断程序, 若不希望中断程序, 不要 panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 简化写法: 直接解包装, 可恢复异常也会 panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //不会为函数产生返回值, 而是直接 panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f1 = File::open(&quot;hello.txt&quot;).unwrap(); //原理: 在 Result 为 Err 时调用 panic! 宏</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f2 = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open.&quot;);//expect 能够向 panic! 宏发送一段指定的错误信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自己控制是否 panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unwrap_or_else(|e| {  panic!(&quot;failed to execute process: {}&quot;, e)})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5213-result--和-问号操作符">5.21.3. Result  和 问号操作符<a href="#5213-result--和-问号操作符" class="hash-link" aria-label="Direct link to 5.21.3. Result  和 问号操作符" title="Direct link to 5.21.3. Result  和 问号操作符">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 可恢复错误, 用 Result&lt;T, E&gt; 类来处理，,类比 java 中 的 exception</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// //在 Rust 标准库中可能产生异常的函数的返回值都是 Result 类型的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// enum Result&lt;T, E&gt; { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///   Ok(T),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///   Err(E),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 异常传递, 函数返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn func(i: i32) -&gt; Result&lt;i32, bool&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if i &gt;= 0 { Ok(i) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else { Err(false) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn g(i: i32) -&gt; Result&lt;i32, bool&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let t = func(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return match t { // 或者省略 return 和分号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ok(i) =&gt; Ok(i), // 原样传给 match, match作为最终结构传给函数返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Err(b) =&gt; Err(b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更好的写法: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //? 符的实际作用是将 Result 类非异常的值直接取出，如果有异常就将异常 Result 返回出去。所以，? 符仅用于返回值类型为 Result&lt;T, E&gt; 的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //?号 是 “要么 unwrap 要么 return Err(From::from(err))”。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 会为函数产生返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn g1(i: i32) -&gt; Result&lt;i32, bool&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let t = func(i)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(t) // 因为确定 t 不是 Err, t 在这里已经是 i32 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r = g1(10000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if let Ok(v) = r {println!(&quot;ok, r = {}&quot;, v)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else { println!(&quot;Err&quot;)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取 error 类型, 处理异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn read_text_from_file(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut f = File::open(path)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut s = String::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        f.read_to_string(&amp;mut s)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let str_file = read_text_from_file(&quot;hello.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match str_file {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(s) =&gt; println!(&quot;{}&quot;, s),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(e) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            match e.kind() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                io::ErrorKind::NotFound =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    println!(&quot;No such file&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                _ =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    println!(&quot;Cannot read the file&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Result 的 map, and_then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类似 option, result也有自己的链式处理方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::num::ParseIntError;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // parse() 返回的是 result 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更推荐的写法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 推荐给 太长的类型起个别名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply1(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let first_number = first_number_str.parse::&lt;i32&gt;()?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let second_number = second_number_str.parse::&lt;i32&gt;()?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(first_number * second_number)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5214-错误装箱-自定义异常">5.21.4. 错误装箱 自定义异常<a href="#5214-错误装箱-自定义异常" class="hash-link" aria-label="Direct link to 5.21.4. 错误装箱 自定义异常" title="Direct link to 5.21.4. 错误装箱 自定义异常">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //装箱可以保存原始错误信息, 坏处就是，被包装的错误类型只能在运行时了解，而不能被静态地 判别。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //对任何实现了 Error trait 的类型，标准库的 Box 通过 From 为它们提供了 到 Box&lt;Error&gt; 的转换, 只要调用 XxxError.into() 即装箱</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::fmt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 为 `Box&lt;error::Error&gt;` 取别名。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自定义异常 /////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 还必须同时实现 Debug 和 Display</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug, Clone)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct EmptyVec;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl fmt::Display for EmptyVec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            write!(f, &quot;invalid first item to double&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl error::Error for EmptyVec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn description(&amp;self) -&gt; &amp;str {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;invalid first item to double&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 泛型错误。没有记录其内部原因。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将第一个数字乘以2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vec.first()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .ok_or_else(|| EmptyVec.into())  // 装箱</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .and_then(|s| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                s.parse::&lt;i32&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .map_err(|e| e.into())  // 装箱</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .map(|i| 2 * i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更好的写法: 使用 ? 号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ?号 是 “要么 unwrap 要么 return Err(From::from(err))”。From::from 是 不同类型间的转换工具，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let first = vec.first().ok_or(EmptyVec)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let parsed = first.parse::&lt;i32&gt;()?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(2 * parsed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5215-捕获异常">5.21.5. 捕获异常<a href="#5215-捕获异常" class="hash-link" aria-label="Direct link to 5.21.5. 捕获异常" title="Direct link to 5.21.5. 捕获异常">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 恐慌安全: 发生 panic后, 代码终止执行, 后续的资源回收相关的代码不会执行, 可能引发问题, 防止这样的问题就是保证恐慌安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// rust 通过 raii机制, 保证了基本的恐慌安全, 即使在 safe rust 中发生 panic, 也能保证资源回收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 但是若 panic 发生在 unsafe rust 里面, 就无法保证恐慌安全了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// catch_unwind 方法来让开发者捕获恐慌，恢复当前线程。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 接收的是一个正常的闭包，在该闭包中 并未发生恐慌，所 以正常执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let result = panic::catch_unwind(|| { println!(&quot;hello!&quot;); });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">assert!(result.is_ok());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 捕获此恐慌，并恢复当前线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let result = panic::catch_unwind(|| { panic!(&quot;oh no!&quot;); });// 输 出 结果 中打印 了恐慌信息，但是并没有影 响 到后续代码 的执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">assert!(result.is_err());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{}&quot;, sum(1, 2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 set_hook 自定义panic 消息消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// set_hook 是全局性设置， 并不是只针对单个代码模块的, 可以和 take_hook 配合使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">panic::set_hook(Box::new(|panic_info| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if let Some(location) = panic_info.location() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;panic occurred &#x27;{}&#x27; at {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            location.file(), location.line()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;can&#x27;t get location information...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let result = panic::catch_unwind(|| { panic!(&quot;oh no!&quot;); });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">assert!(result.is_err());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5216-错误处理进化过程">5.21.6. 错误处理进化过程<a href="#5216-错误处理进化过程" class="hash-link" aria-label="Direct link to 5.21.6. 错误处理进化过程" title="Direct link to 5.21.6. 错误处理进化过程">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 直接解除包装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 读取文件内容, 一步到位</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let content = std::fs::read_to_string(&amp;args.path).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let content = match std::fs::read_to_string(&amp;args.path) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(content) =&gt; content,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(err) =&gt; panic!(&quot;&gt;&gt;&gt; Error occurred: {}&quot;, err),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 返回 error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 需要 main 返回 Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let content = match std::fs::read_to_string(&amp;args.path) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(content) =&gt; content,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(error) =&gt; {return Err(error.into())},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用问号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let content = std::fs::read_to_string(&amp;args.path)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 添加错误上下文, 自定义异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    main -&gt; Result&lt;(),SomeErr&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let content = std::fs::read_to_string(&amp;args.path)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .map_err(|err| SomeErr(format!(&quot;Error of reading {}: {}&quot;, &amp;args.path, err)))?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用第三方库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use failure::ResultExt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use exitfailure::ExitFailure;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let ref path: PathBuf = args.path;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let content = std::fs::read_to_string(path)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .with_context(|_| format!(&quot;could not read file {}&quot;, path.to_str().unwrap()))?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5217-第三方库处理异常">5.21.7. 第三方库处理异常<a href="#5217-第三方库处理异常" class="hash-link" aria-label="Direct link to 5.21.7. 第三方库处理异常" title="Direct link to 5.21.7. 第三方库处理异常">​</a></h3><p>anyhow + thiserror</p><p><a href="https://github.com/rust-cli/human-panic" target="_blank" rel="noopener noreferrer">https://github.com/rust-cli/human-panic</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="522-io">5.22. io<a href="#522-io" class="hash-link" aria-label="Direct link to 5.22. io" title="Direct link to 5.22. io">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5221-命令行参数">5.22.1. 命令行参数<a href="#5221-命令行参数" class="hash-link" aria-label="Direct link to 5.22.1. 命令行参数" title="Direct link to 5.22.1. 命令行参数">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn io_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let args = std::env::args();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;args: {:?}&quot;, args);//Args { inner: [&quot;target/debug/hello&quot;, &quot;main.rs&quot;] }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for item in args {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;arg: {}&quot;, item);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //arg: target/debug/hello</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //arg: main.rs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    args.next().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arg0 = args.next().unwrap();// 命令本身, 拿到参数要两个 args.next()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 或者一步到位</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 或者通过 vector 收集</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let args: Vec&lt;String&gt; = env::args().collect();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //命令行输入文本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let secret_number = rand::thread_rng().gen_range(1, 101);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Please input your guess.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut guess = String::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        io::stdin()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .read_line(&amp;mut guess)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .expect(&quot;Failed to read line&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let guess: u32 = match guess.trim().parse() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ok(num) =&gt; num,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Err(_) =&gt; continue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;You guessed: {}&quot;, guess);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match guess.cmp(&amp;secret_number) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ordering::Equal =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                println!(&quot;You win!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5222-文件-io">5.22.2. 文件 io<a href="#5222-文件-io" class="hash-link" aria-label="Direct link to 5.22.2. 文件 io" title="Direct link to 5.22.2. 文件 io">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // //////////////////////////  文件 io //////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::fs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::io::prelude::*; //涉及到 write 需要 万能导入 prelude</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建写入文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //静态方法，以 可写 模式打开文件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果文件存在则清空旧内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果文件不存在则新建                  类似 echo &quot;xxxx&quot; &gt; path</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut file = fs::File::create(&quot;./cc.md&quot;).expect(&quot;create file error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file.write_all(&quot;hello &quot;.as_bytes()).expect(&quot;write error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file.write_all(&quot; world&quot;.as_bytes()).expect(&quot;write error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file.write_all(&quot;\n你好&quot;.as_bytes()).expect(&quot;write error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 读取文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 一次性读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 静态方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let text = std::fs::read_to_string(&quot;./Cargo.toml&quot;).unwrap(); // 相对路径是相对于根目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, text);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut file = fs::File::open(&quot;./cc.md&quot;).expect(&quot;open error&quot;);// 只读模式打开, 相当于 cat &lt;path&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut str_buf = String::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实例方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file.read_to_string(&amp;mut str_buf).expect(&quot;read error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, str_buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //  append() 用于将文件的打开模式设置为 追加模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //此外还有 .read(true).write(true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 比如  OpenOptions::new().create(true).write(true).open(path) 可创建, 可写模式打开 , 相当于 touch xxx , 有则不动, 无则创建</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut file = fs::OpenOptions::new().append(true).open(&quot;./cc.md&quot;).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file.write_all(&quot;\nappend something...&quot;.as_bytes()).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let updated_content = fs::read_to_string(&quot;./cc.md&quot;).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, updated_content);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 读写二进制文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 文件流读取, 多次读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 二进制 使用 std::fs::read(&quot;&quot;) 读取 u8 类型集合</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 复制文件的 demo:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut buffer = [0u8; 5];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut file = fs::File::open(&quot;cc.md&quot;).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;文件打开成功：{:?}&quot;,file);//File { fd: 3, path: &quot;.../data.txt&quot;, read: true, write: false }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file.read(&amp;mut buffer).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file.read(&amp;mut buffer).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fs::remove_file(&quot;cc.md&quot;).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 其他文件系统操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建 目录, 返回 io::Result&lt;()&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fs::create_dir(&quot;a&quot;) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 递归创建,目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fs::create_dir_all(&quot;a/c/d&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建符号链接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //读取目录下的所有的内容，返回 `io::Result&lt;Vec&lt;Path&gt;&gt;`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match fs::read_dir(&quot;a&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(paths) =&gt; for path in paths {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 移除一个空目录，返回 `io::Result&lt;()&gt;`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fs::remove_dir(&quot;a/c/d&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;-----------------meta -------------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // metadata 元数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遍历目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let meta = fs::metadata(&quot;./src&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(Metadata {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            file_type: FileType(FileType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                mode: 16895</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            is_dir: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            is_file: false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            permissions: Permissions(FilePermissions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                mode: 16895</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            modified: Ok(SystemTime {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tv_sec: 1597127845,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tv_nsec: 217049100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            accessed: Ok(SystemTime {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tv_sec: 1597132516,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tv_nsec: 30962100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            created: Err(Custom {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                kind: Other,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                error: &quot;creation time is not available for the filesystem&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;meta = {:?}&quot;, meta);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;src is dir? {}&quot;, meta.unwrap().is_dir());//true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn copy_file() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut command_line: std::env::Args = std::env::args();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   command_line.next().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 跳过程序名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 原文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let source = command_line.next().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 新文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let destination = command_line.next().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut file_in = std::fs::File::open(source).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut file_out = std::fs::File::create(destination).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut buffer = [0u8; 4096];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   use std::io::Write;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      let nbytes = file_in.read(&amp;mut buffer).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      file_out.write(&amp;buffer[..nbytes]).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if nbytes &lt; buffer.len() { break; }// 如果某次读取没有将 buf 读满, 则写完后退出循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="523-面向对象-oop">5.23. 面向对象 oop<a href="#523-面向对象-oop" class="hash-link" aria-label="Direct link to 5.23. 面向对象 oop" title="Direct link to 5.23. 面向对象 oop">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5231-可见性">5.23.1. 可见性<a href="#5231-可见性" class="hash-link" aria-label="Direct link to 5.23.1. 可见性" title="Direct link to 5.23.1. 可见性">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// rust 下所有元素都是默认私有的, 无法在外部使用, 通过 pub 声明为 公开, 才能在外部使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - pub， 可以对外 暴露 公共接口，隐藏内部实现细节 (可用于任何对象)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - pub(crate)，对整个 crate 可见 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - pub(in Path)，其中 Path是模块路径(以 crate 开头), 表示只能在 Path 指定的模块中访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - pub(self)， 等价于 pub(in self)，表示只限当前模块可见/使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - pub(super)， 等价于 pub(in super)，表示在当前模块和父模块中可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 结构体中的字段, 需要单独使用 pub 关键字来 改变其 可见性 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2015 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub mod outer_mod {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub(self) fn outer_mod_fn() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub mod inner_mod {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // use outer_mod::outer_mod_fn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对外层模块 `outer_mod` 可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub(in outer_mod) fn outer_mod_visible_fn() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对整个crate可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub(crate) fn crate_visible_fn() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // `outer_mod` 内部可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub(super) fn super_mod_visible_fn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 访问同一模块的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inner_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 访问父模块的函数需要使用“::”前缀</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ::outer_mod::outer_mod_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 仅在`inner_mod`可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub(self) fn inner_mod_visible_fn() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn foo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inner_mod::outer_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inner_mod::crate_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inner_mod::super_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 不能使用inner_mod 的私有函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // inner_mod::inner_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn bar() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 该函数对整个crate可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outer_mod::inner_mod::crate_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 该函数只对outer_mod可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // outer_mod::inner_mod::super_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 该函数只对outer_mod可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // outer_mod::inner_mod::outer_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过foo函数调用内部细节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outer_mod::foo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() { bar() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2018</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub mod outer_mod {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub(self) fn outer_mod_fn() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub mod inner_mod {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 在Rust 2018 edtion 模块系统必须使用use导入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        use crate::outer_mod::outer_mod_fn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对外层模块 `outer_mod` 可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub(in crate::outer_mod)  fn outer_mod_visible_fn() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对整个crate可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub(crate) fn crate_visible_fn() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // `outer_mod` 内部可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub(super) fn super_mod_visible_fn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 访问同一模块的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            inner_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用use导入了outer_mod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            outer_mod_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 仅在`inner_mod`可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub(self) fn inner_mod_visible_fn() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn foo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inner_mod::outer_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inner_mod::crate_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inner_mod::super_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 不能使用inner_mod 的私有函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // inner_mod::inner_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn bar() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 该函数对整个crate可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outer_mod::inner_mod::crate_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 该函数只对outer_mod可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // outer_mod::inner_mod::super_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 该函数只对outer_mod可见</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // outer_mod::inner_mod::outer_mod_visible_fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通过foo函数调用内部细节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    outer_mod::foo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() { bar() }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5232-多态">5.23.2. 多态<a href="#5232-多态" class="hash-link" aria-label="Direct link to 5.23.2. 多态" title="Direct link to 5.23.2. 多态">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn oop_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 多态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub struct Screen {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,// Box&lt;dyn Draw&gt; 为任何实现了 Draw trait 的类型的替身</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 另外多态例子</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        width : u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        height : u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x : u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        y : u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        radius : u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait  IShape  { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn area(&amp;self) -&gt; f32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn to_string(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl IShape  for Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn area(&amp;self) -&gt; f32 { (self.height * self.width) as f32 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn to_string(&amp;self) -&gt;String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            format!(&quot;Rectangle -&gt; width={} height={} area={}&quot;, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    self.width, self.height, self.area())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::f64::consts::PI;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl IShape  for Circle  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn area(&amp;self) -&gt; f32 { (self.radius * self.radius) as f32 * PI as f32}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn to_string(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            format!(&quot;Circle -&gt; x={}, y={}, area={}&quot;, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    self.x, self.y, self.area())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::vec::Vec;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let rect = Box::new( Rectangle { width: 4, height: 6});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let circle = Box::new( Circle { x: 0, y:0, radius: 5});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v : Vec&lt;Box&gt; = Vec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.push(rect);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.push(circle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in v.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;area={}&quot;, i.area() );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{}&quot;, i.to_string() );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5233-向下转型">5.23.3. 向下转型<a href="#5233-向下转型" class="hash-link" aria-label="Direct link to 5.23.3. 向下转型" title="Direct link to 5.23.3. 向下转型">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //向下转型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //先得让 IShape 继承于 Any ，并增加一个 as_any() 的转型接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::any::Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trait  IShape : Any + &#x27;static  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn as_any(&amp;self) -&gt; &amp;dyn Any; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        …… …… …… </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //然后，在具体类中实现这个接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl IShape  for Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn as_any(&amp;self) -&gt; &amp;dyn Any { self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        …… …… …… </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl IShape  for Circle  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn as_any(&amp;self) -&gt; &amp;dyn Any { self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        …… …… …… </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut v : Vec&lt;Box&lt;dyn IShape&gt;&gt; = Vec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.push(rect);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.push(circle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in v.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if let Some(s) = i.as_any().downcast_ref::&lt;Rectangle&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;downcast - Rectangle w={}, h={}&quot;, s.width, s.height);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else if let Some(s) = i.as_any().downcast_ref::&lt;Circle&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;downcast - Circle x={}, y={}, r={}&quot;, s.x, s.y, s.radius);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;invaild type&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5234-各种self区分使用">5.23.4. 各种self区分使用<a href="#5234-各种self区分使用" class="hash-link" aria-label="Direct link to 5.23.4. 各种self区分使用" title="Direct link to 5.23.4. 各种self区分使用">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&amp;self           常用, 表示当前对象的引用, 不可变, 无法修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&amp;mut self       常用, 表示当前对象的引用, 可变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">self            不常用, 表示当前对象本身, 操作完成后, 当前对象无法再使用,会被丢弃回收 (场景: 析构函数)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mut self        不常用 ..... 操作完成被丢弃</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5235-设计模式">5.23.5. 设计模式<a href="#5235-设计模式" class="hash-link" aria-label="Direct link to 5.23.5. 设计模式" title="Direct link to 5.23.5. 设计模式">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52351-建造者模式">5.23.5.1. 建造者模式<a href="#52351-建造者模式" class="hash-link" aria-label="Direct link to 5.23.5.1. 建造者模式" title="Direct link to 5.23.5.1. 建造者模式">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// std::process::Command 就使用了 建造者模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: f64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    y: f64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    radius: f64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct CircleBuilder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: f64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    y: f64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    radius: f64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn area(&amp;self) -&gt; f64 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        std::f64::consts::PI * (self.radius * self.radius)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new() -&gt; CircleBuilder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CircleBuilder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            x: 0.0, y: 0.0, radius: 1.0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl CircleBuilder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       self.x = coordinate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       self</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       self.y = coordinate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       self</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       self.radius = radius;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      self</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   fn build(&amp;self) -&gt; Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           x: self.x, y: self.y, radius: self.radius,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52352-访问者模式">5.23.5.2. 访问者模式<a href="#52352-访问者模式" class="hash-link" aria-label="Direct link to 5.23.5.2. 访问者模式" title="Direct link to 5.23.5.2. 访问者模式">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 用于将数据结构和作用于结构上的操作解祸。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 访问者模式一般包含两个层 次:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 定义需要操作的元素。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 定义相关的操作. 一般将操作封装到一个 trait 中, 针对不同的元素, 有不同的方法实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Serde的架构是访问者模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::any::Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait HouseElement {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn accept(&amp;self, visitor: &amp;HouseElementVisitor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any(&amp;self) -&gt; &amp;Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait HouseElementVisitor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn visit(&amp;self, element: &amp;HouseElement);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct House {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    components: Vec&lt;Box&lt;HouseElement&gt;&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl House {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        House {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            components: vec![Box::new(Livingroom::new())],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl HouseElement for House {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn accept(&amp;self, visitor: &amp;HouseElementVisitor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for component in self.components.iter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            component.accept(visitor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        visitor.visit(self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any(&amp;self) -&gt; &amp;Any { self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Livingroom;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Livingroom {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new() -&gt; Self { Livingroom }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl HouseElement for Livingroom {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn accept(&amp;self, visitor: &amp;HouseElementVisitor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        visitor.visit(self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any(&amp;self) -&gt; &amp;Any { self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct HouseElementListVisitor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl HouseElementListVisitor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new() -&gt; Self { HouseElementListVisitor }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl HouseElementVisitor for  HouseElementListVisitor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn visit(&amp;self, element: &amp;HouseElement) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match element.as_any() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            house if house.is::&lt;House&gt;() =&gt; println!(&quot;Visiting the house...&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            living if living.is::&lt;Livingroom&gt;() =&gt; println!(&quot;Visiting the Living room...&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct HouseElementDemolishVisitor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl HouseElementDemolishVisitor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn new() -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HouseElementDemolishVisitor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl HouseElementVisitor for HouseElementDemolishVisitor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn visit(&amp;self, element: &amp;HouseElement) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match element.as_any() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            house if house.is::&lt;House&gt;() =&gt; println!(&quot;Annihilating the house...!!!&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            living if living.is::&lt;Livingroom&gt;() =&gt; println!(&quot;Bombing the Living room...!!!&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let house = House::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // simply print out the house elements</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    house.accept(&amp;HouseElementListVisitor::new());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // do something with the elements of a house</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    house.accept(&amp;HouseElementDemolishVisitor::new());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52353-raii模式">5.23.5.3. raii模式<a href="#52353-raii模式" class="hash-link" aria-label="Direct link to 5.23.5.3. raii模式" title="Direct link to 5.23.5.3. raii模式">​</a></h4><p>重构后的代码:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">利用Rust的ownership（linear/affine type）来设计接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Refact</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. 去掉letter的Clone，使用所有权保证其唯一性；并且信封的wrap方法只接受获得所有权的信封，而非引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 使用类型系统来保证信封的唯一性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 使用RAII机制来管理收尾逻辑，比如实现Drop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">其他示例：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. http response</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. steaming engine</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// #[derive(Clone)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Letter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    text: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct EmptyEnvelope {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct ClosedEnvelope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    letter: Letter,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct PickupLorryHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    done: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Letter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn new(text: String) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Letter {text: text}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl EmptyEnvelope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn wrap(self, letter: Letter) -&gt; ClosedEnvelope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ClosedEnvelope {letter: letter}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn buy_prestamped_envelope() -&gt; EmptyEnvelope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EmptyEnvelope {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl PickupLorryHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn pickup(&amp;mut self, envelope: ClosedEnvelope) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*give letter*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn done(self) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for PickupLorryHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;sent&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn order_pickup() -&gt; PickupLorryHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PickupLorryHandle {done: false , /* other handles */}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let letter = Letter::new(String::from(&quot;Dear RustFest&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let envelope = buy_prestamped_envelope();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let closed_envelope = envelope.wrap(letter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut lorry = order_pickup();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lorry.pickup(closed_envelope);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>有问题的代码:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">利用Rust的ownership（linear/affine type）来设计接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">存在的问题：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. Letter有可能复制多份到多个信封（envelope）里，不安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 信封里有可能有信，也有可能没有信, 可能寄出的是空信封；或者同一个信封装多次不同的信件, 造成信件的覆盖，不安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 有没有把信交给邮车也是无法保证，不安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 信纸</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Clone)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Letter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    text: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 信封</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Envelope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    letter: Option&lt;Letter&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 信件处理器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct PickupLorryHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    done: bool,//是否寄出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Letter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn new(text: String) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Letter {text: text}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Envelope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 装信纸进去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn wrap(&amp;mut self, letter: &amp;Letter){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.letter = Some(letter.clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建空的信封</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn buy_prestamped_envelope() -&gt; Envelope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Envelope {letter: None}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl PickupLorryHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 装车</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn pickup(&amp;mut self, envelope: &amp;Envelope) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*give letter*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 寄出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn done(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.done = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;sent&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建处理器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn order_pickup() -&gt; PickupLorryHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PickupLorryHandle {done: false , /* other handles */}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let letter = Letter::new(String::from(&quot;Dear RustFest&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut envelope = buy_prestamped_envelope();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    envelope.wrap(&amp;letter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut lorry = order_pickup();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lorry.pickup(&amp;envelope);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lorry.done();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn builder_pattern(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unimplemented!();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="524-子进程">5.24. 子进程<a href="#524-子进程" class="hash-link" aria-label="Direct link to 5.24. 子进程" title="Direct link to 5.24. 子进程">​</a></h2><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 子进程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// process::Output 结构体表示已结束的子进程（child process）的输出，而 process::Command 结构体是一个进程创建者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// std::Child 结构体代表了一个正在运行的子进程，它暴露了 stdin（标准 输入），stdout（标准输出） 和 stderr（标准错误） 句柄，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 从而可以通过管道与 所代表的进程交互</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn sub_process_command() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;-------------sub_process_command--------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::process::Command;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let output = Command::new(&quot;rustc&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .arg(&quot;--version&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .output().unwrap_or_else(|e| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            panic!(&quot;failed to execute process: {}&quot;, e)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if output.status.success() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s = String::from_utf8_lossy(&amp;output.stdout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s = String::from_utf8_lossy(&amp;output.stderr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 管道</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::error::Error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::io::prelude::*; // 隐藏导入 万能导入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::process::{Stdio};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static PANGRAM: &amp;&#x27;static str = &quot;the quick brown fox jumped over the lazy dog\n&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 启动 `wc` 命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let process = match Command::new(&quot;wc&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .stdin(Stdio::piped())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .stdout(Stdio::piped())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .spawn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(why) =&gt; panic!(&quot;couldn&#x27;t spawn wc: {}&quot;, why.description()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(process) =&gt; process,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将字符串写入 `wc` 的 `stdin`。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `stdin` 拥有 `Option&lt;ChildStdin&gt;` 类型，不过我们已经知道这个实例不为空值，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因而可以直接 `unwrap 它。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(why) =&gt; panic!(&quot;couldn&#x27;t write to wc stdin: {}&quot;, why.description()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因为 `stdin` 在上面调用后就不再存活，所以它被 `drop` 了，管道也被关闭。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若管道不关闭,  `wc` 就不会开始处理我们刚刚发送的输入。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = String::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match process.stdout.unwrap().read_to_string(&amp;mut s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Err(why) =&gt; panic!(&quot;couldn&#x27;t read wc stdout: {}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           why.description()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //如果你想等待一个 process::Child 完成，就必须调用 Child::wait，这会返回 一个 process::ExitStatus。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _result = child.wait().unwrap(); // 必须调用 wait() 等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;reached end of main&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="525-反射">5.25. 反射<a href="#525-反射" class="hash-link" aria-label="Direct link to 5.25. 反射" title="Direct link to 5.25. 反射">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 标准库提供了 std::any::Any 来支持运行时反射。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 可以接收任何静态生命周期类型 即 &#x27;static 类型, 不能接收非静态生命周期的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let v1 = 0xc0ffee_u32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v2 = E::He;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v3 = S { x: 0xde, y: 0xad, z: 0xbeef };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v4 = &quot;rust&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut a: &amp;Any; // trait object</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a = &amp;v1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 判断是否属于某种类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(a.is::&lt;u32&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 全局唯一类型标识符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 等价 get_type_id()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // TypeId { t: 12849923012446332737 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, TypeId::of::&lt;u32&gt;());   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a = &amp;v2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(a.is::&lt;E&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // TypeId { t: 15527215023668350898 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, TypeId::of::&lt;E&gt;());   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a = &amp;v3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(a.is::&lt;S&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // TypeId { t: 17868507538031848664 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, TypeId::of::&lt;S&gt;());   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a = &amp;v4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(a.is::&lt;&amp;str&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // TypeId { t: 1229646359891580772 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, TypeId::of::&lt;&amp;str&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 向下转型为具体类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::any::Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum E { H, He, Li}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct S { x: u8, y: u8, z: u16 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 参数除使用&amp;Any外，也可以使用 Box&lt;Any&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn print_any(a: &amp;Any) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if let Some(v) = a.downcast_ref::&lt;u32&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;u32 {:x}&quot;, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if let Some(v) = a.downcast_ref::&lt;E&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;enum E {:?}&quot;, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if let Some(v) = a.downcast_ref::&lt;S&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;struct S {:x} {:x} {:x}&quot;, v.x, v.y, v.z);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;else!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print_any(&amp; 0xc0ffee_u32);                       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print_any(&amp; E::He);                             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print_any(&amp; S{ x: 0xde, y: 0xad, z: 0xbeef }); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print_any(&amp; &quot;rust&quot;);                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print_any(&amp; &quot;hoge&quot;);                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 非静态生命周期的类型未实现Any, 无法被 Any 类型接收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::any::Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct UnStatic&lt;&#x27;a&gt; { x: &amp;&#x27;a i32 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let a = 42;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let v = UnStatic { x: &amp;a };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut any: &amp;Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        any = &amp;v;  // Compile Error!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 因为 使用了 静态生命周期类型来创建 UnStatic, 使得 UnStatic 也变为 了静态生命周期类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static ANSWER: i32 = 42;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let v = UnStatic { x: &amp;ANSWER };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut a: &amp;Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        a = &amp;v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert!(a.is::&lt;UnStatic&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="526-宏">5.26. 宏<a href="#526-宏" class="hash-link" aria-label="Direct link to 5.26. 宏" title="Direct link to 5.26. 宏">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5261-宏基本介绍">5.26.1. 宏基本介绍<a href="#5261-宏基本介绍" class="hash-link" aria-label="Direct link to 5.26.1. 宏基本介绍" title="Direct link to 5.26.1. 宏基本介绍">​</a></h3><p><img loading="lazy" alt="rust macro process" src="/en/assets/images/rust_macro_process-ee8b27ee3a95c102b98fc156cdce0bf8.png" width="1472" height="1230" class="img_ev3q"></p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 可进行元编程（metaprogramming）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 宏并不产 生函数调用，而是展开成源码，并和程序的其余部分一起被编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 使用场景:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 避免重复代码 (https://doc.rust-lang.org/stable/rust-by-example/macros/dry.html)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 领域专用语言（DSL，domain-specific language）。宏允许你为特定的目的创造特定的 语法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 可变接口（variadic interface）。有时你需要能够接受不定数目参数的接口，比如 println!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>按照定义方式分类:</p><ul><li>声明宏, 通过 macro_rules! 定义 ( 输入代码, 通过 match 匹配, 以另外的代码替换输出)</li><li>过程宏 (接受 rust 代码作为输入,  在此基础上修改后, 输出;)</li></ul><p>根据使用的语法形式又分为以下两种:</p><ul><li>调用宏， 形如 println!、 assert_eq! 、 thread_local!等可以当作函数调用的宏, </li><li>属性宏， 也就是形如 <code>#[derive(Debug))或#[cfg]</code>这种形式的语法</li></ul><p>按宏的来源，可以分为以下两类</p><ul><li>内置宏</li><li>自定义宏</li></ul><p>有哪些内置宏?</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">todo!()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print!()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">eprintln!(&quot; = {:?}&quot;, );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vec!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">panic!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)] 调试打印 struct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[allow(dead_code)] 用于屏蔽对未使用代码的警告</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 通过这个属性屏蔽警告。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[allow(non_camel_case_types)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[cfg(test)] // 条件编译, 只在 测试时编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5262-声明宏">5.26.2. 声明宏<a href="#5262-声明宏" class="hash-link" aria-label="Direct link to 5.26.2. 声明宏" title="Direct link to 5.26.2. 声明宏">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52621-创建宏">5.26.2.1. 创建宏<a href="#52621-创建宏" class="hash-link" aria-label="Direct link to 5.26.2.1. 创建宏" title="Direct link to 5.26.2.1. 创建宏">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 宏展开:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 假如是单独的文件则执行此命令展开</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  rustc -Z unstable-options --pretty=expanded main.rs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 假如是 cargo 生成的二进和l包则执行此命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// cargo rustc -- -Z unstable-options --pretty=expanded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// macro rules!本身 也 是一种声明宏 ， 只不过它由编译器 内部所定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 宏的原理和正则表达式匹配的原理类似 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 语法:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// macro_rule! $macro_name { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      // 扩展部分, 大小括号均可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      ($arg1:expr, $arg2:expr) =&gt; {code...}; // 分支以分号结尾</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      () =&gt; ()                                // 最后一个分支可省略分号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 未来会支持 macro 关键字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// #![feature(decl_macro)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// macro unless($arg:expr, $branch:expr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//     ( if !$arg { $branch }); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 匹配表达式中类型支持: (各个类型能够匹配的范围有重叠覆盖)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • item， 代表语言项，就是组成一个 Rust包的基本单位，比如模块、声明、函数定义 、 类型定义、结构体定义、 impl 实现等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • block， 代表代码块，由花括号限定的代码。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • stmt，代表语句 ， 一般是 指以分号结尾的代码 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • expr，指代表达式，会生成具体的值 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • pat，指代模式。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • ty， 表示类型。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • ident， 指代标识符。如 变量名或函数名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • path，指代路径， 比如foo、 std::iter等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • meta， 元信息，表示包含在# [...]或#![...]属性 内的信 息。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • tt , TokenTree 的 缩写，指代词条树。比 expr 能匹配的范围要广</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • vis，指代可见性，比如 pub。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • lifetime， 指代生命周期参数 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这是一个简单的宏，名为 `say_hello`。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! say_hello {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `()` 表示此宏不接受任何参数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    () =&gt; (// 这里使用 大括号亦可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 此宏将会展开成这个代码块里面的内容。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Hello cacro!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这个调用将会展开成 `println(&quot;xxx&quot;);`!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">say_hello!();// 这里使用大括号亦可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 带参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! hello {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($name:expr) =&gt; {// 使用 大小括号均可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Hello, {}&quot;, $name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hello!(&quot;xy&quot;)// 使用大小括号均可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 带代码段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! unless {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($arg: expr, $logic:expr) =&gt; (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if !$arg {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            $logic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (a, b) = (1, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unless!(a &gt; b, {// 大括号可省略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;a &lt; b&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 参数类型为 标识符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! create_function {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `ident` 指示符, 标识 func_name 是变量名或函数名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($func_name:ident) =&gt; (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn $func_name() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // `stringify!` 宏把 `ident` 转换成字符串。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;You called {:?}()&quot;, stringify!($func_name))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 借助上述宏来创建名为 `foo` 和 `bar` 的函数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">create_function!(foo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">create_function!(bar);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! print_result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `expr` 指示符表示输入参数为一个表达式。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($expression:expr) =&gt; (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;{:?} = {:?}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    stringify!($expression),// `stringify!` 把表达式*原样*转换成一个字符串。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    $expression)// 执行表达式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">foo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bar();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print_result!(1u32 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//代码块也是表达式！</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print_result!({</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = 1u32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x * x + 2 * x - 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52622-重复循环匹配">5.26.2.2. 重复循环匹配<a href="#52622-重复循环匹配" class="hash-link" aria-label="Direct link to 5.26.2.2. 重复循环匹配" title="Direct link to 5.26.2.2. 重复循环匹配">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 不定参数 可变接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//宏在参数列表中可以使用 + 来表示一个参数可能出现一次或多次，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 * 来表示该 参数可能出现零次或多次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! map {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($($key:expr =&gt; $value:expr),*) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 包裹一层大括号, 表示返回一个值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用绝对路径, 避免冲突</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 若使用到自定义函数, 需要在路径中使用 $crate , 避免导出时出 bug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut map = std::collections::HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 循环读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            $(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                map.insert($key, $value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 调用时, 大小括号都可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let map = map!(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;map: {:?}&quot;, map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mat1 = map!{1 =&gt; &quot;a&quot;, 2 =&gt; &quot;b&quot;, 3 =&gt; &quot;c&quot;};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;mat1: {:?}&quot;, mat1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //但还是存在问题, 末尾元素不能有逗号 , 可以通过添加多个匹配规则解决</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let map2 = map!(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2,);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 解决:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! map {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($($key:expr =&gt; $value:expr),*) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut map = std::collections::HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            $(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                map.insert($key, $value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 新增一条匹配规则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($($key:expr =&gt; $value:expr,)*) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map!($($key =&gt; $value),*) // 递归调用前面的 匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 或者最简单的方法, 将原来的匹配略加修改:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 添加的 $(,)* 表示匹配任意次数的逗号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">($($key:expr =&gt; $value:expr),* $(,)*) =&gt; {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">($($key:expr =&gt; $value:expr,)* $(,)*) =&gt; {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let map = map!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1 =&gt; &quot;a&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        2 =&gt; &quot;b&quot;, // 可以使用 逗号结尾了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52623-实际案例">5.26.2.3. 实际案例<a href="#52623-实际案例" class="hash-link" aria-label="Direct link to 5.26.2.3. 实际案例" title="Direct link to 5.26.2.3. 实际案例">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//  创建 map 宏</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! map {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // @unit 是约定俗成的在宏内部定义宏的命名规则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 必须定义在开头, 否则就按照普通匹配分支处理了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (@unit $($x:tt)*) =&gt; {()};    // 统计 item 个数时使用的单位, 这里使用 空元组, 不占空间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (@count $($key:expr),* ) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (&lt;[()]&gt;::len(&amp;[$(map!(@unit $key)),*]));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($($key:expr =&gt; $value:expr),* $(,)*) =&gt; (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let _cap = map!(@count $($key),*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut _map = std::collections::HashMap::with_capacity(_cap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           $(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               _map.insert($key, $value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           _map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let map = map!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1 =&gt; &quot;a&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        2 =&gt; &quot;b&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  实例:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `min!` 将求出任意数量的参数的最小值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    macro_rules! find_min {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 基本情形：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ($x:expr) =&gt; ($x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // `$x` 后面跟着至少一个 `$y,`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ($x:expr, $($y:expr),+) =&gt; (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 对 `$x` 后面的 `$y` 们调用 `find_min!` </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            std::cmp::min($x, find_min!($($y),+))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, find_min!(1u32));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, find_min!(1u32 + 2 , 2u32));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创造 dsl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里创造关键字 eval</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    macro_rules! calculate {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (eval $e:expr) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let val: usize = $e; // 强制类型为整型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;{} = {}&quot;, stringify!{$e}, val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    calculate! {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        eval 1 + 2 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    calculate! {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        eval (1 + 2) * (3 / 4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 升级版 dsl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可接受多个参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    macro_rules! calculate {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 单个 `eval` 的模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (eval $e:expr) =&gt; {{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let val: usize = $e; // Force types to be integers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                println!(&quot;{} = {}&quot;, stringify!{$e}, val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 递归地拆解多重的 `eval`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (eval $e:expr, $(eval $es:expr),+) =&gt; {{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            calculate! { eval $e }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            calculate! { $(eval $es),+ }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    calculate! { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        eval 1 + 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        eval 3 + 4,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        eval (2 * 3) + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5263-宏调试">5.26.3. 宏调试<a href="#5263-宏调试" class="hash-link" aria-label="Direct link to 5.26.3. 宏调试" title="Direct link to 5.26.3. 宏调试">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 必须 nightly rust 才行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// #![feature(trace_macros) 标注宏定义, 然后在main 开头 trace_macros!(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#![feature(trace_macros)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! hashmap {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (@unit $($x:tt)*) =&gt; (());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (@count $($rest:expr),*) =&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (&lt;[()]&gt;::len(&amp;[$(hashmap!(@unit $rest)),*]));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($($key:expr =&gt; $value:expr),* $(,)*) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let _cap = hashmap!(@count $($key),*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut _map = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ::std::collections::HashMap::with_capacity(_cap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           $(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               _map.insert($key, $value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           )*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           _map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   trace_macros!(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let map = hashmap!{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       &quot;a&quot; =&gt; 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       &quot;b&quot; =&gt; 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       &quot;c&quot; =&gt; 3, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   assert_eq!(map[&quot;a&quot;], 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5264-过程宏">5.26.4. 过程宏<a href="#5264-过程宏" class="hash-link" aria-label="Direct link to 5.26.4. 过程宏" title="Direct link to 5.26.4. 过程宏">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52641-过程宏基本使用规则">5.26.4.1. 过程宏基本使用规则<a href="#52641-过程宏基本使用规则" class="hash-link" aria-label="Direct link to 5.26.4.1. 过程宏基本使用规则" title="Direct link to 5.26.4.1. 过程宏基本使用规则">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 可以用来:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 自定义派生属性, 类似于 #[derive(Debug)]这样的 derive 属性，可以自动为 结构体或枚举类型进行语法扩展, 增加新的方法实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 自定义属性， 可以自定义类似于#[cfg()]这种属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 类似函数调用的宏, 和 macro_rules!定义的宏类似，以 Bang 符号(就是叹号 &quot;!&quot; )结尾的宏 。可以像函数一样被调用 , custom!(...)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-t codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-t codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 过程宏，必须写在单独的lib类型的crate中, `cargo new --lib xxx`, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 为什么不能在同一个 crate 里同时定义&amp;使用 procedual macro ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # procedual macro 是在项目编译前会被预先编译加工的一段程序, 如果定义和使用在同一个 crate, 就嵌入了死锁 (鸡生蛋蛋生鸡的问题)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # crate 代码要编译的话需要先处理 procedual macro展开, 而 处理 procedual macro 展开需要先编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 需要 为当前项目声明使用 proc_macro,  proc_macro crate为 rust 自带, 默认不引入, 需要显式声明为 true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[lib]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 设置为 proc_macro 类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">proc_macro = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52642-自定义属性宏">5.26.4.2. 自定义属性宏<a href="#52642-自定义属性宏" class="hash-link" aria-label="Direct link to 5.26.4.2. 自定义属性宏" title="Direct link to 5.26.4.2. 自定义属性宏">​</a></h4><p>Rust 自身有很多内置的属性 ， 比如条件编译属性 <code>#[cfgOJ和测试属性#[test]</code></p><p>过程宏实现自定义属性的功能还未稳定。在 该版本稳定之前，必须在 Nightly 版本下使用 <code>#![feature(custom_attribute)]</code>特性, 当前版本不需要了</p><p>定义宏:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use proc_macro::TokenStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[proc_macro_attribute]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn attr_with_args(args: TokenStream, _input: TokenStream) -&gt; TokenStream {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // args 是 #[attr_with_args(&quot;Hello attr macro.&quot;)] 中的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // _input 是输入, 即 fn boo() {}, 这里直接忽略了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    format!(&quot;fn foo() -&gt; &amp;&#x27;static str {{{}}}&quot;, args.to_string()).parse().unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[macro_use] extern crate proc_macro_me;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[test]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn tt() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[attr_with_args(&quot;Hello attr macro.&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn foo() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, foo());//&quot;Hello attr macro.&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52643-函数调用宏">5.26.4.3. 函数调用宏<a href="#52643-函数调用宏" class="hash-link" aria-label="Direct link to 5.26.4.3. 函数调用宏" title="Direct link to 5.26.4.3. 函数调用宏">​</a></h4><p>定义函数调用宏:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use proc_macro::TokenStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[proc_macro]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn make_fn_answer(_item: TokenStream) -&gt; TokenStream {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;fn answer() -&gt; u32 { 11 }&quot;.parse().unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[macro_use] extern crate proc_macro_me;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[test]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn tt() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    make_fn_answer!();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, answer());// 11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52644-derive-宏">5.26.4.4. derive 宏<a href="#52644-derive-宏" class="hash-link" aria-label="Direct link to 5.26.4.4. derive 宏" title="Direct link to 5.26.4.4. derive 宏">​</a></h4><p>定义宏</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 自定义 derive 宏</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// extern crate proc_macro;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// use proc_macro::TokenStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// use self::proc_macro::TokenStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use proc_macro::TokenStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// AnswerFn 相当于标识符, 使用时, 这样使用 #[derive(Hello, AnswerFn)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[proc_macro_derive(AnswerFn)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn derive_answer_fn(_input: TokenStream) -&gt; TokenStream {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;fn answer() -&gt; u32 { 11 }&quot;.parse().unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[proc_macro_derive(Hello)]//表示其下方的函数专门处理自定义派生属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn derive_a_hello(input: TokenStream) -&gt; TokenStream {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let input = input.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 保证 代码中存在 struct A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert!(input.contains(&quot;struct A&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //方法最终会返回一个 Result&lt;TokenSteam, Err〉类型， </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 所以还需要再次用 unwrap 方法才能返回。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    r#&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        impl A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fn a(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                format!(&quot;hello from a impl&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;#.parse().unwrap() </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// #[macro_use] extern crate proc_macro_me;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use proc_macro_me::{AnswerFn, Hello};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Hello, AnswerFn)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[test]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn test_derive_a() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let aa = A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(&quot;hello from a impl&quot;.to_string(), aa.a());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, answer());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5265-使用第三方包">5.26.5. 使用第三方包<a href="#5265-使用第三方包" class="hash-link" aria-label="Direct link to 5.26.5. 使用第三方包" title="Direct link to 5.26.5. 使用第三方包">​</a></h3><p>官方的过程宏库为proc_macro, 还没稳定，不推荐直接使用</p><p>derive_more</p><p>syn  完整实现了 Rust 源码 的语 法树结构</p><p>quote 可以将 syn 的语法树结构转为 proc macro::TokenStrem 类型</p><p>proc_macro2</p><p>proc-macro-workshop</p><p>seq-macro</p><p>paste</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5266-编译器插件">5.26.6. 编译器插件<a href="#5266-编译器插件" class="hash-link" aria-label="Direct link to 5.26.6. 编译器插件" title="Direct link to 5.26.6. 编译器插件">​</a></h3><p>cargo-expand</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># install</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo </span><span class="token function" style="color:#d73a49">install</span><span class="token plain"> cargo-expand</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup component </span><span class="token function" style="color:#d73a49">add</span><span class="token plain"> rustfmt </span><span class="token comment" style="color:#999988;font-style:italic"># this is used to format the expanded code</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustup </span><span class="token function" style="color:#d73a49">install</span><span class="token plain"> nightly </span><span class="token comment" style="color:#999988;font-style:italic"># 在 Nightly 版本的 Rust 之下，配合, just need install nightly version, not have to switch to nightly</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 使用 </span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo </span><span class="token function" style="color:#d73a49">expand</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># this will expand all code</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo </span><span class="token function" style="color:#d73a49">expand</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain">function name</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># this will only expand the specified function</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>6. unsafe 屏蔽内存安全检查</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="61-unsafe-基本场景">6.1. unsafe 基本场景<a href="#61-unsafe-基本场景" class="hash-link" aria-label="Direct link to 6.1. unsafe 基本场景" title="Direct link to 6.1. unsafe 基本场景">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 unsafe 定义 不安全的 函数/方法/trait, 以及为 trait 实现方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如: String::from_utf8_unchecked 就是不安全的, 对于输入参数, 没有检查是否是有效的 utf-8字节序列; String::from_utf8_lossy 则是安全的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如: Send trait, Sync trait 都是 unsafe 的, 使 用 unsafe对 Send和 Sync进行标记，就意味着开发者手动实现它会有安全风险, 所以编译器会自动对我们自定义的类型实现这两个接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如: Searcher trait, 没有检查截取的字符位置在字符串中是否是有效字符边界, 需要开发者自己保证</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在 unsafe 块中执行不安全的操作 (对于不安全的操作, 会屏蔽内存安全检查, 但是对于安全的操作, 依然有安全检查)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 解引用裸指针 (但是创建裸指针无需在 unsafe 中)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 调用 unsafe 的函数/方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 访问修改可变静态变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 实现 unsafe 的 trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 读写 union 联合体中的  字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 访问修改可变静态变量 (一般用不到, 只是用于和 c 交互)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 静态变量是全局可访 问 的 。对于不可变静态变量来说，访问它不存在任何安全 问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果多个线程同时访 问可变静态变量, 会有安全问题, 所以要在 unsafe 中修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static mut COUNTER: u32 = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let inc = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        COUNTER += inc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;COUNTER: {}&quot;, COUNTER);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 访问 union 联合体 (只要还是为了方便 和 c 交互)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 解引用裸/原生指针 (raw pointer), 裸指针常用于 和 c 交互</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 分为:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 不可变裸指针   *const T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 可变裸指针     *mut T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 允许忽略借用规则: 某个对象可以同时拥有可变不可变裸指针, 或者多个同时指向相同位置的可变裸指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 不保证指向的内存是有效的, 允许指向空地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 不保证线程安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 没有自动清理的功能, 需要手动清理内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let rp1 = &amp; a as *const i32; // 创建时无需在 unsafe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 同时出现了 可变, 不可变借用, 编译器不报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let rp2 = &amp;mut a as *mut i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;rp1 = {}&quot;, *rp1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;rp2 = {}&quot;, *rp2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 访问 unsafe 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsafe fn danger() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;dangerous&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    danger();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="62-交叉编译">6.2. 交叉编译<a href="#62-交叉编译" class="hash-link" aria-label="Direct link to 6.2. 交叉编译" title="Direct link to 6.2. 交叉编译">​</a></h2><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 如果是针对 ARM 嵌入式开发平台, 不能使 用std标准库 (#![no_std))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rustc --target=arm-unknown-linux-gnueabihf hello .rs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo build --target=arm - unknown - linux - gnueabihf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 第三方交叉编译工具 xargo</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过配置文件指定链接器: vim ~/ . cargo/config</p><div class="language-t codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-t codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[target . arm- unknown-linux-gnueabihf]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">linker = ”arm-linux-gnueabihf-gcc-4.8”</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="63-ffi-外部函数接口">6.3. ffi 外部函数接口<a href="#63-ffi-外部函数接口" class="hash-link" aria-label="Direct link to 6.3. ffi 外部函数接口" title="Direct link to 6.3. ffi 外部函数接口">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="631-ffi-基本介绍">6.3.1. ffi 基本介绍<a href="#631-ffi-基本介绍" class="hash-link" aria-label="Direct link to 6.3.1. ffi 基本介绍" title="Direct link to 6.3.1. ffi 基本介绍">​</a></h3><p>Java语言则将FFI称为JNI CJavaNativeInterface)</p><p><a href="https://www.cnblogs.com/Jackeyzhe/p/12623689.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/Jackeyzhe/p/12623689.html</a></p><p><a href="https://rustcc.cn/article?id=3b8241d0-c4ca-4f49-8e07-0a5142b00f59" target="_blank" rel="noopener noreferrer">https://rustcc.cn/article?id=3b8241d0-c4ca-4f49-8e07-0a5142b00f59</a></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">///外部语言函数接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// Rust 提供了到 C 语言库的外部语言函数接口（Foreign Function Interface，FFI）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 外 部语言函数必须在一个 extern 代码块中声明，且该代码块要带有一个包含库名称 的 #[link] 属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 支持四种库:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - dylib , rust动态库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - rlib, rust 静态库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - cdylib, 其他语言写的动态库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - staticlib , 其他语言静态库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如何编译为库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// flag 参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// (crate type 可以指定多个, #[crate_type = &quot;bin&quot;] 这种使用形式需要标注在 lib.rs or main.rs 开头)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// --crate-type=bin or #[crate_type = &quot;bin&quot;] 表示将生成-个可执行文件 。要求程序中必 须包含一个 main 函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// --crate-type=lib or #[crate_type = &quot;lib&quot;] 表示将生成一个 Rust库。 具体生成什么类型库，由编译器自行决定。默认会产生 rlib静态 库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//--crate-type=rlib or #[crate_type = &quot;rlib&quot;] 静态 Rust库，由Rust编译器来使 用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//--crate-type=dylib or #[crate_type = &quot;dylib&quot;] 动态 Rust库,由 Rust 编译器来使用(在 Linux上会创建*.so文件，在 MacOSX上会创建.dylib文件， 在 Windows上会创建.dll文件)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// --crate-type=staticlib or #[crate_type = &quot;staticlib&quot;] 生成静态系统库 。 Rust 编译器 永远不会链接该类型库，主要用于和 C 语言进行链接 ，达成和其他语 言交互 的目的 。 静态系统库在 Linux和 MacOSX上会创建.a文件，在 Windows上会创建*.lib文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//--crate-type=cdylib or #[crate_type = &quot;cdylib&quot;] 生成动态系统库。同样 用 于生成 C 接口， 和其他语言交互。该类型在 Linux上会创建.so文件 ，在 MacOSX上会创建.dylib , 在 Windows上会创建.dll文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="632-和-elixir-交互">6.3.2. 和 elixir 交互<a href="#632-和-elixir-交互" class="hash-link" aria-label="Direct link to 6.3.2. 和 elixir 交互" title="Direct link to 6.3.2. 和 elixir 交互">​</a></h3><p>rustler</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="633-和c-cpp-交互">6.3.3. 和c cpp 交互<a href="#633-和c-cpp-交互" class="hash-link" aria-label="Direct link to 6.3.3. 和c cpp 交互" title="Direct link to 6.3.3. 和c cpp 交互">​</a></h3><p>Cbindgen</p><p>autocxx -&gt; c++</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6331-在-rust-中调用-c-函数">6.3.3.1. 在 rust 中调用 C 函数<a href="#6331-在-rust-中调用-c-函数" class="hash-link" aria-label="Direct link to 6.3.3.1. 在 rust 中调用 C 函数" title="Direct link to 6.3.3.1. 在 rust 中调用 C 函数">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 在 Rust 中调用 C 函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里指定使用 C-ABI，等价于 “extern fn foo () ”这样的函数声明; 此外还有 extern &quot;Rust”， 这是默认的 ABI，任何普通 的函数都将使 用 该 ABI</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extern &quot;C&quot; {//也可以 直接使用 extern 块，而省略掉ABI字符串°C” 。因为默认的extern块就是按C-ABI处理的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 定义了 C 标准库内置的 isalnum 函数签名, 可以直接使用了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn isalnum(input: i32) -&gt; i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Is 3 a number ?  the answer is : {}&quot;, isalnum(3));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // error, 参数类型错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Is &#x27;a&#x27; a number ? &quot;, isalnum(&#x27;a&#x27;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6332-在-rust调用-cpp">6.3.3.2. 在 rust调用 cpp<a href="#6332-在-rust调用-cpp" class="hash-link" aria-label="Direct link to 6.3.3.2. 在 rust调用 cpp" title="Direct link to 6.3.3.2. 在 rust调用 cpp">​</a></h4><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 调用 cpp c++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 单精度复数的最简实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[repr(C)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[derive(Clone, Copy)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct Complex {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        re: f32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        im: f32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    impl fmt::Debug for Complex {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if self.im &lt; 0. {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                write!(f, &quot;{}-{}i&quot;, self.re, -self.im)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                write!(f, &quot;{}+{}i&quot;, self.re, self.im)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个 extern 代码块链接到 libm 库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[link(name = &quot;m&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    extern {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个外部函数用于计算单精度复数的平方根</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn csqrtf(z: Complex) -&gt; Complex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个用来计算单精度复数的复变余弦</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fn ccosf(z: Complex) -&gt; Complex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 由于调用其他语言的函数被认为是不安全的，我们通常会给它们写一层安全的封装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn cos(z: Complex) -&gt; Complex {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsafe { ccosf(z) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // z = -1 + 0i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let z = Complex { re: -1., im: 0. };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 调用外部语言函数是不安全操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let z_sqrt = unsafe { csqrtf(z) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 调用不安全操作的安全的 API 封装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6333-在-c-中调用-rust">6.3.3.3. 在 c 中调用 rust<a href="#6333-在-c-中调用-rust" class="hash-link" aria-label="Direct link to 6.3.3.3. 在 c 中调用 rust" title="Direct link to 6.3.3.3. 在 c 中调用 rust">​</a></h4><h3 class="anchor anchorWithStickyNavbar_LWe7" id="634-和-python-交互">6.3.4. 和 Python 交互<a href="#634-和-python-交互" class="hash-link" aria-label="Direct link to 6.3.4. 和 Python 交互" title="Direct link to 6.3.4. 和 Python 交互">​</a></h3><p><a href="https://github.com/PyO3/pyo3" target="_blank" rel="noopener noreferrer">https://github.com/PyO3/pyo3</a>
<a href="https://saidvandeklundert.net/learn/2021-11-18-calling-rust-from-python-using-pyo3/" target="_blank" rel="noopener noreferrer">https://saidvandeklundert.net/learn/2021-11-18-calling-rust-from-python-using-pyo3/</a>
<a href="https://zhuanlan.zhihu.com/p/148144823" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/148144823</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="635-和-swift">6.3.5. 和 Swift<a href="#635-和-swift" class="hash-link" aria-label="Direct link to 6.3.5. 和 Swift" title="Direct link to 6.3.5. 和 Swift">​</a></h3><p>cbingen</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="636-和-js-javascript-nodejs-交互">6.3.6. 和 js JavaScript nodejs 交互<a href="#636-和-js-javascript-nodejs-交互" class="hash-link" aria-label="Direct link to 6.3.6. 和 js JavaScript nodejs 交互" title="Direct link to 6.3.6. 和 js JavaScript nodejs 交互">​</a></h3><p>neon -&gt; 和 node 交互</p><p><a href="https://github.com/napi-rs/napi-rs" target="_blank" rel="noopener noreferrer">https://github.com/napi-rs/napi-rs</a></p><p><a href="https://rustwasm.github.io/" target="_blank" rel="noopener noreferrer">https://rustwasm.github.io/</a> webassembly</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="637-和-java-交互">6.3.7. 和 java 交互<a href="#637-和-java-交互" class="hash-link" aria-label="Direct link to 6.3.7. 和 java 交互" title="Direct link to 6.3.7. 和 java 交互">​</a></h3><p><a href="https://github.com/jni-rs/jni-rs" target="_blank" rel="noopener noreferrer">https://github.com/jni-rs/jni-rs</a>
<a href="https://github.com/astonbitecode/j4rs" target="_blank" rel="noopener noreferrer">https://github.com/astonbitecode/j4rs</a></p><p>flapigen-rs, robusta</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6371-java-调用-rust">6.3.7.1. java 调用 rust<a href="#6371-java-调用-rust" class="hash-link" aria-label="Direct link to 6.3.7.1. java 调用 rust" title="Direct link to 6.3.7.1. java 调用 rust">​</a></h4><p><a href="https://github.com/drrb/java-rust-example" target="_blank" rel="noopener noreferrer">https://github.com/drrb/java-rust-example</a></p><p><a href="https://github.com/jnr/jnr-ffi" target="_blank" rel="noopener noreferrer">https://github.com/jnr/jnr-ffi</a></p><p><a href="https://github.com/drrb/java-rust-example" target="_blank" rel="noopener noreferrer">https://github.com/drrb/java-rust-example</a>
<a href="https://stackoverflow.com/questions/30258427/calling-rust-from-java" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/30258427/calling-rust-from-java</a></p><p><a href="https://blog.csdn.net/abcamus/article/details/81017325" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/abcamus/article/details/81017325</a></p><p><a href="https://rustcc.cn/article?id=98b96e69-7a5f-4bba-a38e-35bdd7a0a7dd" target="_blank" rel="noopener noreferrer">https://rustcc.cn/article?id=98b96e69-7a5f-4bba-a38e-35bdd7a0a7dd</a> 各种库区别</p><p><a href="https://rustcc.cn/article?id=f371a5f1-08fa-4ab8-99a4-21d307223f82" target="_blank" rel="noopener noreferrer">https://rustcc.cn/article?id=f371a5f1-08fa-4ab8-99a4-21d307223f82</a> rust 导出共享库</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="6372-rust-调用-java">6.3.7.2. rust 调用 java<a href="#6372-rust-调用-java" class="hash-link" aria-label="Direct link to 6.3.7.2. rust 调用 java" title="Direct link to 6.3.7.2. rust 调用 java">​</a></h4><p><a href="https://github.com/benanders/rjni" target="_blank" rel="noopener noreferrer">https://github.com/benanders/rjni</a> </p><h1>7. 内存管理</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="71-堆-和-栈">7.1. 堆 和 栈<a href="#71-堆-和-栈" class="hash-link" aria-label="Direct link to 7.1. 堆 和 栈" title="Direct link to 7.1. 堆 和 栈">​</a></h2><p>手动管理内存 -&gt; bug (内存泄漏, 垂悬指针)</p><p>gc -&gt; 性能问题(stop the world, 因为GC 在工作的 时候必须保证程序不会引入新的“垃圾&quot;, 所以要使运行中的程序暂停)</p><ul><li><p>虚拟内存管理技术: 对物理存储设备的抽象, 方便同时运行 多道程序 ，使得每个进程都有各自独立的进程地址空间</p></li><li><p>虚拟地址空间: (用户所接触到的地址都是虚拟地址，而不是真实 的物理地址)</p><ul><li><p>是线性空间, 分为 用户空 间和内核空间 (它们的比例是 3:1 (Linux系统中)或 2:2 (Windows系统中))</p><p>  32 位计算机Linux的地址空间大小是 4GB</p></li><li><p>好处:</p><ul><li><p>用户程序可以使用比物理内存更大的地址空间</p></li><li><p>保护操作系统，让进程在各自的地址空间内操作内存</p></li></ul></li></ul></li><li><p>用户空间中的 栈 (stack), 堆 (heap)</p><ul><li><p>栈 (堆栈): 用 于支持 CPU 入栈或出栈的指令操作, 如函数嵌套调用时需要存储方法栈帧</p><p>  stack 内存中保存的数据，生命周期都比较短，会随着函数调用的完成而消亡, </p><p>  对于基本原生数据类型来说， Rust 是默认将其分配到栈中的</p><p>  结构体或枚举, 联合体只是定义，看它们被分配在哪 ，主要是看其类型实例如 何使用</p></li><li><p>堆: 一块巨大的内存空间, 长久地保存在内存中的数据，以便跨函数使用;程序不可以主动申请桔 内存，但可以主动申请堆内存</p></li><li><p>堆分配算法: 空闲链表 (Free List)和位图标记 (Bitmap)。</p><p>  空闲链表实际上就是把堆中空闲的内存地址记录为链表 ， 当系统收到程序申请时，会遍 历该链表:当找到适合的空间堆节点 时， 会将此节点从链表中删除;当空间被回收以后 ， 再 将其加到空闲链表中。空闲链表的优势是实现简单，但如果链表遭到破坏 ， 整个堆就无法正 常工作。</p><p>  位图的核心思想是将整个堆划分为大量大小相等的块。 当程序申请内存时，总是分配整 数个块的空间。每块内存都用一个二进制位来表示其状态，如果该内存被占用 ，则相应位图 中的位置置为 1;如果该内存空闲，则相应位图中的位置置为 0。位图的优势是速度快，如 果单个内存块数据遭到破坏， 也不会影响整个堆，但缺点是容易产生内存碎片</p></li><li><p>内存释放: 分配的都是虚拟地址空 间 。 所以当堆空间被释放时，并不代表指物理 空 间也 马上被释放, 只是内存被归还给了内存分配器。 内存分配 器会对空闲的 内存进行统一 “整理”, 在适合( 比如空闲内存达到 2048KB)的时候，才会把 内存归还给系统 ，也就是指释放物理空 间</p><p>  Rust 编译器目前自带两个默认分配 器: alloc_system 和 alloc_jemalloc, Rust 2018 版本 下， 默认使用 alloc_system, 可以自己指定</p></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="72-内存对齐">7.2. 内存对齐<a href="#72-内存对齐" class="hash-link" aria-label="Direct link to 7.2. 内存对齐" title="Direct link to 7.2. 内存对齐">​</a></h2><p>内存对齐, 即字节对齐, 减少 cpu 读取内存次数</p><p>CPU在单位时间/一次计算能处理的位数 -&gt; 字长, 32位CPU， 其字长为32位，也就是一次读取4个字节, 所以每次只能对 4 的 倍数的 地址 进行读取</p><p>现有一整数类型的数据，首地址并不是 4 的倍数，不妨设为 Ox3, 存储在 地址范围是 Ox3~Ox7 的存储空间, cpu 需要分别在 Ox1 和 Ox5 处进行两次读取, 采取内存对齐策略后, 数据的首地址变为 0x5, CPU只需要读取一次。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 对应到代码层面:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a: u8,// 1byte</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b: u32,// 4byte</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c: u16,  // 2 byte</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println!(&quot;{:?}&quot;, std :: mem::size o f : : &lt; A &gt; ( );// 8 , 单位 字节</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 分析:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 总共是 7, 为什么打印 8 ?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 因为存在内存对齐策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 内存对齐包括基本数据对齐和结构体(或联合体)数据对齐</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 对于基本数据类型，默认 对齐方式是按其大小进行对齐，也被称作自然对齐。 比如Rust中u32类型占4字节，则它默 认对齐方式为 4 字节对齐</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="73-手动堆内存分配">7.3. 手动堆内存分配<a href="#73-手动堆内存分配" class="hash-link" aria-label="Direct link to 7.3. 手动堆内存分配" title="Direct link to 7.3. 手动堆内存分配">​</a></h2><p>在编写 Unsafe Rust的过程中，也需要手动进行堆内存分配，所以 Rust标准库 std::alloc 模块中也提供 了堆内存 分配的 相 关 API</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Rust 1.28之前默认全局内存分配器：jemalloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Rust 1.28内存分配器 : System，同时会提供其他全局分配器，可自定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::alloc::{GlobalAlloc, System, Layout};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct MyAllocator;// 可以直接使用GlobalAlloc, 这里是做了一个包装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsafe impl GlobalAlloc for MyAllocator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.alloc(layout)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe fn dealloc(&amp;self, ptr: *mut u8, layout: Layout) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.dealloc(ptr, layout)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 声明为全局分配器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[global_allocator]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static GLOBAL: MyAllocator = MyAllocator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 此处Vec的内存会由GLOBAL全局分配器来分配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut v = Vec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   v.push(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 指定全局分配器为jemalloc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extern crate jemallocator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use jemallacator::Jemalloc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[global_allocator]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static GLOBAL: Jemalloc = Jemalloc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>8. 工程管理 模块</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="81-概念简单解释">8.1. 概念简单解释<a href="#81-概念简单解释" class="hash-link" aria-label="Direct link to 8.1. 概念简单解释" title="Direct link to 8.1. 概念简单解释">​</a></h2><p><a href="https://www.jianshu.com/p/51693602114a" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/51693602114a</a>
<a href="https://zhuanlan.zhihu.com/p/73544030" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/73544030</a>
or
<a href="https://privaterookie.github.io/2019-07-14-Rust%E6%A8%A1%E5%9D%97%E4%B8%8E%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener noreferrer">https://privaterookie.github.io/2019-07-14-Rust%E6%A8%A1%E5%9D%97%E4%B8%8E%E6%96%87%E4%BB%B6/</a></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// - 箱（Crate）: 二进制程序文件or 库文件, 位于包中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 包（Package）: cargo new xxx 新建的 就是 包; 包必须由一个 Cargo.toml 文件来管理，该文件描述了包的基本信息以及依赖项。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///    一个 package 最少有一个 crate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///    当使用 cargo new 命令创建完包之后，src 目录下会生成一个 main.rs 源文件，Cargo 默认这个文件为二进制箱的根，编译之后的二进制箱将与包名相同。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - 模块（Module）: 使用 mod 声明一个模块, 一个文件默认就是一个 module, 文件名就是 module name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      每个包都拥有一个顶级 (top level) 模块 src/lib.rs 或 src/main.rs。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     每个 rust 文件都是一个 module, 比如: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      (若想在同个文件定义多个 module , 只需 mod xx_module {...} mod yy_module {...})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     ```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     // main.rs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     mod second_module; // 声明一个模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///         println!(&quot;This is the main module.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///         println!(&quot;{}&quot;, second_module::message());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     // second_module.rs, 模块名就是文件名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     pub fn message() -&gt; String {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///         String::from(&quot;This is the 2nd module.&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///     ```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      若希望多个 文件, 组成一个 module,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      需要:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      合并到一个文件夹, 新建一个 mod.rs (2018 中可以省略了), 然后在其中导出即可 (pub use sub1; pub use sub2;), 新 module name = 文件夹名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      若文件夹 和某个文件 aa.rs 同名, 则文件夹下定义的 module 都是 aa.rs 的子模块 (2015 中则不允许文件与目录同名)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn mod_package_crate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 路径:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Rust 中的路径分隔符是 ::</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //绝对路径从 crate 关键字开始描述。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 相对路径从 self 或 super 关键字或一个标识符开始描述</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如: 导入外部依赖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use super::{deserial, serial}; //导入 parent 指定资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use super::*; // 导入 parent 的所有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use crate::codec::{serial, deserial}; // 绝对路径, codec 为依赖 (不论是自定义模块还是第三方依赖, 若为第三方模块, 则 crate 关键字可选), codec 也能是 同个项目的其他 module (rust 文件)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  标准库 默认导入了, 所以以下两句可选</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    extern crate std; // 导入 标准库 std crate, 这是 2015 中的语法, 2018 中可选了, 只需要 cargo.toml 中导入即可, 无需再代码中显式指定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std : :prelude: :vl: :* ; // 标准库的 prelude module</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在 module 开头声明不需要 标准库, 使用 核心库(嵌入式开发必须)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[no_std]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // govern 函数的绝对路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    crate::nation::government::govern();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 相对路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nation::government::govern();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //Rust 中有两种简单的访问权：公共（pub）和私有（模块成员默认都是私有）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有 模块中的元素都需要 pub 修饰才能在外部访问到 , 但是 枚举类的字段不受这个限制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //对于私有的模块，只有在与其平级的位置或下级的位置才能访问，不能从其外部访问。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mod nation {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub mod government {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pub fn govern() {println!(&quot;govern()&quot;)}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mod congress {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pub fn legislate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                println!(&quot;legislate()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub mod court {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pub fn judicial() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                print!(&quot;judicial - &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                super::congress::legislate();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // use 关键字可以与 pub 关键字配合使用：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pub use congress::legislate as le;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nation::government::govern();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nation::court::judicial();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 导入 and 简化路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use nation::court::judicial as  ju;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 现在可以直接使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ju();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nation::le();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="82-可见性管理">8.2. 可见性管理<a href="#82-可见性管理" class="hash-link" aria-label="Direct link to 8.2. 可见性管理" title="Direct link to 8.2. 可见性管理">​</a></h2><p>pub use T 导出了 T，T 可以被其他 crate 使用；pub (crate) use T 只把 T 导出到当前的 crate，其他 crate 访问不了</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="83-编译器版本管理">8.3. 编译器版本管理<a href="#83-编译器版本管理" class="hash-link" aria-label="Direct link to 8.3. 编译器版本管理" title="Direct link to 8.3. 编译器版本管理">​</a></h2><p>在项目根目录下, 放 rust-toolchain 文件, 指定编译器版本</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="84-为项目单独指定config-配置">8.4. 为项目单独指定config 配置<a href="#84-为项目单独指定config-配置" class="hash-link" aria-label="Direct link to 8.4. 为项目单独指定config 配置" title="Direct link to 8.4. 为项目单独指定config 配置">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cargo 全局配置 : /.cargo/confg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">当前用户全局配置: $HOME/.cargo/config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">项目单独配置:     $proj/.cargo/config (子模块亦可继续指定)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="85-依赖管理-cargo">8.5. 依赖管理 cargo<a href="#85-依赖管理-cargo" class="hash-link" aria-label="Direct link to 8.5. 依赖管理 cargo" title="Direct link to 8.5. 依赖管理 cargo">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="851-cargo-基本命令">8.5.1. cargo 基本命令<a href="#851-cargo-基本命令" class="hash-link" aria-label="Direct link to 8.5.1. cargo 基本命令" title="Direct link to 8.5.1. cargo 基本命令">​</a></h3><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 新建可执行程序, 默认是 --bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 生成 main.rs 启动类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo new [--bin] &lt;proj&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 不初始化 git</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo new &lt;proj&gt; --vcs none</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 新建库, 在项目根目录下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 生成 的库下, 有 src, toml, lib_name.rs (带有基本的测试)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo new --lib &lt;lib name&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 在当前文件夹下新建项目</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo init [--bin]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo init --lib</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 构建, 更新依赖, 依赖在这里找 https://crates.io/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 默认是以 debug 方式编译, 编译速度快, 但是生成的可执行文件未优化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># build 后会生成 Cargo.lock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#  ./target/debug/project_name 中找到编译后的 可执行文件(exe) 运行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo build </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 使用 --release 参数编译最终发布版本。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 编译器会对代码进行优化， 使得编译时间变慢， 但是代码运行速度会变快。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo build --release</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 指定条件编译属性 (可以在 Cargo.toml 中指定)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 会给 rustc 传递 --cfg features=&quot;xxx&quot;, 表示 会编译 aa_module 模块, 不指定 xxx feature 则不会编译 该模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo build --features &quot;xxx&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 在代码中这么使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#   # 表示若没有指定 xxx feature, 则编译报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#   #[cfg(not(feature = &quot;xxx&quot;))]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#   compile_error!(&quot;xxx feature is required to build this crate&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#   # 表示 只有指定 了 xxx feature, 编译时才会包含 aa_module 进去</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#   #[cfg(feature = &quot;xxx&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#   mod aa_module</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo check # 迅速检查错误, 时间短</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo run </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 运行 example 文件夹下的 server.rs 的 main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo run --example server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 运行指定子模块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo run -p &lt;xxx&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 运行当前项目(rust_tools)下的 bin 文件夹下的 chat_server.rs 可执行文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo run --package rust_tools --bin chat_server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 从中心仓库安装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo install &lt;package&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 从 GitHub 安装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo install orz --git https://github.com/richox/orz --tag v1.6.1 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo doc # 生成html文档</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo doc --open # 同时打开文档预览</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo doc --target-doc ./ #输出文档时指定target目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># # 测试, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 会跑 #cfg[test] 下的 #[test]; 也会跑文档注释 (单元测试)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># and  tests/ 下的测试 (集成测试)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo test </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo test xxx # 过滤, 运行任何名字中包含 xxx 的测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo publish # publish a library to crates.io</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo --version</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># This will write out a new Cargo.lock with the new version information</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo update           # updates all dependencies</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo update -p rand   # updates just “rand”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 第三方插件扩展:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 需要 rustup component add rustfmt [一toolchain nightly]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo fmt # 格式化项目代码, 在项目根目录下执行, 会生成备份文件, .bk结尾, 跳过格式化 #[rustfmt_skip]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo fix # 自动修复代码警告</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cargo clippy #捕捉常见错误，改善代码 (需要安装 clippy)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>自定义格式化:  在项目根目录 rustfmt.tomI</p><div class="language-t codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-t codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">max_width = 90 # 最大宽度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn_call_width = 90 # 函数宽度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">chain_one_line_max = 80 # 链式调用最大宽度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">condense_wildcard_suffixes = true # 压缩通配符前缀</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="852-文件布局结构">8.5.2. 文件布局结构<a href="#852-文件布局结构" class="hash-link" aria-label="Direct link to 8.5.2. 文件布局结构" title="Direct link to 8.5.2. 文件布局结构">​</a></h3><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── Cargo.lock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── Cargo.toml</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── benches #性能测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│   └── large-input.rs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── examples    # 示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│   └── simple.rs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── src    # 源码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│   ├── bin # 其他可执行文件 (如果可执行文件包含不止一个源文件，则可以使用src/bin目录下，又一个包含main.rs文件的目录,而该目录将被视为具有父目录名称的可执行文件)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│   │   └── another_executable.rs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│   ├── lib.rs  # 默认库文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│   └── main.rs # 默认可执行文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">└── tests   # 集成测试 , 单元测试一般就写在 src 下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    └── some-integration-tests.rs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="853-cargotoml">8.5.3. Cargo.toml<a href="#853-cargotoml" class="hash-link" aria-label="Direct link to 8.5.3. Cargo.toml" title="Direct link to 8.5.3. Cargo.toml">​</a></h3><p>Cargo.toml 项目元信息, 包括版本, 依赖</p><div class="language-t codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-t codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[package]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">build = &quot;build.rs&quot; # 构建脚本, 相对于根目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">workspace = &quot;..&quot; # 这是 sub crate 中的配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">member = [&quot;&quot;, &quot;&quot;] # 这是 parent crate 中的配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[[bin]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = &quot;run-main&quot; # 生成的可执行文件的名字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path = &quot;src/main.rs&quot; # 当想在一个作为库的包里同时包含 main.rs , 需要配置这个, 文件名必须为 main.rs, 若放在 src/bin 下则可以自定义文件名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bench = false # 生成 可执行文件时不执行性能测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[[bench]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = &quot;bench&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path = &quot;src/bench.rs&quot; # 性能测试代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">test = false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bench = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 依赖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#  [dependencies] 专门用于设置第三方包的依赖，这些依赖会在执行 cargo build命令编译 时使用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uuid = &quot;0.0.1&quot; # 会从中心仓库下载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ferris-says = &quot;0.1&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 版本号规则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">gfx-hal = { version = &quot;0.1.0&quot;, git = &quot;https://github.com/gfx-rs/gfx&quot;, rev = &quot;bd7f058efe78d7626a1cc6fbc0c1d3702fb6d2e7&quot; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#  或者写成多行 (使用点 &quot;.&quot; 表示json 中的嵌套)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[dependencies.gfx-hal]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git = &quot;https://github.com/gfx-rs/gfx&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">version = &quot;0.1.0&quot; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rev = &quot;bd7f058efe78d7626a1cc6fbc0c1d3702fb6d2e7&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 本地项目导入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hello_utils = { path = &quot;../hello_utils&quot;, version = &quot;0.1.0&quot; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 默认不会被编译, 但是定义了一个 和依赖名称一样的 feature, 即 gif, 在代码中可以使用 cfg(feature = &quot;gif&quot;), 然后命令行中可以 --features gif 使用条件编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 当然, 也能这样使用: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # [dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # ravif = { version = &quot;0.6.3&quot;, optional = true }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # rgb = { version = &quot;0.8.25&quot;, optional = true }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # [features]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # avif = [&quot;ravif&quot;, &quot;rgb&quot;] (无法直接使用 raif, 或者 rgb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">gif = { version = &quot;0.11.1&quot;, optional = true }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># [dev-dependencies]表的作用用来设置测试( tests)、示例 (examples)和基准测试( benchmarks)时使用的依赖, 在执行 cargo test 或 cargo bench 命 令 时使用 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[dev-dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># build 依赖库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[build-dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cc = &quot;1.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 打开指定 feature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serde = { version = &quot;1.0.118&quot;, features = [&quot;derive&quot;] }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 禁用默认打开的 feature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">flate2 = { version = &quot;1.0.3&quot;, default-features = false, features = [&quot;zlib&quot;] }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 条件编译功能 (选择性地编 译 代 码)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 通过命令行 --features &quot;foo bar&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 默认所有 features 是关闭的, 除非手动打开, 通过 default feature 可以改变这一默认约定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 可以通过引入依赖时指定 default-features=false 即 flate2 = { version = &quot;1.0.3&quot;, default-features = false, features = [&quot;zlib&quot;] } 来防止默认打开某些 feature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[features]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">default=[&quot;use_std&quot;] # use_std feature 就默认打开了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use_std=[]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unstable= [&quot;pattern&quot;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">patter=[]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 打开jpeg-decoder依赖的 rayon feature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">parallel = [&quot;jpeg-decoder/rayon&quot;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 最终编译目标库的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[lib]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = foo # 表示将来编译的库名字为“libfooa” 或 “libfoo.so&quot;等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">crate-type = dylib # 比如 crate-type = [”dylib”, ”staticlib”]，表示可 以同时编译生成动态库和静态库。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path = &quot;src/lib.rs&quot; # 表示库文件入口 ， 如果不指定， 则默认是 src/lib.rs。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">test=true # 表示可以使用单元测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bench = true # 表示可以使用性能基准测试, 若代码中没有提供性能基准测试, 则可设置为  false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 双中括号 -&gt; 数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[[test]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path = &quot;tests/test_default.rs&quot; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = &quot;default&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[[test]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = &quot;aa&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path = &quot;tests/aa.rs&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 使用本地仓库中的代码build</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[patch.crates-io]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uuid = { path = &quot;../path/to/uuid&quot; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 默认 master 分支, # 手动指定 commit id, 不过有了 lock 文件, 就不必这么干了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uuid = {git = &quot;https://github.com/uuid-rs/uuid.git&quot;,  rev = &quot;9f35b8e&quot;} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 四个内建的 profile : dev, release, test, and bench, 在命令行通过 --release 指定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 对每个 profile 进行更细致的配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 分别代表对 Release、 Bench 和 Test, debug 四种 编译模式进行配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[profile.release]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">debug=true # 编译时, 包含 debug 信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 优化级别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">opt-level = 3 # 编译优化, 耗时更长</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[profile.bench]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">debug=true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[profile.test]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">debug=true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[profile.dev]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">opt-level = 0 # 优化级别, 命令行通过  -C opt-level=1 指定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # 0: no optimizations, also turns on cfg(debug_assertions) (the default).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # 1: basic optimizations.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # 2: some optimizations.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # 3: all optimizations.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # s: optimize for binary size.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                # z: optimize for binary size, but also turn off loop vectorization.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">overflow-checks = false # Disable integer overflow checks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lto= # 连接时间优化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="854-cargolock">8.5.4. cargo.lock<a href="#854-cargolock" class="hash-link" aria-label="Direct link to 8.5.4. cargo.lock" title="Direct link to 8.5.4. cargo.lock">​</a></h3><p>锁定依赖版本</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="855-workspace">8.5.5. workspace<a href="#855-workspace" class="hash-link" aria-label="Direct link to 8.5.5. workspace" title="Direct link to 8.5.5. workspace">​</a></h3><p>工作空间可以管理多个 proj 和 lib</p><p>新建 Cargo.toml 作为根包的元数据 (工作空间中的子包 也都有自己的 Cargo.toml 配置，各自独立， 互不影响)</p><div class="language-t codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-t codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[workspace]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">members = [</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;main&quot;, # 可执行 主程序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;core&quot;, # 核心类库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;util&quot;, # 工具库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>不管是编译根包还是子包，最终的编译结 果永远都会输出到根包的 target 目录下，并且整个工作空间只允许有一个 Cargo.lock 文件。</p><p><code>cargo new [--bin] main</code>, <code>cargo new --lib core</code>, <code>cargo new --lib util</code>; 由于每次创建时, cargo 都会检查 顶层 Cargo 配置文件中的 member 是否都存在, 所以中间可能检查出现错误, 不必担心, 全部创建完错误就消失了</p><p>lib 类型类型需要将新建的 module (即rs文件) 在 lib.rs 中声明 <code>pub mod xxx</code>, pub 可选</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="856-依赖的版本号规则">8.5.6. 依赖的版本号规则<a href="#856-依赖的版本号规则" class="hash-link" aria-label="Direct link to 8.5.6. 依赖的版本号规则" title="Direct link to 8.5.6. 依赖的版本号规则">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Rust 包使用的是语义化版本号 (SemVer)。基本格式为“X卫Z”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • x，主版本号 当做了不兼容或颠覆性的更新时 ， 修改此版本号。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • y， ;欠版本号 (minor)。当做了向下兼容的功能性修改时，修改此版本号 。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// • z，修订版本号 (patch)。当做了向下兼容的问题修正时，修改此版本号。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 符号:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ^: 版本号必须大于指定版本, 新的版本必须满足不修改[major, minor, patch]中最左边非零数字。如指定 ^1.0.0, 等价于 &gt;=1.0.0 &lt;2.0.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// *: 通配符, 可以用在[major, minor,patch]的任何一个上面。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ~: 允许修改[major, minor, patch]中没有明确指定的版本号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 手动指定， 通过 &gt;, &lt;, =, &gt;=, &lt;= 来指定版本号 。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="86-buildrs">8.6. build.rs<a href="#86-buildrs" class="hash-link" aria-label="Direct link to 8.6. build.rs" title="Direct link to 8.6. build.rs">​</a></h2><p>build.rs可实现本项目编译前的额外操作，比如代码生成(如 grpc)、调用cmake/clang/gcc/ndk-build等编译所依赖的C/C++库、读取C/C++头文件生成FFI文件给Rust项目使用等等，相当于Rust写的shell脚本</p><p>先于 cargo build 被编 译</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="87-项目管理案例">8.7. 项目管理案例<a href="#87-项目管理案例" class="hash-link" aria-label="Direct link to 8.7. 项目管理案例" title="Direct link to 8.7. 项目管理案例">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="871-导出自定义宏">8.7.1. 导出自定义宏<a href="#871-导出自定义宏" class="hash-link" aria-label="Direct link to 8.7.1. 导出自定义宏" title="Direct link to 8.7.1. 导出自定义宏">​</a></h3><p><code>cargo new --bin hello_macro</code>, 新建 lib.rs (名字任意), 定义 macro, 导出</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[macro_export]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! map {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 统计 item 个数时使用的单位, 这里使用 空元组, 不占空间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // @unit 是约定俗成的在宏内部定义宏的命名规则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 必须定义在开头条, 否则就按照普通匹配分支处理了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (@unit $($x:tt)*) =&gt; {()};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (@count $($key:expr),* ) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (&lt;[()]&gt;::len(&amp;[$(map!(@unit $key)),*]));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($($key:expr =&gt; $value:expr),* $(,)*) =&gt; (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let _cap = map!(@count $($key),*);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut _map = std::collections::HashMap::with_capacity(_cap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           $(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               _map.insert($key, $value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           )*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           _map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 main.rs 中导入使用</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// #[macro_use] extern crate hello_async; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use hello_macro::map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let map = map!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1 =&gt; &quot;a&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        2 =&gt; &quot;b&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 导出同个包下, 其他 mod 内的宏</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[macro_use]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mod macros {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     macro_rules! xxx {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     macro_rules! yy {..}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 直接使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    xxx!(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="872-导入自定义-crate">8.7.2. 导入自定义 crate<a href="#872-导入自定义-crate" class="hash-link" aria-label="Direct link to 8.7.2. 导入自定义 crate" title="Direct link to 8.7.2. 导入自定义 crate">​</a></h3><p><code>cargo new web-server</code></p><p><code>cd web-server</code></p><p><code>cargo new --lib thread-pool</code></p><p>修改 web-server 的 cargo.toml:</p><div class="language-t codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-t codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thread-pool = {path = &quot;./thread-pool&quot; } # 必须为 thread-pool, 和库名一致; thread_pool 错误, threadpool错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    # 使用: use thread_pool::xxxx (变为下划线)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="873-执行子目录中的-module">8.7.3. 执行子目录中的 module<a href="#873-执行子目录中的-module" class="hash-link" aria-label="Direct link to 8.7.3. 执行子目录中的 module" title="Direct link to 8.7.3. 执行子目录中的 module">​</a></h3><div class="language-t codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-t codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[[example]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = &quot;udp_server&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path = &quot;examples/udp_server.rs&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[[example]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = &quot;udp_client&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path = &quot;examples/udp_client.rs&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[[example]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = &quot;tcp_server&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path = &quot;examples/tcp_server.rs&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[[example]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name = &quot;tcp_client&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">path = &quot;examples/tcp_client.rs&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>然后在 /examples 下新建 rs 文件, 写 main 方法即可</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="874-导入自定义-module">8.7.4. 导入自定义 module<a href="#874-导入自定义-module" class="hash-link" aria-label="Direct link to 8.7.4. 导入自定义 module" title="Direct link to 8.7.4. 导入自定义 module">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//ferris_says  为自定义 module</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mod ferris_says; // 方法 1: 通过声明导入 module</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use ferris_says::say;// 方法 2: 导入模块的方法  // 支持 as , 如 use xxx as yyy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io::{stdout, BufWriter}; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let stdout = stdout();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let message = String::from(&quot;Hello fellow Rustaceans!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let width = message.chars().count();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut writer = BufWriter::new(stdout.lock());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    say(message.as_bytes(), width, &amp;mut writer).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="875-导入第三方-crate">8.7.5. 导入第三方 crate<a href="#875-导入第三方-crate" class="hash-link" aria-label="Direct link to 8.7.5. 导入第三方 crate" title="Direct link to 8.7.5. 导入第三方 crate">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Rust 2015 版本的写法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在 Rust2018 版本中，可以省略掉 extern erate, 因为在 Cargo.toml 中已经添加了依赖 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// extern crate 声明包的名称 是 linked_list， 用的是下画线“_”， 而在 Cargo.tom! 中用的是连字符&quot;-&quot;。这是怎么回事呢?其实 Cargo 默认会把连字符转换成 下画线 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extern crate linked_list，</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>9. 单元测试</h1><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// 单元测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 使用 cargo test 运行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 运行某个特定的测试方法 cargo test test_any_panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// cargo test panic 方法名中含有 panic 的测试方法会运行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[cfg(test)]// 条件编译 ， 告诉编译器只在运行测试( cargo test 命令)时才编译执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mod tests {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 注意这个惯用法：在 tests 模块中，从外部作用域导入所有名字。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use super::*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[test]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn test_xx() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;hello unit test&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 测试 panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[test]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[ignore] // 忽略测试, 或者使用 cargo test -- --ignored 命令来运行它们。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[should_panic(expected = &quot;assertion failed&quot;)] // 倒置我们的测试结果 (如果发生错误测试将会成功并且如果没有错误会失败), 一般 和 `(expected = &quot;assertion failed&quot;)` 一起使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn test_any_panic() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        divide_non_zero_result(1, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 测试 带有输出文本的panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[test]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[should_panic(expected = &quot;Divide result is zero&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn test_specific_panic() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        divide_non_zero_result(1, 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>10. 交叉编译 and 条件编译</h1><p><a href="https://github.com/japaric/rust-cross#tldr-ubuntu-example" target="_blank" rel="noopener noreferrer">https://github.com/japaric/rust-cross#tldr-ubuntu-example</a>
<a href="https://zhuanlan.zhihu.com/p/76611800" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/76611800</a>
<a href="https://zhuanlan.zhihu.com/p/128626720" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/128626720</a></p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">///条件编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// cfg 属性：在属性位置中使用 #[cfg(...)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///cfg! 宏：在布尔表达式中使用 cfg!(...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn condition_compile() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个函数仅当目标系统是 Linux 的时候才会编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[cfg(target_os = &quot;linux&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn are_you_on_linux() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;You are running linux!&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 而这个函数仅当目标系统 **不是** Linux 时才会编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[cfg(not(target_os = &quot;linux&quot;))]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn are_you_on_linux() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;You are *not* running linux!&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    are_you_on_linux();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if cfg!(target_os = &quot;linux&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Yes. It&#x27;s definitely linux!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Yes. It&#x27;s definitely *not* linux!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自定义条件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `rustc --cfg some_condition custom.rs &amp;&amp; ./custom`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // #[cfg(some_condition)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fn conditional_function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //     println!(&quot;condition met!&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // conditional_function();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>11. 并发</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="111-通用概念">11.1. 通用概念<a href="#111-通用概念" class="hash-link" aria-label="Direct link to 11.1. 通用概念" title="Direct link to 11.1. 通用概念">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1111-进程-and-线程">11.1.1. 进程 and 线程<a href="#1111-进程-and-线程" class="hash-link" aria-label="Direct link to 11.1.1. 进程 and 线程" title="Direct link to 11.1.1. 进程 and 线程">​</a></h3><p>进程是资源分配的最小单元，线程是程序执行时的最小单元 </p><p>可以使用多进程来提供并发，比如 Master-Worker 模式，由 Master 进程来管理 Worker 子进程， Worker 子进程执行任务 。 Master 和 Worker 之间通常使用 Socket 来进行进程间通信好处是程序健壮, 缺点是耗费资源</p><p>使用线程提供并发, 占用资源少, 但是编程调试相当复杂</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1112-事件回调实现的异步并发">11.1.2. 事件回调实现的异步并发<a href="#1112-事件回调实现的异步并发" class="hash-link" aria-label="Direct link to 11.1.2. 事件回调实现的异步并发" title="Direct link to 11.1.2. 事件回调实现的异步并发">​</a></h3><blockquote><p>多进程/线程 实现的并发, 还是无法支撑万级别的并发访问, 因为就算一个线程处理一个连接, 也要上万线程, 这时候服务器也崩了</p></blockquote><p>事件驱动实现并发: 只有一个线程, 不断从事件队列中查询是否有事件发生, 若有, 则调用关联的回调函数, 整个过程是非阻塞的</p><ol><li><p>为了解决回调地狱的问题, 新的方案出现了 --&gt; Promise, Future, promise 站在任务处理者的角度，将异步任务完成或失败的 状态标记到 Promise 对象中 。 Future 则站在任务调用者的角度，来检测任务是否完成，如果 完成则直接获取结果，如果未完成则阻塞直到获取到结果 ， 或者编写回调函数避免阻塞</p></li><li><p>为了进一步解决代码冗余 ---&gt; 协程: 描述了一种任务协同执行的方式, 只有一个线程, 同时处理多个任务, 一个时间片在执行任务 1, 某个时间片又切到执行任务 2, 看起来就好像任务 1,2 同时在执行 (整个概念类似 CPU 对线程的调度方式)</p><p>总的来说，协程可以让开发者用写同步(顺序)代码的方 式编写可异步执行的代码 </p><p>协程是以线程为容器的， 协程的特点是内存占用比线程更小、上下文切换的开销更小, 也被称为用户 态线程，所以可大量使用</p><p>虽然充分挖掘了单线程的利用率，在 单线程下可以处理高并发io，但却无法利用多核, 因为始终只有一个线程。</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="112-线程基本使用">11.2. 线程基本使用<a href="#112-线程基本使用" class="hash-link" aria-label="Direct link to 11.2. 线程基本使用" title="Direct link to 11.2. 线程基本使用">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1121-创建线程">11.2.1. 创建线程<a href="#1121-创建线程" class="hash-link" aria-label="Direct link to 11.2.1. 创建线程" title="Direct link to 11.2.1. 创建线程">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// 并发 闭包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// Rust 中通过 std::thread::spawn 函数创建本地操作系统（native OS）线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// spawn() 返回新线程的句柄（handle），我们必须拥有句柄，才能获取线程的返回值, 通过 handle.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn concurrent() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::time::Duration;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 普通函数的写法, 不推荐写法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn spawn_function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i in 0..5 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;spawned thread print {}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            thread::sleep(Duration::from_millis(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let t = thread::spawn(spawn_function);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 闭包的写法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let t = thread::spawn(|| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for i in 0..5 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;spawned thread print {}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            thread::sleep(Duration::from_millis(1));// 睡眠</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t.join().unwrap();// 等待线程结束 or 获取返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //move 强制所有权迁移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //在子线程中尝试使用当前函数的资源, 这一定是错误的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 需要使用 move, 将资源所有权移动到子线程内部使得外部资源失效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let s = &quot;hello&quot;; // 若是 &amp;str 类型, 则 move 执行的是 copy, 闭包外层 s 还是有效的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = &quot;hello&quot;.to_owned();// 若为 String, 则 move 执行 移动语义, s 失效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let handle = thread::spawn(move || {// 一定要加 move</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;sub thread, s = {}&quot;, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 错误, s已经 失效了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;main thread, s= {}&quot;, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    handle.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1122-自定义配置线程">11.2.2. 自定义配置线程<a href="#1122-自定义配置线程" class="hash-link" aria-label="Direct link to 11.2.2. 自定义配置线程" title="Direct link to 11.2.2. 自定义配置线程">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 设置线程栈, 线程名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> // 直接使用 thread::spawn生成的线程， 默认没有名称， 并且其栈大小默认为 2MB (其实底层还是通过 builder 创建的)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用 thread::Builder 结构体来创建可配置的线 程, 主线程无法配置, 和 rust 无关, 因为主线程默认使用 进程的栈, 由操作系统决定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 也可以通过指定环境变 量 RUST_MIN_STACK  设置新创建的线程的线程栈, 会被 builder 覆盖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{panic::catch_unwind, thread::{Builder, current}};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut ths = vec![];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for id in 0..3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let thread_builder = Builder::new()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .name(format!(&quot;child-{}&quot;, id))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // unit: byte</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .stack_size(3 * 1024);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let child = thread_builder.spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;child id = {}&quot;, id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if id == 2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // panic!(&quot;panic.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                catch_unwind(|| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    panic!(&quot;panic.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                println!(&quot;catch panic in {}&quot;, current().name().unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ths.push(child);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for t in ths {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1123-线程本地变量">11.2.3. 线程本地变量<a href="#1123-线程本地变量" class="hash-link" aria-label="Direct link to 11.2.3. 线程本地变量" title="Direct link to 11.2.3. 线程本地变量">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 线程本地变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::cell::RefCell;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    thread_local!(static FOO: RefCell&lt;u32&gt; = RefCell::new(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FOO.with(|f| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert_eq!(*f.borrow(), 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *f.borrow_mut() = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    thread::spawn(|| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       FOO.with(|f| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           assert_eq!(*f.borrow(), 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           *f.borrow_mut() = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   FOO.with(|f| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       assert_eq!(*f.borrow(), 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1124-手动阻塞唤醒">11.2.4. 手动阻塞唤醒<a href="#1124-手动阻塞唤醒" class="hash-link" aria-label="Direct link to 11.2.4. 手动阻塞唤醒" title="Direct link to 11.2.4. 手动阻塞唤醒">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::time::Duration;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let parked_thread = thread::Builder::new()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .spawn(|| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;Parking thread&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 阻塞</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 也可以 通过 std::thread: :park_timeout 来显 式指定阻塞超时时间 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            thread::park();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;Thread unparked&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   thread::sleep(Duration::from_millis(10));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   println!(&quot;Unpark the thread&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    唤醒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   parked_thread.thread().unpark();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   parked_thread.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 此外, 还有 yield_now() 谦让, 让出 cpu 控制权</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="113-线程同步">11.3. 线程同步<a href="#113-线程同步" class="hash-link" aria-label="Direct link to 11.3. 线程同步" title="Direct link to 11.3. 线程同步">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1131-错误示例">11.3.1. 错误示例<a href="#1131-错误示例" class="hash-link" aria-label="Direct link to 11.3.1. 错误示例" title="Direct link to 11.3.1. 错误示例">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 在线程间传递可变字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 直接使用 String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread::spawn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = String::from(&quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _i in 0..3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s.push_str(&quot;xxx&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 Rc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{rc::Rc, thread::spawn};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 想在多个线程中共享s，则需要使用。 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Rc实现了!Send, 不可在线程间传递所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = Rc::new(String::from(&quot;hello&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _i in 0..3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut s_clone = s.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // spawn 函数传入的 闭包没有实现 Send，这是因为捕获变量没</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 有实现 Send。捕获变量是 Rc&lt;String&gt;类型， 实现的是!Send，正好和 Send相反</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s_clone.push_str(&quot;xxx&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用可以在多线程间被移动和共享的 Arc&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{sync::Arc, thread::spawn};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = Arc::new(String::from(&quot;hello&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _i in 0..3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s_clone = s.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这是因为 Arc&lt;T&gt;默认是不可变的, 考虑使用具有内部可变性的类型, 如 Cell/RefCell</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s_clone.push_str(&quot;xxx&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用 RefCell 提供内部可变性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{cell::RefCell, sync::Arc, thread::spawn};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = Arc::new(RefCell::new(String::from(&quot;hello&quot;)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _i in 0..3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s_clone = s.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // `RefCell&lt;String&gt;` cannot be shared between threads safely</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let s_clone = s_clone.borrow_mut();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s_clone.push_str(&quot;xxx&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 正确方式: 使用 Mutex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{sync::{Arc, Mutex}, thread::spawn};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Arc 用于支持安全的多引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Mutex 用于安全的提供内部可变性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = Arc::new(Mutex::new(String::from(&quot;hello&quot;)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut ths = vec![];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _i in 0..3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s_ref = s.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let child = spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut s_ref_mut = s_ref.lock().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s_ref_mut.push_str(&quot; xxx&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ths.push(child);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for t in ths {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1132-锁">11.3.2. 锁<a href="#1132-锁" class="hash-link" aria-label="Direct link to 11.3.2. 锁" title="Direct link to 11.3.2. 锁">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Mutex&lt;T&gt; 互斥锁: 支持跨线程安全共享可变变量的容器, 同时只允许一个线程访问内部 可变数据, 类似 线程安全版本的 RefCell</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// - lock() 返回内部数据的可变引用(阻塞当前线程, 直到拿到锁)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      返回值 LockResult&lt;MutexGuard&lt;T&gt;&gt;, 超出作用域会自动释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - try_lock() 获取 锁的时候不会阻塞当前线程, 如果得到锁 ， 就返回 MutexGuard&lt;T&gt;; 如果得不到锁，就返回 Err。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// RefCell&lt;T&gt;: 使得内部数据可变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  Rc&lt;T&gt;: 原子引用计数 , 允许多引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  Arc&lt;T&gt; : 线程安全的 Rc&lt;T&gt;, 允许多线程下的多引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// Mutex&lt;T&gt; : 线程安全的 RefCell, 提供多线程下内部数据的可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 通道都类似于单所有权，因为一旦将一个值传送到通道中，将无法再使用这个值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 锁类似于多所有权: 多个线程可以访问相同的内存位置 , 只是不能同一时候访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn lock_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 计数器示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::sync::{Mutex, Arc};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 不能仅仅使用 Mutex::new(0), 因为有多个 Thread需要它, counter移动进入某个Thread后其他Thread就没法拥有counter了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 也不能用Rc::new(Mutex::new(0)), 因为Rc&lt;T&gt;的引用计数, 在多线程下不安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let counter = Arc::new(Mutex::new(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut handles = vec![];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _ in 0..10 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let counter = Arc::clone(&amp;counter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let counter = counter.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let handle = thread::spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // lock() 这个调用会阻塞当前线程, 直到获取锁为止</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //如果另一个线程拥有锁，并且那个线程 panic 了，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 则本线程 lock 调用会失败。在这种情况下，没人能够再获取锁，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 所以这里选择 unwrap 在遇到这种情况时使线程直接 panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //返回 result, 拆包后是 MutexGuard&lt;T&gt;, 是个智能指针, 实现了 Deref所以可以解引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 实现了 Drop ,当 MutexGuard 离开作用域时自动释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut num = counter.lock().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 解引用后, 数据是可变的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            *num += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handles.push(handle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for handle in handles {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handle.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 中毒: 线程在获得锁之后发生恐慌</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mutex = Arc::new(Mutex::new(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c_mutex = mutex.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _ = thread::spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut data = c_mutex.lock().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *data = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 子线程 panic, 中毒了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        panic!(&quot;oh no&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }).join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    是否中毒, 即查看获取锁的子线程是否 panic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   assert_eq!(mutex.is_poisoned(), true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    主线程获取锁, 当然获取不到</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   match mutex.lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    不可达</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       Ok(_) =&gt; unreachable!(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       Err(p_err) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //    提供了 get_ref或 get_mut方法, 获取锁内部的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           let data = p_err.get_ref();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           println!(&quot;recovered: {}&quot;, data);//2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 读写锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // RwLock&lt;T&gt; 支持多个读线程和一个写线程同时访问 (不像 Mutex&lt;T&gt;只能线程独占访问)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 只要线程没有拿到写锁 ， RwLock&lt;T&gt;就 允许任意数量 的读线程获得读锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let lock = RwLock::new(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 读锁和 写锁要使用显式作用域块隔离开 ，这样的话 ， 读锁或写锁才能在离开作用 域之后自 动释放 ; 否则会引起死锁，因为读锁和写锁不能同时存在 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取多个读锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let r1 = lock.read().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let r2 = lock.read().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert_eq!(*r1, 5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert_eq!(*r2, 5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //    获取写锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       let mut w = lock.write().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       *w += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       assert_eq!(*w, 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 屏障 (类似 java 的 CountDownLatch)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::sync::{Arc, Barrier};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut handles = Vec::with_capacity(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let barrier = Arc::new(Barrier::new(5));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _ in 0..5 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let c = barrier.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handles.push(thread::spawn(move|| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;before wait&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使得当前子线程阻塞, 知道 clone 5 次后 barrie 归零后, 线程恢复执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           c.wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           println!(&quot;after wait&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for handle in handles {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       handle.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 条件变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 满足指定条件之前阻塞某一个得到互斥锁的线程 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 条件变量需要配合互斥锁才能使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 每个条件变量每次只能和一个互斥体一起使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 使用场景: 当状态成立时通知互斥体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::sync::{Arc, Condvar, Mutex};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pair = Arc::new((Mutex::new(false), Condvar::new()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pair_clone = pair.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    thread::spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let &amp;(ref lock, ref cvar) = &amp;*pair_clone;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut started = lock.lock().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 修改锁内部数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *started = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 通知主线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       cvar.notify_one();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let &amp;(ref lock, ref cvar) = &amp;*pair;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut started = lock.lock().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   while !*started {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       println!(&quot;{}&quot;, started); // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //阻塞当前线程(主线程), 直到收到条件变量的通知</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       started = cvar.wait(started).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       println!(&quot;{}&quot;, started); // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1133-原子类型">11.3.3. 原子类型<a href="#1133-原子类型" class="hash-link" aria-label="Direct link to 11.3.3. 原子类型" title="Direct link to 11.3.3. 原子类型">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// AtomicBool、 AtomicIsize、 AtomicPtr 和 AtomicUsize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实现自旋锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::sync::Arc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::sync::atomic::{AtomicUsize, Ordering};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 初始值设置为 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let spinlock = Arc::new(AtomicUsize::new(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let spinlock_clone = spinlock.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let thread = thread::spawn(move|| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 修改为 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同时指定内存顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spinlock_clone.store(0, Ordering::SeqCst);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若不为 0, 则自旋</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   while spinlock.load(Ordering::SeqCst) != 0 {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//    阻塞主线程, 等待子线程完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if let Err(panic) = thread.join() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       println!(&quot;Thread had an error: {:?}&quot;, panic);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1134-channel">11.3.4. channel<a href="#1134-channel" class="hash-link" aria-label="Direct link to 11.3.4. channel" title="Direct link to 11.3.4. channel">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// channel 消息传递</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// 具体实现实际上是一个 多生产者单消费者 (Multi-Producer-Single-Consumer, MPSC) 的先进先出(FIFO〕 队列, 底层基于链表实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 三种类型的csp 进程:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Sender 用于发送异步消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - SyncSender 发送同步消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Receiver接收消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 两种类型的 channel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 异步无界 Channel -  let (sender, receiver):  (Sender, Receiver) = channel(); 发送消息是异步无阻塞的, 缓冲区无限大</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 同步有界 Channel -  let (sender, receiver):  (SyncSender, Receiver) = sync_channel(size);可以预分配具有固定大小的缓冲区 , 满了就阻塞消息发送, 若缓冲区 == 0, sender和 receiver 间变为原子操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn channel_demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //一个发送者（transmitter）和一个接收者（receiver）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::sync::mpsc;// mpsc 是 多个生产者，单个消费者（multiple producer, single consumer）的缩写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // tx: 发送者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // rx : 接收者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 此时还无法编译, 因为 Rust 不知道我们想要在通道中发送什么类型, 后续编译器能够自动推断类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (tx, rx) = mpsc::channel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //创建一个新线程作为发送者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // //使用 move 将 tx 移动到闭包中这样新建线程就拥有 tx 了, 当</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 发送者执行完逻辑, 退出作用域, tx 也就自动析构了, 接收端也就收到关闭的信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // (若没有 使用 move, tx 始终存活, 无法自动析构, 会造成 接收者始终阻塞)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    thread::spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let val = String::from(&quot;hi&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tx.send(val).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 接收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这个方法会阻塞主线程执行直到从通道中接收一个值, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //当通道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //try_recv 不会阻塞，相反它立刻返回一个 Result&lt;T, E&gt;：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //可以编写一个循环来频繁调用 try_recv，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let received = rx.recv().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Got: {}&quot;, received);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //也可以迭代接收器, 当通道被关闭时，迭代器也将结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for received in rx {// 或者 rx.iter()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;Got: {}&quot;, received);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //通过克隆发送者来创建多个生产者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    use std::sync::mpsc::{Sender, Receiver};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static NTHREADS: i32 = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();// 手动指定传输数据的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for id in 0..NTHREADS {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // sender 端可被复制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let thread_tx = tx.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 或者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let tx1 = mpsc::Sender::clone(&amp;tx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread::spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 被创建的线程取得 `thread_tx` 的所有权</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            thread_tx.send(id).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;thread {} finished&quot;, id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut ids = Vec::with_capacity(NTHREADS as usize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _ in 0..NTHREADS {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 若无可用消息的话，`recv` 将阻止当前线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ids.push(rx.recv());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 显示消息被发送的次序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:?}&quot;, ids);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1135-tokio-中的各种-channel-实现">11.3.5. tokio 中的各种 channel 实现<a href="#1135-tokio-中的各种-channel-实现" class="hash-link" aria-label="Direct link to 11.3.5. tokio 中的各种 channel 实现" title="Direct link to 11.3.5. tokio 中的各种 channel 实现">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sync : 容量有限, sender 会被 block</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async: 容量无限, sender 不会被 block</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rendezvous: 容量为 0, 用于线程间同步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">oneshot: 只允许发送一次数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async/await : 和 sync channel 类似, 但是 waker 不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="114-多线程小例子">11.4. 多线程小例子<a href="#114-多线程小例子" class="hash-link" aria-label="Direct link to 11.4. 多线程小例子" title="Direct link to 11.4. 多线程小例子">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1141-实现线程池">11.4.1. 实现线程池<a href="#1141-实现线程池" class="hash-link" aria-label="Direct link to 11.4.1. 实现线程池" title="Direct link to 11.4.1. 实现线程池">​</a></h3><p>第三方包: threadpool</p><p>这里手动实现</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1142-实现-map-reduce-算法">11.4.2. 实现 map-reduce 算法<a href="#1142-实现-map-reduce-算法" class="hash-link" aria-label="Direct link to 11.4.2. 实现 map-reduce 算法" title="Direct link to 11.4.2. 实现 map-reduce 算法">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //例子:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //实现 map-reduce 算法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let data = &quot;86967897737416471853297327050364959</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11861322575564723963297542624962850</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70856234701860851907960690014725639</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38397966707106094172783238747669219</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52380795257888236525459303330302837</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58495327135744041048897885734297812</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69920216438980873548808413720956532</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16278424637452589860345374828574668&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 创建一个向量，用于储存将要创建的子线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut children = vec![];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let chunked_data = data.split_whitespace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i, data_segment) in chunked_data.enumerate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        children.push(thread::spawn(move || -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 计算该段的每一位的和：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let result = data_segment</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 对该段中的字符进行迭代..</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .chars()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // ..把字符转成数字..</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // ..对返回的数字类型的迭代器求和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .sum();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // println! 会锁住标准输出，这样各线程打印的内容不会交错在一起</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;processed segment {}, result={}&quot;, i, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 不需要 “return”，因为 Rust 是一种 “表达式语言”，每个代码块中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 最后求值的表达式就是代码块的值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 把每个线程产生的中间结果收入一个新的向量中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut intermediate_sums = vec![];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for child in children {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 收集每个子线程的返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let intermediate_sum = child.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intermediate_sums.push(intermediate_sum);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Final sum result: {}&quot;, final_result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1143-多线程统计和">11.4.3. 多线程统计和<a href="#1143-多线程统计和" class="hash-link" aria-label="Direct link to 11.4.3. 多线程统计和" title="Direct link to 11.4.3. 多线程统计和">​</a></h3><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const TOTAL_SIZE:usize = 100 * 1000; //数组长度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const NTHREAD:usize = 6; //线程数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let data : Vec&lt;i32&gt; = (1..(TOTAL_SIZE+1) as i32).collect(); //初始化一个数据从1到n数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let arc_data = Arc::new(data); //data 的所有权转给了 ar_data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let result  = Arc::new(AtomicU64::new(0)); //收集结果的数组(原子操作)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut thread_handlers = vec![]; // 用于收集线程句柄</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i in 0..NTHREAD {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // clone Arc 准备move到线程中，只增加引用计数，不会深拷贝内部数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let test_data = arc_data.clone(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let res = result.clone(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread_handlers.push( </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            thread::spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let id = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //找到自己的分区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let chunk_size = TOTAL_SIZE / NTHREAD + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let start = id * chunk_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let end = std::cmp::min(start + chunk_size, TOTAL_SIZE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //进行求和运算</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let mut sum = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for  i in start..end  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sum += test_data[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //原子操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res.fetch_add(sum as u64, Ordering::SeqCst);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                println!(&quot;id={}, sum={}&quot;, id, sum );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //等所有的线程执行完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for th in thread_handlers {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        th.join().expect(&quot;The sender thread panic!!!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //输出结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;result = {}&quot;,result.load(Ordering::SeqCst));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1144-带线程池的-webserver">11.4.4. 带线程池的 webserver<a href="#1144-带线程池的-webserver" class="hash-link" aria-label="Direct link to 11.4.4. 带线程池的 webserver" title="Direct link to 11.4.4. 带线程池的 webserver">​</a></h3><p>main.rs 是项目启动入口</p><p>lib.rs 为 项目内部的 子库</p><p>main.rs :</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mod lib;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::net::{TcpListener, TcpStream};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io::{Read, Write};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::fs::read_to_string;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::time::Duration;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use thread_pool::ThreadPool;// 横线变为下划线了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pool = ThreadPool::new(4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for stream in listener.incoming().take(2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match stream {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ok(stream) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pool.execute(|| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    handle_conn_quick(stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // handle_conn_quick(stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Err(_) =&gt; eprintln!(&quot;error of connection&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn handle_conn_quick(mut stream: TcpStream) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut buf = [0u8; 512];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stream.read(&amp;mut buf).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;************** req ***************&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}\n&quot;, String::from_utf8_lossy(&amp;buf));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (status_line, html_path) = if buf.starts_with(get) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;resources/hello.html&quot;)// 相对于根路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if buf.starts_with(sleep) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread::sleep(Duration::from_secs(5));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;resources/hello.html&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;resources/404.html&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let resp = format!(&quot;{}{}&quot;, status_line, read_to_string(html_path).unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;************** resp ***************&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}\n&quot;, resp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stream.write(resp.as_bytes()).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stream.flush().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  这是单线程 webserver 的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[allow(dead_code)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn handle_conn(mut stream: TcpStream) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut buf = [0u8; 1024];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut content = String::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let len = stream.read(&amp;mut buf).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content.push_str(&amp;String::from_utf8_lossy(&amp;buf)[..]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if len &lt; buf.len() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let get = &quot;GET / HTTP/1.1\r\n&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (status_line, html_path) = if content.starts_with(get) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;resources/hello.html&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;resources/404.html&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let html = read_to_string(html_path).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let resp = format!(&quot;{}{}&quot;, status_line, html);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stream.write(resp.as_bytes()).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stream.flush().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>lib.rs:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread::{JoinHandle, spawn};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::sync::mpsc::{Sender, channel, Receiver};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::sync::{Arc, Mutex};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[cfg(test)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mod tests {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[test]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn it_works() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert_eq!(2 + 2, 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct ThreadPool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 要实现的行为是创建线程并稍后发送任务代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 所以不能直接存 Thread, 而要引入中间层 worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 若直接使用 Thread, 创建线程后, 任务会直接立即执行, 不行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    workers: Vec&lt;Worker&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sender: Sender&lt;Msg&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for ThreadPool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 向每个 worker发送终止消息, 使得任务代码跳出receive循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 为什么要分为两个for循环?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果尝试在同一循环中发送消息并立即 join 线程，则无法保证当前迭代的 worker 是从通道收到终止消息的 worker</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for _ in &amp;mut self.workers {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.sender.send(Msg::TerminateMsg).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for w in &amp;mut self.workers {// 需要获取workers的可变引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            println!(&quot;worker {} stop&quot;, w.id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // join 调用者需要是 非引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 那么, 需要一个方法将 thread 移动出拥有其所有权的 Worker 实例以便 join 可以消费这个线程。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // w.thread.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if let Some(thread) = w.thread.take() {//take 方法会取出 Some 而留下 None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                thread.join().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Msg {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    JobMsg(Job),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TerminateMsg,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type Job = Box&lt;dyn FnOnce() + Send + &#x27;static&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl ThreadPool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// 创建线程池。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// # Panics</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ///</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// `new` 函数在 size 为 0 时会 panic。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn new(size: usize) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        assert!(size &gt; 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut workers = Vec::with_capacity(size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let (sender, receiver) = channel();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let receiver = Arc::new(Mutex::new(receiver));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //多 生产者，单 消费者 的。这意味着不能简单的克隆通道的消费端来解决问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //我们希望通过在所有的 worker 中共享单一 receiver，在线程间分发任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for id in 0..size {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadPool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            workers,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sender,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn execute&lt;F&gt;(&amp;self, f: F)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 没参数, 没返回值的闭包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        where F: FnOnce() + Send + &#x27;static</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let job = Box::new(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.sender.send(Msg::JobMsg(job)).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Worker {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    id: usize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    thread: Option&lt;JoinHandle&lt;()&gt;&gt;,// &quot;()&quot; 表示线程中的任务没有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Worker {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;Receiver&lt;Msg&gt;&gt;&gt;) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let thread = spawn(move|| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 不可使用 while let, 因为while 表达式中的值还有块都一直处于作用域中, 锁无法释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 只能使用 loop 循环,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //使用 loop 并在循环块之内而不是之外获取锁和任务，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // lock 方法返回的 MutexGuard 在 let job 语句结</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 束之后立刻就被丢弃了。这确保了 recv 调用过程中持有锁，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 而在 job() 调用前锁就被释放了，这就允许并发处理多个请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let msg = receiver.lock().unwrap().recv().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                match msg {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Msg::JobMsg(job) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        println!(&quot;worker {} running&quot;, id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        job();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Msg::TerminateMsg =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        println!(&quot;worker {} receive terminate msg&quot;, id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            thread: Some(thread),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="115-rayon-并行执行任务">11.5. rayon 并行执行任务<a href="#115-rayon-并行执行任务" class="hash-link" aria-label="Direct link to 11.5. rayon 并行执行任务" title="Direct link to 11.5. rayon 并行执行任务">​</a></h2><p>轻松地将顺序计算转换为安全的并行计算，并且保证无数据竞争</p><p>底层使用 线程池执行任务, 若工作线程都被占用, 则新加的任务会顺序执行</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 并行迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extern crate rayon;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use rayon::prelude::*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn sum_of_squares(input: &amp;[i32]) -&gt; i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input.par_iter()// 返回一个不可变的并行迭代器类型, 通过 map 构造了新的 集合迭代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(|&amp;i| i * i).sum()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn increment_all(input: &amp;mut [i32]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input.par_iter_mut() // 回一个可变的并行迭代器类型。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .for_each(|p| *p += 1);// 直接在原有基础上修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let v = [1,2,3,4,5,6,7,8,9,10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let r = sum_of_squares(&amp;v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   println!(&quot;{}&quot;, r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let mut v = [1,2,3,4,5,6,7,8,9,10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   increment_all(&amp;mut v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   println!(&quot;{:?}&quot;, v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// join()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 并不保证接收的两个闭包一定并行执行, 因为 若 线程池中没有空闲的线程了, 新任务还是只能顺序执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extern crate rayon;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn fib(n: u32) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if n &lt; 2 { return n; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (a, b) = rayon::join(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 接收两个闭包 , 并行执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        || fib(n - 1), || fib(n - 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a + b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let r = fib(32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert_eq!(r, 2178309);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="116-crossbeam-无锁的数据结构">11.6. CrossBeam 无锁的数据结构<a href="#116-crossbeam-无锁的数据结构" class="hash-link" aria-label="Direct link to 11.6. CrossBeam 无锁的数据结构" title="Direct link to 11.6. CrossBeam 无锁的数据结构">​</a></h2><p>是对 标准库的扩展和包装，</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// - 扩展原子类型, 为基础库中的原子类型实现了 AtomicConsume trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Scoped 线程: 允许子线程可以安全地使用父线程中的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - 使用缓存行填充提升井发性能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - MPMC Channel: 多生产者多消 费者通道</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="117-rwlock-和-refcell">11.7. RwLock 和 RefCell<a href="#117-rwlock-和-refcell" class="hash-link" aria-label="Direct link to 11.7. RwLock 和 RefCell" title="Direct link to 11.7. RwLock 和 RefCell">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// RwLock&lt;T&gt;相当于线程安全版本的 RefCell&lt;T&gt;，同时运行多个 reader或者一个 writer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// RwLock 读写锁，是多读单写锁，也 叫共享独占锁 。 它允许多个线程读，单个线程写 。 但是在写的时候 ， 只能有一个线程占有写锁 ; 而在读的时候， 允许任意线程获取读锁 。 读锁和写锁不能被同时获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 所以在度多写少的场景, 使用 读写锁可以有更高的并发支持</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="118-mutex">11.8. Mutex<a href="#118-mutex" class="hash-link" aria-label="Direct link to 11.8. Mutex" title="Direct link to 11.8. Mutex">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Mutex&lt;T&gt;是锁，同一时间仅允许有-个线程进行操作, 不管是读还是写。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 本质是一个 struct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="119-atomicptr-和-cell">11.9. AtomicPtr 和 Cell<a href="#119-atomicptr-和-cell" class="hash-link" aria-label="Direct link to 11.9. AtomicPtr 和 Cell" title="Direct link to 11.9. AtomicPtr 和 Cell">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Atomic 系列类型: AtomicBool、 Atomiclsize、 AtomicUsize和AtomicPtr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 可以用 AtomicPtr 来模拟其他想要的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// AtomicPtr 相当于线程安全版本 的 Cell&lt;T&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1110-send-和-sync-trait">11.10. Send 和 Sync trait<a href="#1110-send-和-sync-trait" class="hash-link" aria-label="Direct link to 11.10. Send 和 Sync trait" title="Direct link to 11.10. Send 和 Sync trait">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Send 表示该类型的值可以安全的在多线程中传递, 转移 ownership (表示跨线程 move);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    几乎所有的Rust类型都是Send的，但是例外：例如Rc&lt;T&gt;是不能Send的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    任何完全由Send类型组成的类型也会自动被标记为Send</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Sync 表示类型可以安全的在多个线程中拥有其值的引用 (表示跨线程 share data, 可以被安全的 borrow)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    即，对于任意类型T，如果&amp;T（T 的引用）是Send的话T就是Sync的，这意味着其引用就可以安全的发送到另一个线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">手动实现Send和Sync是不安全的。通常并不需要手动实现Send和Sync trait，因为由Send和Sync的类型组成的类型，自动就是Send和Sync的。因为他们是标记trait，甚至都不需要实现任何方法</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>12. 异步并发</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="121-异步概念">12.1. 异步概念<a href="#121-异步概念" class="hash-link" aria-label="Direct link to 12.1. 异步概念" title="Direct link to 12.1. 异步概念">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1211-为什么使用异步">12.1.1. 为什么使用异步<a href="#1211-为什么使用异步" class="hash-link" aria-label="Direct link to 12.1.1. 为什么使用异步" title="Direct link to 12.1.1. 为什么使用异步">​</a></h3><p>想要同时运行多个任务, 可以使用多线程, 但是在不同线程之间的切换和线程之间的数据共享过程中，涉及到很多开销。即使是一个只是坐着什么都不做的线程，也会消耗宝贵的系统资源</p><p>异步可以在不创建多个线程的情况下同时运行多个任务, 具体来说就是使用协程 coroutine</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1212-普通多线程-webserver">12.1.2. 普通多线程 webserver<a href="#1212-普通多线程-webserver" class="hash-link" aria-label="Direct link to 12.1.2. 普通多线程 webserver" title="Direct link to 12.1.2. 普通多线程 webserver">​</a></h3><p>例子: 从两个 server下载, 第一个资源 耗时 3s, 第二个资源耗时 1s , 总共耗时 4s, 改为 多线程可以缩短为 3s, 但是有线程切换的开销, 最好的是 改为异步</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn start_client() -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 顺序执行, 耗时长, 4s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // connect_to_server(&quot;localhost&quot;, 8080, &quot;send to server0: 8080&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // connect_to_server(&quot;localhost&quot;, 8081, &quot;send to server1: 8081&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 多线程, 进一步, 可以考虑 使用线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut handles = Vec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let handle_server0 = spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        connect_to_server(&quot;localhost&quot;, 8080, &quot;send to server0: 8080&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    handles.push(handle_server0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let handle_server1 = spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        connect_to_server(&quot;localhost&quot;, 8081, &quot;send to server0: 8081&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    handles.push(handle_server1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for handle in handles {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handle.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn connect_to_server(host: &amp;str, port: u16, content: &amp;str) -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = TcpStream::connect((host, port))?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.write(content.as_bytes())?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut buf_reader = BufReader::new(&amp;s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut buf = Vec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buf_reader.read_until(b&#x27;\n&#x27;, &amp;mut buf)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;&gt;&gt;&gt; recv from server : {}&quot;, std::str::from_utf8(&amp;buf).unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// server1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn start_server1() -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let tcp_listener = TcpListener::bind(&quot;localhost:8080&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for stream in tcp_listener.incoming() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handle_conn(&amp;mut stream?, 3)?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//server2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn start_server2() -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let tcp_listener = TcpListener::bind(&quot;localhost:8081&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for stream in tcp_listener.incoming() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handle_conn(&amp;mut stream?, 1)?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn handle_conn(s: &amp;mut TcpStream, wait_seconds: u64) -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut buf = [0; 512];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let len = s.read(&amp;mut buf)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if len == 0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Ok(());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sleep(Duration::from_secs(wait_seconds));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.write(&amp;buf[..len])?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.write(&quot;\n&quot;.as_bytes())?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1213-改进后的异步版本">12.1.3. 改进后的异步版本<a href="#1213-改进后的异步版本" class="hash-link" aria-label="Direct link to 12.1.3. 改进后的异步版本" title="Direct link to 12.1.3. 改进后的异步版本">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    io::{BufRead, BufReader, Read, Result, Write},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    net::{TcpListener, TcpStream},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    str::from_utf8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use futures::{executor::block_on, join};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block_on(conn_all_async())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn conn_all_async() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f0 = conn_server_async(&quot;localhost&quot;, 8080, &quot;send to server0: 8080&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f1 = conn_server_async(&quot;localhost&quot;, 8081, &quot;send to server0: 8081&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    join!(f0, f1);// 等待 f0, f1 完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn conn_server_async(host: &amp;str, port: u16, content: &amp;str) -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    conn_serve(host, port, content)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn conn_serve(host: &amp;str, port: u16, content: &amp;str) -&gt; Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = TcpStream::connect((host, port))?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.write(content.as_bytes())?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut buf = Vec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut buf_reader = BufReader::new(&amp;s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buf_reader.read_until(b&#x27;\n&#x27;, &amp;mut buf)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;recv from server: {}&quot;, from_utf8(&amp;buf).unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="122-基本使用">12.2. 基本使用<a href="#122-基本使用" class="hash-link" aria-label="Direct link to 12.2. 基本使用" title="Direct link to 12.2. 基本使用">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1221-block_on">12.2.1. block_on<a href="#1221-block_on" class="hash-link" aria-label="Direct link to 12.2.1. block_on" title="Direct link to 12.2.1. block_on">​</a></h3><p>定义异步函数, 然后使用 block_on 阻塞主线程:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// futures = &quot;0.3&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use futures::executor::block_on;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let hello_future = hello();// 异步执行 (不会等待执行完), hello_future 代表异步函数的 handle 句柄</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;main finish&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 阻塞 main thread,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 接受一个 future, 返回真实结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block_on(hello_future);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 异步函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn hello() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;hello async&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1222-await">12.2.2. await<a href="#1222-await" class="hash-link" aria-label="Direct link to 12.2.2. await" title="Direct link to 12.2.2. await">​</a></h3><p>使用 .await 等待异步函数执行完, 用于多个异步函数有依赖关系</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// futures = &quot;0.3&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use futures::executor::block_on;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block_on(hello2());// 阻塞等待 hello2 执行完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn hello() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;hello async&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn hello1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hello().await;// 等待 hello() 执行完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;hello 1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn hello2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hello1().await; //等待 hello1 执行完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;hello 2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1223-joinn">12.2.3. joinn<a href="#1223-joinn" class="hash-link" aria-label="Direct link to 12.2.3. joinn" title="Direct link to 12.2.3. joinn">​</a></h3><p>并行执行异步函数</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use futures::executor::block_on;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::time::Duration;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let main = async_main();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block_on(main);//阻塞</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Song;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn learn_song() -&gt; Song {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 不能使用 thread::sleep</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    async_std::task::sleep(Duration::from_secs(1)).await; //async-std = &quot;1.5&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;learn song&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Song</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn sing_song(song: Song) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    async_std::task::sleep(Duration::from_secs(1)).await;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;sing song: {:?}&quot;, song);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn dance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;dance&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn learn_and_sing() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let song = learn_song().await;// 等待执行完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sing_song(song).await;// 也要加 await, 否则主线程不会等待 sing_song() 执行完就继续前进了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async fn async_main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f1 = learn_and_sing();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f2 = dance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `join!` 类似于 `.await` ，但是可以等待多个 future 并发完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    futures::join!(f1, f2); //  f1, f2 并行完成, 返回 (handle1, handle2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //dance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //learn song</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //sing song: Song</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="123-future并发模式">12.3. future并发模式<a href="#123-future并发模式" class="hash-link" aria-label="Direct link to 12.3. future并发模式" title="Direct link to 12.3. future并发模式">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1231-future底层是生成器">12.3.1. future底层是生成器<a href="#1231-future底层是生成器" class="hash-link" aria-label="Direct link to 12.3.1. future底层是生成器" title="Direct link to 12.3.1. future底层是生成器">​</a></h3><p>要支持async/await异步开发， 最好是能有协程的支持, </p><p>一种是有栈协程(Stackful); 另一种是无栈协程(Stackless)。对于有栈协程的实现， 一般每个协程都自带独立的栈，功能强大， 但是比较耗 内存， 性能不如无栈协程。 而无栈协程一般是基于状态机(StateMachine) 来实现的， 不使 用独立 的栈，具体的应用形式 叫生成器( Generator), rust 使用后者</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 基本使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#![feature(generators, generator_trait)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{ops::{Generator, GeneratorState}, pin::Pin};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 生成器无法接受参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 和闭包一样可以捕获外部环境的变量，也可以使用move关键字</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 生成器自动实现了Send和Sync,但不会自动实现Copy或Clone之类的trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut gen = || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        yield 1;// 每个 yield 对应一个不同的状态, 每次调用 resume(), 则返回对应值, 生成器暂时被挂起, 直到再次 调用 resume(), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        yield 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 3; // 调用 resume 返回 3, 则 生成器结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match Pin::new(&amp;mut gen).resume(()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        GeneratorState::Yielded(1) =&gt; {},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; panic!(&quot;error 1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match Generator::resume(Pin::new(&amp;mut gen), ()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        GeneratorState::Yielded(2) =&gt; {},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; panic!(&quot;error 2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match Generator::resume(Pin::new(&amp;mut gen), ()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // GeneratorState::Yielded(3) =&gt; {},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        GeneratorState::Complete(3) =&gt; {},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; panic!(&quot;error 3&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let state = Generator::resume(Pin::new(&amp;mut gen), ());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // println!(&quot;{:?}&quot;, state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 作为函数返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#![feature(generators, generator_trait)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::ops::Generator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn up_to(limit: u64) -&gt; impl Generator&lt;Yield = u64, Return = u64&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for x in 0..limit {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         yield x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return limit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut b = up_to(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for _ in 0..=10{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         let c = b.resume();   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         println!(&quot;{:?}&quot;, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//  和迭代器 的关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Generator&lt;Yield=T, Return=()&gt; - 如果只关注计算 的过程，而不关 心计 算的结果， 则可以 将 Return 设置为单元类型，只保留 Yield 的类型， 那 么生成器就可以化身为法代器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 生成器的性能比迭代器更高。因为生成器是一种延迟计算或惰性计算， 它避免了不必 要的计算，只有在每次需要时才通过 yield来产生相关的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#![feature(generators, generator_trait)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::{ops::{Generator, GeneratorState}, pin::Pin};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut gen = gen();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut state = Pin::new(&amp;mut gen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for _ in 0..3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match state.as_mut().resume(()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            GeneratorState::Yielded(i) =&gt; println!(&quot;{:?}&quot;, i),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; println!(&quot;complete&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn gen() -&gt; impl Generator&lt;Yield = u64, Return = ()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            yield i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 和 future关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Generator&lt;Yield = (), Return = Result&lt;T, E&gt;&gt; - 不关 心过 程 ， 只关注结果, 生成器就可以化身为 Future</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub fn up_to(limit: u64) -&gt; impl Generator&lt;Yield = (), Return = Result&lt;u64, ()&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for x in 0..limit {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            yield ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Ok(limit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let limit = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut gen = up_to(limit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for i in 0..=limit{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         match gen.resume() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             GeneratorState::Yielded(v) =&gt; println!(&quot;resume {:?} : Pending&quot;, i),// 表示还没处理完</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             GeneratorState::Complete(v) =&gt; println!(&quot;resume {:?} : Ready&quot;, i), // 处理完成, 拿到结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1232-future基本使用用">12.3.2. future基本使用用<a href="#1232-future基本使用用" class="hash-link" aria-label="Direct link to 12.3.2. future基本使用用" title="Direct link to 12.3.2. future基本使用用">​</a></h3><p>第三方库 futures-rs 提供</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 基本组件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Future  真实结果的包装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//      核心函数 poll(), 返回 计算结果是否准备好</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Executor 调度器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// - Task 具体的异步任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实现一个 Future trait的方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 方式1：使用 async fn，async fu 会自动为开发者生成返回值是 impl Future 类 型的函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 方式2：自定义 结构体，并实现 Future trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// async/await 原理: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// async 关键字定义异步函数/异步块，底层都会先转为 async 块的形式, 再将 async 块生成一个 Generator&lt;Yield=()&gt;类型的生成器来使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1233-动手实现-future-类型">12.3.3. 动手实现 Future 类型<a href="#1233-动手实现-future-类型" class="hash-link" aria-label="Direct link to 12.3.3. 动手实现 Future 类型" title="Direct link to 12.3.3. 动手实现 Future 类型">​</a></h3><p><a href="https://www.rectcircle.cn/posts/rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" target="_blank" rel="noopener noreferrer">https://www.rectcircle.cn/posts/rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1234-动手实现-异步-sleep">12.3.4. 动手实现 异步 sleep<a href="#1234-动手实现-异步-sleep" class="hash-link" aria-label="Direct link to 12.3.4. 动手实现 异步 sleep" title="Direct link to 12.3.4. 动手实现 异步 sleep">​</a></h3><p>通过自定义类型的方式实现一个异步的sleep, 类似于async_std::task:sleep</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use futures::executor::block_on;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::time::Duration;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use async_std::sync::Arc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::sync::Mutex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use futures::task::{Waker, Context, Poll};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use futures::Future;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::pin::Pin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::thread::{spawn, sleep};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block_on(async { // 异步代码块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;start&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TimerFuture::new(Duration::from_secs(2)).await;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;end&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct TimerFuture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct SharedState {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    completed: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    waker: Option&lt;Waker&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Future for TimerFuture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Output = ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#x27;_&gt;) -&gt; Poll&lt;Self::Output&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut shared_state = self.shared_state.lock().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if shared_state.completed {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Poll::Ready(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            shared_state.waker = Some(cx.waker().clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Poll::Pending</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl TimerFuture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new(du: Duration) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let shared_state = Arc::new(Mutex::new(SharedState {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            completed: false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            waker: None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let thread_shared_state = shared_state.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spawn(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sleep(du);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut state = thread_shared_state.lock().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            state.completed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if let Some(waker) = state.waker.take() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                waker.wake();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TimerFuture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            shared_state,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="124-async-std">12.4. async-std<a href="#124-async-std" class="hash-link" aria-label="Direct link to 12.4. async-std" title="Direct link to 12.4. async-std">​</a></h2><p>相较于 tokio, 年轻, 没有历史包袱, 兼容标准库, 更加小巧</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="125-tokio">12.5. tokio<a href="#125-tokio" class="hash-link" aria-label="Direct link to 12.5. tokio" title="Direct link to 12.5. tokio">​</a></h2><h1>13. 简单文件系统</h1><p><a href="https://zhuanlan.zhihu.com/p/115464045" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/115464045</a></p><h1>14. 网络编程</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="141-tcp">14.1. tcp<a href="#141-tcp" class="hash-link" aria-label="Direct link to 14.1. tcp" title="Direct link to 14.1. tcp">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::net::TcpListener;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::io::Read;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() -&gt; std::io::Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let listener = TcpListener::bind(&quot;127.0.0.1:1080&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for stream in listener.incoming() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match stream {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Ok(mut stream) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let mut buf = [0u8; 512];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let len = stream.read(&amp;mut buf)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;buf));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Err(_) =&gt; eprintln!(&quot;Error of accept request.&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() -&gt; std::io::Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut stream = TcpStream::connect(&quot;127.0.0.1:1080&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for index in 0..3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let msg = format!(&quot;tcp msg {}&quot;, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stream.write_all(msg.as_bytes());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        debug!(&quot;send: {}&quot;, msg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut buf = [0u8; 512];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stream.read(&amp;mut buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="142-udp">14.2. udp<a href="#142-udp" class="hash-link" aria-label="Direct link to 14.2. udp" title="Direct link to 14.2. udp">​</a></h2><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::net::UdpSocket;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() -&gt; std::io::Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let socket = UdpSocket::bind(&quot;127.0.0.1:1080&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut buf = [0u8; 512];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // receive from client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // len: data length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // src_addr: source address</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let (len, src_addr) = socket.recv_from(&amp;mut buf)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;recv: {}&quot;, String::from_utf8_lossy(&amp;buf));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let resp_buf = &amp;mut buf[..len];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resp_buf.reverse();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.send_to(resp_buf, src_addr)?;// send data to client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;send: {}&quot;, String::from_utf8_lossy(resp_buf));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() -&gt; std::io::Result&lt;()&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let socket = UdpSocket::bind(&quot;127.0.0.1:34254&quot;)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    socket.connect(&quot;127.0.0.1:8080&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for index in 0..3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let msg = format!(&quot;udp msg {}&quot;, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.send(msg.as_bytes());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;send: {}&quot;, msg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut buf = [0u8; 512];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        socket.recv(&amp;mut buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;recv: {}&quot;, String::from_utf8_lossy(&amp;buf));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>15. 消息中间件</h1><p><a href="https://github.com/nkbai/learnrustbynats" target="_blank" rel="noopener noreferrer">https://github.com/nkbai/learnrustbynats</a></p><p>TODO</p><h1>16. 游戏开发</h1><p><a href="https://www.yuque.com/quaint/rust/ldnc5g" target="_blank" rel="noopener noreferrer">https://www.yuque.com/quaint/rust/ldnc5g</a>
TODO</p><h1>17. 爬虫</h1><p>Hyper ：一个快速和正确的 Rust HTTP实现。 <a href="https://github.com/hyperium/hyper" target="_blank" rel="noopener noreferrer">https://github.com/hyperium/hyper</a>
reqwest : rust http client实现 <a href="https://github.com/seanmonstar/reqwest" target="_blank" rel="noopener noreferrer">https://github.com/seanmonstar/reqwest</a>
html5ever：Rust html解析库 <a href="https://github.com/servo/html5ever" target="_blank" rel="noopener noreferrer">https://github.com/servo/html5ever</a>
select :基于html5ever 的html解析库，类似于python的 beautifulsoap <a href="https://github.com/utkarshkukreti/select.rs" target="_blank" rel="noopener noreferrer">https://github.com/utkarshkukreti/select.rs</a>
crates.io <a href="https://crates.io/crates/select" target="_blank" rel="noopener noreferrer">https://crates.io/crates/select</a>
附：https：//github.com/carllerche/curl-rust</p><h1>18. rpc 框架</h1><p><a href="https://zhuanlan.zhihu.com/p/36528189" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/36528189</a></p><h1>19. 编写代理</h1><p><a href="https://github.com/gwuhaolin/blog/issues/12" target="_blank" rel="noopener noreferrer">https://github.com/gwuhaolin/blog/issues/12</a>
<a href="https://github.com/importcjj/rust-miniproxy" target="_blank" rel="noopener noreferrer">https://github.com/importcjj/rust-miniproxy</a>
<a href="https://github.com/wangyuntao/socks5-rs" target="_blank" rel="noopener noreferrer">https://github.com/wangyuntao/socks5-rs</a>
<a href="https://github.com/importcjj/gkd-rs" target="_blank" rel="noopener noreferrer">https://github.com/importcjj/gkd-rs</a></p><p><a href="https://zhuanlan.zhihu.com/p/28645724" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/28645724</a>
<a href="https://www.jianshu.com/p/d1048d0b687f" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/d1048d0b687f</a>
<a href="https://doc.rust-lang.org/std/net/" target="_blank" rel="noopener noreferrer">https://doc.rust-lang.org/std/net/</a>
<a href="https://zhuanlan.zhihu.com/p/97200083" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/97200083</a>
<a href="https://www.mojidong.com/post/2015-03-07-socket5-1/" target="_blank" rel="noopener noreferrer">https://www.mojidong.com/post/2015-03-07-socket5-1/</a>
<a href="https://www.zhihu.com/search?type=content&amp;q=rust%20socket" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/search?type=content&amp;q=rust%20socket</a></p><p>TODO</p><p><a href="https://lowlvl.org/" target="_blank" rel="noopener noreferrer">https://lowlvl.org/</a> 使用 rust 学习 tcp</p><p><a href="https://github.com/shadowsocks/shadowsocks-rust" target="_blank" rel="noopener noreferrer">https://github.com/shadowsocks/shadowsocks-rust</a>
<a href="https://github.com/trojan-gfw/trojan" target="_blank" rel="noopener noreferrer">https://github.com/trojan-gfw/trojan</a>
<a href="https://github.com/p4gefau1t/trojan-r" target="_blank" rel="noopener noreferrer">https://github.com/p4gefau1t/trojan-r</a>
<a href="https://github.com/importcjj/rust-miniproxy" target="_blank" rel="noopener noreferrer">https://github.com/importcjj/rust-miniproxy</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="191-http-代理">19.1. http 代理<a href="#191-http-代理" class="hash-link" aria-label="Direct link to 19.1. http 代理" title="Direct link to 19.1. http 代理">​</a></h2><p>http 代理: 基于 HTTP 协议. 属于应用层协议，一般只会代理转发 HTTP 请求，当然也可以使用 CONNECT 方法来实现一般 TCP 的代理转发
<a href="https://github.com/linmx0130/rust-http-proxy" target="_blank" rel="noopener noreferrer">https://github.com/linmx0130/rust-http-proxy</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="192-socket-代理">19.2. socket 代理<a href="#192-socket-代理" class="hash-link" aria-label="Direct link to 19.2. socket 代理" title="Direct link to 19.2. socket 代理">​</a></h2><p>Socket是一套标准，它完成了对TCP/IP的高度封装; Socket = IP地址 + 端口 + 协议。</p><p>socket5代理: socket5 是一个tcp、udp的代理协议(socket4不支持udp), 传输层代理协议, 它直接通过协议握手来进行连接，并直接修改报头来实现转发，所以速度非常快,大部分软件都支持socket5代理。</p><p><a href="https://github.com/importcjj" target="_blank" rel="noopener noreferrer">https://github.com/importcjj</a>
<a href="https://github.com/zhboner/realm" target="_blank" rel="noopener noreferrer">https://github.com/zhboner/realm</a> 流量转发
<a href="https://cloud.tencent.com/developer/article/1484318" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1484318</a>
<a href="https://github.com/gwuhaolin/blog/issues/12" target="_blank" rel="noopener noreferrer">https://github.com/gwuhaolin/blog/issues/12</a></p><h1>20. 开发微信小程序-web 游戏</h1><p><a href="https://github.com/planet0104" target="_blank" rel="noopener noreferrer">https://github.com/planet0104</a></p><h1>21. 第三方 crates</h1><p><a href="https://crates.io/" target="_blank" rel="noopener noreferrer">https://crates.io/</a>
<a href="https://s0docs0rs.icopy.site/" target="_blank" rel="noopener noreferrer">https://s0docs0rs.icopy.site/</a></p><p><a href="https://rust-lang-nursery.github.io/rust-cookbook/" target="_blank" rel="noopener noreferrer">https://rust-lang-nursery.github.io/rust-cookbook/</a></p><p><a href="https://github.com/crate-ci/typos" target="_blank" rel="noopener noreferrer">https://github.com/crate-ci/typos</a> 拼写检查</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="211-事实上的标准库">21.1. 事实上的标准库<a href="#211-事实上的标准库" class="hash-link" aria-label="Direct link to 21.1. 事实上的标准库" title="Direct link to 21.1. 事实上的标准库">​</a></h2><p>clap<br>
<!-- -->serde<br>
<!-- -->reqwest  http client<br>
<!-- -->hyper  快速HTTP实现   , 经常使用Actix而不是Hyper<br>
<!-- -->rayon 数据并行<br>
<!-- -->slog and log<br>
<!-- -->itertools<br>
<!-- -->PyO3  包装 rust lib 在 Python 中使用  (<a href="https://github.com/ijl/orjson" target="_blank" rel="noopener noreferrer">https://github.com/ijl/orjson</a>, <a href="https://github.com/mre/hyperjson" target="_blank" rel="noopener noreferrer">https://github.com/mre/hyperjson</a>)<br>
<!-- -->proptest 基于属性的测试库<br>
<!-- -->libloading 将Go或其他c-lib库混合到Rust前端<br>
<!-- -->regex   正则    </p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="212-markdown">21.2. markdown<a href="#212-markdown" class="hash-link" aria-label="Direct link to 21.2. markdown" title="Direct link to 21.2. markdown">​</a></h2><p><a href="https://github.com/raphlinus/pulldown-cmark" target="_blank" rel="noopener noreferrer">https://github.com/raphlinus/pulldown-cmark</a> 简单<br>
<a href="https://github.com/kivikakk/comrak" target="_blank" rel="noopener noreferrer">https://github.com/kivikakk/comrak</a> 复杂, 强大</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="213-桌面开发">21.3. 桌面开发<a href="#213-桌面开发" class="hash-link" aria-label="Direct link to 21.3. 桌面开发" title="Direct link to 21.3. 桌面开发">​</a></h2><p><a href="https://github.com/tauri-apps/tauri" target="_blank" rel="noopener noreferrer">https://github.com/tauri-apps/tauri</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="214-视频处理">21.4. 视频处理<a href="#214-视频处理" class="hash-link" aria-label="Direct link to 21.4. 视频处理" title="Direct link to 21.4. 视频处理">​</a></h2><p><a href="https://github.com/larksuite/rsmpeg" target="_blank" rel="noopener noreferrer">https://github.com/larksuite/rsmpeg</a> 飞书团队出品 ffmpeg 的 rust binding</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="215-图片处理">21.5. 图片处理<a href="#215-图片处理" class="hash-link" aria-label="Direct link to 21.5. 图片处理" title="Direct link to 21.5. 图片处理">​</a></h2><p><a href="https://github.com/Aloxaf/silicon" target="_blank" rel="noopener noreferrer">https://github.com/Aloxaf/silicon</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="216-游戏开发三方库">21.6. 游戏开发三方库<a href="#216-游戏开发三方库" class="hash-link" aria-label="Direct link to 21.6. 游戏开发三方库" title="Direct link to 21.6. 游戏开发三方库">​</a></h2><p><a href="https://github.com/rust-gamedev/arewegameyet" target="_blank" rel="noopener noreferrer">https://github.com/rust-gamedev/arewegameyet</a></p><p>bevy</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="217-系统信息">21.7. 系统信息<a href="#217-系统信息" class="hash-link" aria-label="Direct link to 21.7. 系统信息" title="Direct link to 21.7. 系统信息">​</a></h2><p><a href="https://github.com/GuillaumeGomez/sysinfo" target="_blank" rel="noopener noreferrer">https://github.com/GuillaumeGomez/sysinfo</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="218-web-开发发">21.8. web 开发发<a href="#218-web-开发发" class="hash-link" aria-label="Direct link to 21.8. web 开发发" title="Direct link to 21.8. web 开发发">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2181-swagger-openapi-生成">21.8.1. swagger openapi 生成<a href="#2181-swagger-openapi-生成" class="hash-link" aria-label="Direct link to 21.8.1. swagger openapi 生成" title="Direct link to 21.8.1. swagger openapi 生成">​</a></h3><p><a href="https://github.com/GREsau/okapi" target="_blank" rel="noopener noreferrer">https://github.com/GREsau/okapi</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2182-web框架">21.8.2. web框架<a href="#2182-web框架" class="hash-link" aria-label="Direct link to 21.8.2. web框架" title="Direct link to 21.8.2. web框架">​</a></h3><p><a href="https://hardocs.com/d/rustprimer/quickstart/quickstart.html" target="_blank" rel="noopener noreferrer">https://hardocs.com/d/rustprimer/quickstart/quickstart.html</a></p><p><a href="https://www.arewewebyet.org/" target="_blank" rel="noopener noreferrer">https://www.arewewebyet.org/</a></p><p>rocket <a href="https://rocket.rs/" target="_blank" rel="noopener noreferrer">https://rocket.rs/</a></p><p><a href="https://github.com/actix/actix-web" target="_blank" rel="noopener noreferrer">https://github.com/actix/actix-web</a></p><p>tiny_http</p><p>warp</p><p><a href="https://github.com/yewstack/yew" target="_blank" rel="noopener noreferrer">https://github.com/yewstack/yew</a> 使用 jsx 语法写 wasm</p><p>对比选型 <a href="http://jiagoushi.pro/book/export/html/334" target="_blank" rel="noopener noreferrer">http://jiagoushi.pro/book/export/html/334</a></p><p>Zola 静态网站</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2183-orm">21.8.3. orm<a href="#2183-orm" class="hash-link" aria-label="Direct link to 21.8.3. orm" title="Direct link to 21.8.3. orm">​</a></h3><p>Diesel ORM</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2184-http-client">21.8.4. http client<a href="#2184-http-client" class="hash-link" aria-label="Direct link to 21.8.4. http client" title="Direct link to 21.8.4. http client">​</a></h3><p>http - HTTP标准相关的基础类型，如<code>Request&lt;T&gt; 、Response&lt;T&gt;</code>以及StatusCode和常用的Header</p><p>hyper -  HTTP底层库，它封装了HTTP的报文解析、报文编码处理、连接控制</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="219-序列化反序列化">21.9. 序列化反序列化<a href="#219-序列化反序列化" class="hash-link" aria-label="Direct link to 21.9. 序列化反序列化" title="Direct link to 21.9. 序列化反序列化">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2191-toml">21.9.1. toml<a href="#2191-toml" class="hash-link" aria-label="Direct link to 21.9.1. toml" title="Direct link to 21.9.1. toml">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::env::args;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let config = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let config_path = args().nth(1).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let content = std::fs::read_to_string(config_path).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content.parse::&lt;toml::Value&gt;().unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:#?}&quot;, config);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let tbl = config.as_table().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let input = config.get(&quot;input&quot;).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:#?}&quot;, input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let json_file = input.get(&quot;json_file&quot;).unwrap().as_str().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:#?}&quot;, json_file);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2192-json">21.9.2. json<a href="#2192-json" class="hash-link" aria-label="Direct link to 21.9.2. json" title="Direct link to 21.9.2. json">​</a></h3><p>serde_json 是基于 serde 实现的</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2110-读写数据">21.10. 读写数据<a href="#2110-读写数据" class="hash-link" aria-label="Direct link to 21.10. 读写数据" title="Direct link to 21.10. 读写数据">​</a></h2><p>bytes</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2111-增强工具">21.11. 增强工具<a href="#2111-增强工具" class="hash-link" aria-label="Direct link to 21.11. 增强工具" title="Direct link to 21.11. 增强工具">​</a></h2><p>itertools</p><p>time</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2112-授权-authorization">21.12. 授权 Authorization<a href="#2112-授权-authorization" class="hash-link" aria-label="Direct link to 21.12. 授权 Authorization" title="Direct link to 21.12. 授权 Authorization">​</a></h2><p>oso</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2113-日志系统">21.13. 日志系统<a href="#2113-日志系统" class="hash-link" aria-label="Direct link to 21.13. 日志系统" title="Direct link to 21.13. 日志系统">​</a></h2><p>日志 <a href="https://segmentfault.com/a/1190000021681959" target="_blank" rel="noopener noreferrer">https://segmentfault.com/a/1190000021681959</a></p><p>log 提供 api, 如果只是开发一个 lib , 无需导入实现, 如果是在一个可执行程序里, 必须有实现才能打印</p><p>具体实现有多种</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="21131-tracing">21.13.1. tracing<a href="#21131-tracing" class="hash-link" aria-label="Direct link to 21.13.1. tracing" title="Direct link to 21.13.1. tracing">​</a></h3><p>日志 追踪</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="21132-env_logger">21.13.2. env_logger<a href="#21132-env_logger" class="hash-link" aria-label="Direct link to 21.13.2. env_logger" title="Direct link to 21.13.2. env_logger">​</a></h3><p><code>RUST_LOG=info ./bin_file</code></p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[macro_use]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extern crate log;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    env_logger::init();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    debug!(&quot;debug&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    info!(&quot;info&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    warn!(&quot;warn&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trace!(&quot;trace&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    error!(&quot;error&quot;); // default</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="21133-log4rs-and-log">21.13.3. log4rs and log<a href="#21133-log4rs-and-log" class="hash-link" aria-label="Direct link to 21.13.3. log4rs and log" title="Direct link to 21.13.3. log4rs and log">​</a></h3><div class="language-t codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-t codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[dependencies]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">log = &quot;0.4.11&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">log4rs = &quot;0.13.0&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>log4rs.yml</p><div class="language-yml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yml codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">refresh_rate</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 30 seconds</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">appenders</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">stdout</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">kind</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> console</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">requests</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">kind</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">path</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;log/requests.log&quot;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic"># 相对于项目根目录</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">encoder</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">pattern</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;{d} - {m}{n}&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">root</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">level</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">appenders</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> stdout</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> requests</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#loggers:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#  app::backend::db:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#    level: info</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#  app::requests:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#    level: info</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#    appenders:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#      - requests</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#    additive: false</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let log_file = &quot;config/log4rs.yml&quot;; // 相对于 项目根目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log4rs::init_file(log_file, Default::default()).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    debug!(&quot;&gt;&gt;&gt; load log config file: {}&quot;, log_file);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let listener = TcpListener::bind(&quot;127.0.0.1:8090&quot;).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    info!(&quot;visit ==&gt; http://127.0.0.1:8090&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2114-文本解析器-parser">21.14. 文本解析器 parser<a href="#2114-文本解析器-parser" class="hash-link" aria-label="Direct link to 21.14. 文本解析器 parser" title="Direct link to 21.14. 文本解析器 parser">​</a></h2><p><a href="https://github.com/Geal/nom" target="_blank" rel="noopener noreferrer">https://github.com/Geal/nom</a>
<a href="https://zhuanlan.zhihu.com/p/115017849" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/115017849</a></p><p>pest</p><p>pom</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2115-lazy-static-延迟初始化">21.15. lazy static 延迟初始化<a href="#2115-lazy-static-延迟初始化" class="hash-link" aria-label="Direct link to 21.15. lazy static 延迟初始化" title="Direct link to 21.15. lazy static 延迟初始化">​</a></h2><p>可以把定义全局静态变量延迟到运行时，而非编译时</p><p>在运行时初始化静态变量, 即静态变量延迟初始化</p><p>例如, 某些静态变量由命令行参数决定, 得等到运行时才能确定静态变量</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::collections::HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use lazy_static::lazy_static;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// #[macro_use]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// extern crate lazy_static;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lazy_static! {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static ref HASH_MAP: HashMap&lt;u32, &amp;&#x27;static str&gt; = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut m = HashMap::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m.insert(1, &quot;hello&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m.insert(2, &quot;world&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;hash map init&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, HASH_MAP.get(&amp;1).unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, HASH_MAP.get(&amp;2).unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2116-电子书">21.16. 电子书<a href="#2116-电子书" class="hash-link" aria-label="Direct link to 21.16. 电子书" title="Direct link to 21.16. 电子书">​</a></h2><p>mdBook 生成电子书</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2117-命令行程序">21.17. 命令行程序<a href="#2117-命令行程序" class="hash-link" aria-label="Direct link to 21.17. 命令行程序" title="Direct link to 21.17. 命令行程序">​</a></h2><p>indicatif 进度条</p><p>clap 命令行参数解析</p><p>借助第三方解析库:</p><p><a href="https://rust-cli.github.io/book/tutorial/cli-args.html" target="_blank" rel="noopener noreferrer">https://rust-cli.github.io/book/tutorial/cli-args.html</a>
<a href="http://llever.com/cli-wg-zh/tutorial/cli-args.zh.html" target="_blank" rel="noopener noreferrer">http://llever.com/cli-wg-zh/tutorial/cli-args.zh.html</a></p><p><a href="https://github.com/rust-cli" target="_blank" rel="noopener noreferrer">https://github.com/rust-cli</a></p><p>ansi_term 彩色输出</p><p><a href="https://github.com/fdehau/tui-rs" target="_blank" rel="noopener noreferrer">https://github.com/fdehau/tui-rs</a></p><p><a href="https://github.com/cjbassi/ytop" target="_blank" rel="noopener noreferrer">https://github.com/cjbassi/ytop</a> 命令行系统监控程序</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="21171-structopt">21.17.1. structopt<a href="#21171-structopt" class="hash-link" aria-label="Direct link to 21.17.1. structopt" title="Direct link to 21.17.1. structopt">​</a></h3><p>整合 clap, 将参数直接解析为 struct, 更加方便 </p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::path::PathBuf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use structopt::StructOpt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(StructOpt, Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[structopt(name = &quot;basic&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Opt {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 不指定 short long, 会使用 field name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[structopt(short = &quot;v&quot;, long)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    verbose: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[structopt(short = &quot;r&quot;, long = &quot;result&quot;, parse(from_os_str))]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result: PathBuf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #[structopt(parse(from_os_str))]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    files: Vec&lt;PathBuf&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // result this cmd: cargo run input.txt input2.txt -v --result res.xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let opt = Opt::from_args();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{:#?}&quot;, opt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="21172-clap">21.17.2. clap<a href="#21172-clap" class="hash-link" aria-label="Direct link to 21.17.2. clap" title="Direct link to 21.17.2. clap">​</a></h3><p>功能强大, 使用不够简单</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2118-异步编程">21.18. 异步编程<a href="#2118-异步编程" class="hash-link" aria-label="Direct link to 21.18. 异步编程" title="Direct link to 21.18. 异步编程">​</a></h2><p>tokio</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2119-websocket">21.19. websocket<a href="#2119-websocket" class="hash-link" aria-label="Direct link to 21.19. websocket" title="Direct link to 21.19. websocket">​</a></h2><p><a href="https://github.com/websockets-rs/rust-websocket" target="_blank" rel="noopener noreferrer">https://github.com/websockets-rs/rust-websocket</a></p><p>wsl 中可能 build 失败, 如下解决:</p><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">apt install -y openssl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">apt install -y libssl-dev</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">apt install -y pkg-config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2120-缩小体积">21.20. 缩小体积<a href="#2120-缩小体积" class="hash-link" aria-label="Direct link to 21.20. 缩小体积" title="Direct link to 21.20. 缩小体积">​</a></h2><p>cargo-bloat</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2121-http-client">21.21. http client<a href="#2121-http-client" class="hash-link" aria-label="Direct link to 21.21. http client" title="Direct link to 21.21. http client">​</a></h2><p>chttp</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2122-容错运行时">21.22. 容错运行时<a href="#2122-容错运行时" class="hash-link" aria-label="Direct link to 21.22. 容错运行时" title="Direct link to 21.22. 容错运行时">​</a></h2><p>bastion</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2123-监控">21.23. 监控<a href="#2123-监控" class="hash-link" aria-label="Direct link to 21.23. 监控" title="Direct link to 21.23. 监控">​</a></h2><p>sentry 错误监控</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2124-电子邮件">21.24. 电子邮件<a href="#2124-电子邮件" class="hash-link" aria-label="Direct link to 21.24. 电子邮件" title="Direct link to 21.24. 电子邮件">​</a></h2><p>tera</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2125-分发工具">21.25. 分发工具<a href="#2125-分发工具" class="hash-link" aria-label="Direct link to 21.25. 分发工具" title="Direct link to 21.25. 分发工具">​</a></h2><p>Cargo-release</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2126-并发编程">21.26. 并发编程<a href="#2126-并发编程" class="hash-link" aria-label="Direct link to 21.26. 并发编程" title="Direct link to 21.26. 并发编程">​</a></h2><p><a href="https://github.com/crossbeam-rs/crossbeam" target="_blank" rel="noopener noreferrer">https://github.com/crossbeam-rs/crossbeam</a></p><p>Rayon 并行流</p><p>dashmap</p><p>parking_lot</p><p>crossbeam</p><p>flume</p><p>rsRust</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2127-gui-图形库">21.27. gui 图形库<a href="#2127-gui-图形库" class="hash-link" aria-label="Direct link to 21.27. gui 图形库" title="Direct link to 21.27. gui 图形库">​</a></h2><p><a href="https://github.com/PistonDevelopers/conrod" target="_blank" rel="noopener noreferrer">https://github.com/PistonDevelopers/conrod</a> 2d</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2128-底层网络-api">21.28. 底层网络 api<a href="#2128-底层网络-api" class="hash-link" aria-label="Direct link to 21.28. 底层网络 api" title="Direct link to 21.28. 底层网络 api">​</a></h2><p>libpnet, 如 <code>pnet = &quot;0.25.0&quot;</code></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2129-正则">21.29. 正则<a href="#2129-正则" class="hash-link" aria-label="Direct link to 21.29. 正则" title="Direct link to 21.29. 正则">​</a></h2><ul><li>regex 官方实现, 不支持环视 ( look-around ) 和 反向引用 ( backreference)</li><li>fancy-regex , 支持 支持环视 ( look-around ) 和 反向引用 ( backreference)</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2130-随机">21.30. 随机<a href="#2130-随机" class="hash-link" aria-label="Direct link to 21.30. 随机" title="Direct link to 21.30. 随机">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="21301-rand-随机数字">21.30.1. rand 随机数字<a href="#21301-rand-随机数字" class="hash-link" aria-label="Direct link to 21.30.1. rand 随机数字" title="Direct link to 21.30.1. rand 随机数字">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use rand::prelude::*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut rng = rand::thread_rng();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let i = rng.gen_range(0..3); // 0/1/2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // let s: &amp;str = rng.gen();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let boo = rng.gen::&lt;bool&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;bool true from gen() : {}&quot;, boo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let rate = rng.gen_ratio(1, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if rng.gen_bool(1.0 / 2.0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;percent of true&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if rng.gen() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;bool from gen() without turbofish&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if rand::random() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;rand bool from random()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2131-搜索引擎">21.31. 搜索引擎<a href="#2131-搜索引擎" class="hash-link" aria-label="Direct link to 21.31. 搜索引擎" title="Direct link to 21.31. 搜索引擎">​</a></h2><p><a href="https://github.com/valeriansaliou/sonic" target="_blank" rel="noopener noreferrer">https://github.com/valeriansaliou/sonic</a>
<a href="https://github.com/tantivy-search/tantivy" target="_blank" rel="noopener noreferrer">https://github.com/tantivy-search/tantivy</a>
<a href="https://artem.krylysov.com/blog/2020/07/28/lets-build-a-full-text-search-engine/" target="_blank" rel="noopener noreferrer">https://artem.krylysov.com/blog/2020/07/28/lets-build-a-full-text-search-engine/</a> 实现原理</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2132-开源集合容器">21.32. 开源集合容器<a href="#2132-开源集合容器" class="hash-link" aria-label="Direct link to 21.32. 开源集合容器" title="Direct link to 21.32. 开源集合容器">​</a></h2><p><a href="https://github.com/jonhoo/flurry" target="_blank" rel="noopener noreferrer">https://github.com/jonhoo/flurry</a>  A port of Java&#x27;s ConcurrentHashMap to Rust</p><h1>22. 开源项目</h1><p><a href="https://zhuanlan.zhihu.com/p/62325234" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/62325234</a>
<a href="https://zhuanlan.zhihu.com/p/139180791" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/139180791</a>
<a href="https://www.zhihu.com/question/30511494" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/30511494</a></p><h1>23. 参考链接</h1><p>libp2p<br>
<!-- -->是用于构建P2P网络的模块化网络堆栈和库，源自开源项目IPFS，模块化设计使它能够用来构建各种去中心化应用的P2P网络层。目前，知名区块链项目Ethereum 2.0、Pokdot、BitXHub都选择基于Libp2p库搭建系统网络层。</p><p><a href="https://github.com/WumaCoder/rust-boom" target="_blank" rel="noopener noreferrer">https://github.com/WumaCoder/rust-boom</a></p><p><a href="https://github.com/rustlang-cn/rusty-book" target="_blank" rel="noopener noreferrer">https://github.com/rustlang-cn/rusty-book</a> 开源库</p><p><a href="https://github.com/search?q=algorithm+language%3ARust&amp;type=Repositories&amp;ref=advsearch&amp;l=Rust&amp;l=" target="_blank" rel="noopener noreferrer">https://github.com/search?q=algorithm+language%3ARust&amp;type=Repositories&amp;ref=advsearch&amp;l=Rust&amp;l=</a> 算法</p><p><a href="https://github.com/rust-unofficial/patterns" target="_blank" rel="noopener noreferrer">https://github.com/rust-unofficial/patterns</a> 规范</p><p><a href="https://github.com/lapce/lapce" target="_blank" rel="noopener noreferrer">https://github.com/lapce/lapce</a> 编辑器, ui</p><p><a href="https://github.com/develon2015/dnsd" target="_blank" rel="noopener noreferrer">https://github.com/develon2015/dnsd</a>
<a href="https://github.com/develon2015/remote_bind" target="_blank" rel="noopener noreferrer">https://github.com/develon2015/remote_bind</a>
<a href="https://github.com/ppbl/scicode" target="_blank" rel="noopener noreferrer">https://github.com/ppbl/scicode</a> yew+actix</p><p><a href="https://jasonkayzk.github.io/2022/02/20/%E4%BD%BF%E7%94%A8Rust%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" target="_blank" rel="noopener noreferrer">https://jasonkayzk.github.io/2022/02/20/%E4%BD%BF%E7%94%A8Rust%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</a> 双向链表</p><p><a href="https://github.com/bitlabx/cherry" target="_blank" rel="noopener noreferrer">https://github.com/bitlabx/cherry</a> orm</p><p><a href="https://github.com/mini-lust/tutorials" target="_blank" rel="noopener noreferrer">https://github.com/mini-lust/tutorials</a> 手把手动手实现 rpc</p><p><a href="https://rust-cli.github.io/book/index.html" target="_blank" rel="noopener noreferrer">https://rust-cli.github.io/book/index.html</a> 命令行</p><p><a href="https://github.com/wisespace-io/binance-rs" target="_blank" rel="noopener noreferrer">https://github.com/wisespace-io/binance-rs</a></p><p><a href="https://www.youtube.com/watch?v=qyRIkcdRfRg&amp;t=974s" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=qyRIkcdRfRg&amp;t=974s</a> 企业级开发最佳实践
<a href="https://www.youtube.com/watch?v=36_TiWriqQ4" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=36_TiWriqQ4</a> rust and webasembly</p><p><a href="https://course.rs/about-book.html" target="_blank" rel="noopener noreferrer">https://course.rs/about-book.html</a></p><p><a href="https://github.com/sunface/rust-course" target="_blank" rel="noopener noreferrer">https://github.com/sunface/rust-course</a></p><p><a href="https://books.budshome.com/" target="_blank" rel="noopener noreferrer">https://books.budshome.com/</a></p><p><a href="https://github.com/sunface/rust-course" target="_blank" rel="noopener noreferrer">https://github.com/sunface/rust-course</a></p><p><a href="https://github.com/0voice/Understanding_in_Rust" target="_blank" rel="noopener noreferrer">https://github.com/0voice/Understanding_in_Rust</a></p><p><a href="https://github.com/KernelErr/awesome-rust-zh" target="_blank" rel="noopener noreferrer">https://github.com/KernelErr/awesome-rust-zh</a>
<a href="https://github.com/studyrs/fancy-rust" target="_blank" rel="noopener noreferrer">https://github.com/studyrs/fancy-rust</a>
<a href="https://github.com/TaKO8Ki/awesome-alternatives-in-rust" target="_blank" rel="noopener noreferrer">https://github.com/TaKO8Ki/awesome-alternatives-in-rust</a></p><p><a href="https://github.com/pingcap/talent-plan" target="_blank" rel="noopener noreferrer">https://github.com/pingcap/talent-plan</a> 课程</p><p><a href="https://github.com/meilisearch/MeiliSearch" target="_blank" rel="noopener noreferrer">https://github.com/meilisearch/MeiliSearch</a> 搜索引擎, 类似 algolia, 不过是开源的</p><p><a href="https://docs.rs/" target="_blank" rel="noopener noreferrer">https://docs.rs/</a>  cates api 文档
<a href="https://crates.io/" target="_blank" rel="noopener noreferrer">https://crates.io/</a> crates 搜索</p><p><a href="https://github.com/pretzelhammer/rust-blog" target="_blank" rel="noopener noreferrer">https://github.com/pretzelhammer/rust-blog</a></p><p><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials" target="_blank" rel="noopener noreferrer">https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials</a> 在树莓派上实现操作系统</p><p><a href="https://github.com/mre/idiomatic-rust" target="_blank" rel="noopener noreferrer">https://github.com/mre/idiomatic-rust</a> 最佳实践
<a href="https://github.com/ctjhoa/rust-learning" target="_blank" rel="noopener noreferrer">https://github.com/ctjhoa/rust-learning</a></p><p><a href="https://github.com/sassman/t-rec-rs" target="_blank" rel="noopener noreferrer">https://github.com/sassman/t-rec-rs</a> 终端记录工具 录制 gif</p><p><a href="https://github.com/wtklbm/crm" target="_blank" rel="noopener noreferrer">https://github.com/wtklbm/crm</a> 简单项目 镜像源切换</p><p><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials" target="_blank" rel="noopener noreferrer">https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials</a> 嵌入式 os 内核 开发</p><p><a href="https://folyd.com/blog/" target="_blank" rel="noopener noreferrer">https://folyd.com/blog/</a> Rust的Pin与Unpin</p><p><a href="https://github.com/ajmwagar" target="_blank" rel="noopener noreferrer">https://github.com/ajmwagar</a> rust 小项目
<a href="https://github.com/kilerd" target="_blank" rel="noopener noreferrer">https://github.com/kilerd</a>
<a href="https://github.com/ramsayleung" target="_blank" rel="noopener noreferrer">https://github.com/ramsayleung</a></p><p><a href="https://github.com/warycat/rustgym" target="_blank" rel="noopener noreferrer">https://github.com/warycat/rustgym</a> 算法
<a href="https://github.com/aylei/leetcode-rust" target="_blank" rel="noopener noreferrer">https://github.com/aylei/leetcode-rust</a> 算法实现
<a href="https://github.com/sunface/rust-algos" target="_blank" rel="noopener noreferrer">https://github.com/sunface/rust-algos</a>
<a href="https://github.com/dxx/datastructure-algorithm" target="_blank" rel="noopener noreferrer">https://github.com/dxx/datastructure-algorithm</a></p><p><a href="https://github.com/rust-unofficial/awesome-rust" target="_blank" rel="noopener noreferrer">https://github.com/rust-unofficial/awesome-rust</a>
<a href="https://github.com/rust-lang-nursery/rust-cookbook" target="_blank" rel="noopener noreferrer">https://github.com/rust-lang-nursery/rust-cookbook</a></p><p><a href="https://play.integer32.com/" target="_blank" rel="noopener noreferrer">https://play.integer32.com/</a>
<a href="https://play.rust-lang.org/" target="_blank" rel="noopener noreferrer">https://play.rust-lang.org/</a></p><p><a href="https://rust-unofficial.github.io/patterns/" target="_blank" rel="noopener noreferrer">https://rust-unofficial.github.io/patterns/</a> 设计模式</p><p><a href="https://www.rust-lang.org/" target="_blank" rel="noopener noreferrer">https://www.rust-lang.org/</a> 官方站</p><p><a href="https://www.zhihu.com/question/31038569" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/31038569</a> 如何学</p><p><a href="https://users.rust-lang.org/" target="_blank" rel="noopener noreferrer">https://users.rust-lang.org/</a> 社区
<a href="https://rustcc.cn/" target="_blank" rel="noopener noreferrer">https://rustcc.cn/</a> 中文社区</p><p><a href="https://doc.rust-lang.org/std/" target="_blank" rel="noopener noreferrer">https://doc.rust-lang.org/std/</a> std api</p><p><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" target="_blank" rel="noopener noreferrer">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a> the book 手册
<a href="https://kaisery.github.io/trpl-zh-cn/title-page.html" target="_blank" rel="noopener noreferrer">https://kaisery.github.io/trpl-zh-cn/title-page.html</a> the book 翻译
<a href="https://course.rs/into-rust.html" target="_blank" rel="noopener noreferrer">https://course.rs/into-rust.html</a>
<a href="https://rust-by-example.budshome.com/" target="_blank" rel="noopener noreferrer">https://rust-by-example.budshome.com/</a></p><p><a href="https://github.com/rust-lang/nomicon" target="_blank" rel="noopener noreferrer">https://github.com/rust-lang/nomicon</a> 死灵书 设计原理</p><p><a href="https://doc.rust-lang.org/stable/reference/introduction.html" target="_blank" rel="noopener noreferrer">https://doc.rust-lang.org/stable/reference/introduction.html</a></p><p><a href="https://doc.rust-lang.org/stable/rust-by-example/macros/dsl.html" target="_blank" rel="noopener noreferrer">https://doc.rust-lang.org/stable/rust-by-example/macros/dsl.html</a> example
<a href="https://books.budshome.com/rust-by-example/testing/unit_testing.html" target="_blank" rel="noopener noreferrer">https://books.budshome.com/rust-by-example/testing/unit_testing.html</a> 中文</p><p><a href="https://rust-unofficial.github.io/too-many-lists/" target="_blank" rel="noopener noreferrer">https://rust-unofficial.github.io/too-many-lists/</a> another tutorial
<a href="https://github.com/rust-unofficial/too-many-lists" target="_blank" rel="noopener noreferrer">https://github.com/rust-unofficial/too-many-lists</a></p><p><a href="https://cheats.rs/#data-structures" target="_blank" rel="noopener noreferrer">https://cheats.rs/#data-structures</a> 速查表 cheatsheet</p><p><a href="https://doc.rust-lang.org/cargo/index.html" target="_blank" rel="noopener noreferrer">https://doc.rust-lang.org/cargo/index.html</a> cargo book
<a href="https://cargo.budshome.com/index.html" target="_blank" rel="noopener noreferrer">https://cargo.budshome.com/index.html</a></p><p><a href="https://github.com/chinanf-boy?tab=stars" target="_blank" rel="noopener noreferrer">https://github.com/chinanf-boy?tab=stars</a> - 爱好者
<a href="https://github.com/AurevoirXavier" target="_blank" rel="noopener noreferrer">https://github.com/AurevoirXavier</a> - 爱好者
<a href="https://github.com/BurntSushi" target="_blank" rel="noopener noreferrer">https://github.com/BurntSushi</a> - master
<a href="https://github.com/mre" target="_blank" rel="noopener noreferrer">https://github.com/mre</a> master
<a href="https://github.com/rust-lang" target="_blank" rel="noopener noreferrer">https://github.com/rust-lang</a> 官方GitHub</p><p><a href="http://intorust.com/" target="_blank" rel="noopener noreferrer">http://intorust.com/</a> 动画介绍</p><p><a href="https://zhuanlan.zhihu.com/c_208092758/" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/c_208092758/</a> 知乎专栏
<a href="https://zhuanlan.zhihu.com/c_118514498" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/c_118514498</a></p><p><a href="https://github.com/phil-opp/blog_os" target="_blank" rel="noopener noreferrer">https://github.com/phil-opp/blog_os</a> rust 实现os</p><p><a href="https://github.com/Kilerd/resource" target="_blank" rel="noopener noreferrer">https://github.com/Kilerd/resource</a> - 中文资料收集
<a href="https://zhuanlan.zhihu.com/rust-lang" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/rust-lang</a>
<a href="https://wiki.jikexueyuan.com/project/rust-primer/concurrency-parallel-thread/thread.html" target="_blank" rel="noopener noreferrer">https://wiki.jikexueyuan.com/project/rust-primer/concurrency-parallel-thread/thread.html</a></p><p><a href="https://www.zhihu.com/question/382172347/answer/1103525234" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/382172347/answer/1103525234</a> tips
<a href="https://www.zhihu.com/question/393796866/answer/1213171124" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/393796866/answer/1213171124</a></p><p><a href="https://www.zhihu.com/question/30407715/answer/48032883" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/30407715/answer/48032883</a></p><p><a href="https://www.zhihu.com/question/34665842?sort=created" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/34665842?sort=created</a> 练手
<a href="https://www.zhihu.com/question/352420716/answer/973279231" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/352420716/answer/973279231</a></p><p><a href="https://www.zhihu.com/question/30511494/answer/649921526" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/30511494/answer/649921526</a> 值得关注</p><p><a href="https://github.com/rajasekarv/vega" target="_blank" rel="noopener noreferrer">https://github.com/rajasekarv/vega</a> spark 替代</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/en/docs/tags/rust">rust</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/xiaoyureed/xiaoyureed.github.io/tree/main/docs/rust-note.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/en/docs/regex"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Regular Expression 正则🌈</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/en/docs/saas-paas-iaas-as-a-service"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">SaaS Intro</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#11-感悟" class="table-of-contents__link toc-highlight">1.1. 感悟</a></li><li><a href="#12-架构" class="table-of-contents__link toc-highlight">1.2. 架构</a></li><li><a href="#13-优点-对比" class="table-of-contents__link toc-highlight">1.3. 优点 对比</a></li><li><a href="#14-思想" class="table-of-contents__link toc-highlight">1.4. 思想</a></li><li><a href="#15-语义-概念" class="table-of-contents__link toc-highlight">1.5. 语义 概念</a></li><li><a href="#21-install" class="table-of-contents__link toc-highlight">2.1. install</a></li><li><a href="#22-命令行工具使用" class="table-of-contents__link toc-highlight">2.2. 命令行工具使用</a></li><li><a href="#23-ide" class="table-of-contents__link toc-highlight">2.3. IDE</a></li><li><a href="#24-配置国内镜像" class="table-of-contents__link toc-highlight">2.4. 配置国内镜像</a></li><li><a href="#31-path-路径" class="table-of-contents__link toc-highlight">3.1. path 路径</a></li><li><a href="#32-时间" class="table-of-contents__link toc-highlight">3.2. 时间</a></li><li><a href="#41-nll" class="table-of-contents__link toc-highlight">4.1. nll</a></li><li><a href="#42-raw-identifier" class="table-of-contents__link toc-highlight">4.2. Raw identifier</a></li><li><a href="#43-简化模式匹配" class="table-of-contents__link toc-highlight">4.3. 简化模式匹配</a></li><li><a href="#44-main-函数可以返回-result" class="table-of-contents__link toc-highlight">4.4. main 函数可以返回 Result</a></li><li><a href="#45-impl-trait-抽象类型" class="table-of-contents__link toc-highlight">4.5. impl trait 抽象类型</a></li><li><a href="#51-注释" class="table-of-contents__link toc-highlight">5.1. 注释</a></li><li><a href="#52-变量赋值" class="table-of-contents__link toc-highlight">5.2. 变量赋值</a><ul><li><a href="#521-默认是不可变的" class="table-of-contents__link toc-highlight">5.2.1. 默认是不可变的</a></li><li><a href="#522-字面量" class="table-of-contents__link toc-highlight">5.2.2. 字面量</a></li></ul></li><li><a href="#53-基本数据类型" class="table-of-contents__link toc-highlight">5.3. 基本数据类型</a><ul><li><a href="#531-convert" class="table-of-contents__link toc-highlight">5.3.1. convert</a></li><li><a href="#532-值类型-and-引用类型" class="table-of-contents__link toc-highlight">5.3.2. 值类型 and 引用类型</a></li><li><a href="#533-常量-静态变量" class="table-of-contents__link toc-highlight">5.3.3. 常量 静态变量</a></li><li><a href="#534-数字" class="table-of-contents__link toc-highlight">5.3.4. 数字</a></li><li><a href="#535-布尔值-字符-字节" class="table-of-contents__link toc-highlight">5.3.5. 布尔值 字符 字节</a></li><li><a href="#536-数组" class="table-of-contents__link toc-highlight">5.3.6. 数组</a></li><li><a href="#537-range-范围" class="table-of-contents__link toc-highlight">5.3.7. Range 范围</a></li><li><a href="#538-切片" class="table-of-contents__link toc-highlight">5.3.8. 切片</a></li><li><a href="#539-str-字符串切片" class="table-of-contents__link toc-highlight">5.3.9. str 字符串切片</a></li><li><a href="#5310-原生指针-raw-pointer" class="table-of-contents__link toc-highlight">5.3.10. 原生指针 raw pointer</a></li><li><a href="#5311-never-类型-感叹号" class="table-of-contents__link toc-highlight">5.3.11. never 类型 感叹号</a></li></ul></li><li><a href="#54-字符串" class="table-of-contents__link toc-highlight">5.4. 字符串</a><ul><li><a href="#541-几种字符串区别" class="table-of-contents__link toc-highlight">5.4.1. 几种字符串区别</a></li><li><a href="#542-常用方法" class="table-of-contents__link toc-highlight">5.4.2. 常用方法</a></li><li><a href="#543-字符串转换" class="table-of-contents__link toc-highlight">5.4.3. 字符串转换</a></li><li><a href="#544-格式化" class="table-of-contents__link toc-highlight">5.4.4. 格式化</a></li><li><a href="#545-调试打印复合类型-debug-display" class="table-of-contents__link toc-highlight">5.4.5. 调试打印复合类型 Debug Display</a></li><li><a href="#546-问号操作符-多次写" class="table-of-contents__link toc-highlight">5.4.6. 问号操作符 多次写</a></li></ul></li><li><a href="#55-集合" class="table-of-contents__link toc-highlight">5.5. 集合</a><ul><li><a href="#551-vec-动态数组" class="table-of-contents__link toc-highlight">5.5.1. Vec 动态数组</a></li><li><a href="#552-双端队列-vecdeque" class="table-of-contents__link toc-highlight">5.5.2. 双端队列 VecDeque</a></li><li><a href="#553-链表-linkedlist" class="table-of-contents__link toc-highlight">5.5.3. 链表 Linkedlist</a></li><li><a href="#554-hashmap-无序哈希表" class="table-of-contents__link toc-highlight">5.5.4. hashmap 无序哈希表</a><ul><li><a href="#5541-哈希表基本使用" class="table-of-contents__link toc-highlight">5.5.4.1. 哈希表基本使用</a></li><li><a href="#5542-复合类型作为-key" class="table-of-contents__link toc-highlight">5.5.4.2. 复合类型作为 key</a></li><li><a href="#5543-哈希碰撞攻击" class="table-of-contents__link toc-highlight">5.5.4.3. 哈希碰撞攻击</a></li></ul></li><li><a href="#555-btreemap-有序哈希表" class="table-of-contents__link toc-highlight">5.5.5. BTreeMap 有序哈希表</a></li><li><a href="#556-hashset-无序集合" class="table-of-contents__link toc-highlight">5.5.6. hashset 无序集合</a></li><li><a href="#557-btreeset-有序集合" class="table-of-contents__link toc-highlight">5.5.7. BTreeSet 有序集合</a></li><li><a href="#558-优先队列-binaryheap" class="table-of-contents__link toc-highlight">5.5.8. 优先队列 BinaryHeap</a></li></ul></li><li><a href="#56-类型转换" class="table-of-contents__link toc-highlight">5.6. 类型转换</a><ul><li><a href="#561-基本的类型转换" class="table-of-contents__link toc-highlight">5.6.1. 基本的类型转换</a></li><li><a href="#562-转换相关的-trait" class="table-of-contents__link toc-highlight">5.6.2. 转换相关的 trait</a></li></ul></li><li><a href="#57-所有权" class="table-of-contents__link toc-highlight">5.7. 所有权</a><ul><li><a href="#571-为什么需要所有权-raii机制" class="table-of-contents__link toc-highlight">5.7.1. 为什么需要所有权 RAII机制</a></li><li><a href="#572-基本原则" class="table-of-contents__link toc-highlight">5.7.2. 基本原则</a></li><li><a href="#573-字符串赋值的所有权" class="table-of-contents__link toc-highlight">5.7.3. 字符串赋值的所有权</a></li><li><a href="#574-函数参数的所有权" class="table-of-contents__link toc-highlight">5.7.4. 函数参数的所有权</a></li><li><a href="#575-函数返回值所有权" class="table-of-contents__link toc-highlight">5.7.5. 函数返回值所有权</a></li><li><a href="#576-复合类型中的所有权" class="table-of-contents__link toc-highlight">5.7.6. 复合类型中的所有权</a></li><li><a href="#577-多所有权" class="table-of-contents__link toc-highlight">5.7.7. 多所有权</a></li></ul></li><li><a href="#58-生命周期参数" class="table-of-contents__link toc-highlight">5.8. 生命周期参数</a><ul><li><a href="#581-什么是生命周期" class="table-of-contents__link toc-highlight">5.8.1. 什么是生命周期</a></li><li><a href="#582-为什么存在生命周期注释" class="table-of-contents__link toc-highlight">5.8.2. 为什么存在生命周期注释</a></li><li><a href="#583-函数中的生命周期参数" class="table-of-contents__link toc-highlight">5.8.3. 函数中的生命周期参数</a></li><li><a href="#584-结构体中生命周期-省略的规则" class="table-of-contents__link toc-highlight">5.8.4. 结构体中生命周期 省略的规则</a></li><li><a href="#585-静态生命周期注释" class="table-of-contents__link toc-highlight">5.8.5. 静态生命周期注释</a></li><li><a href="#586-生命周期约束" class="table-of-contents__link toc-highlight">5.8.6. 生命周期约束</a></li></ul></li><li><a href="#59-引用" class="table-of-contents__link toc-highlight">5.9. 引用</a><ul><li><a href="#591-引用基本介绍" class="table-of-contents__link toc-highlight">5.9.1. 引用基本介绍</a></li><li><a href="#592-不可变引用" class="table-of-contents__link toc-highlight">5.9.2. 不可变引用</a></li><li><a href="#593-可变引用" class="table-of-contents__link toc-highlight">5.9.3. 可变引用</a></li><li><a href="#594-垂悬引用问题dangling-references" class="table-of-contents__link toc-highlight">5.9.4. 垂悬引用问题（Dangling References)</a></li></ul></li><li><a href="#510-裸指针" class="table-of-contents__link toc-highlight">5.10. 裸指针</a></li><li><a href="#511-智能指针" class="table-of-contents__link toc-highlight">5.11. 智能指针</a><ul><li><a href="#5111-智能指针介绍-工作机制" class="table-of-contents__link toc-highlight">5.11.1. 智能指针介绍 工作机制</a></li><li><a href="#5112-raii机制-实现内存回收" class="table-of-contents__link toc-highlight">5.11.2. RAII机制 实现内存回收</a></li><li><a href="#5113-自定义智能指针-自动解引用-deref-和-drop" class="table-of-contents__link toc-highlight">5.11.3. 自定义智能指针 自动解引用 Deref 和 Drop</a></li><li><a href="#5114-box-无痛使用堆内存" class="table-of-contents__link toc-highlight">5.11.4. Box 无痛使用堆内存</a><ul><li><a href="#51141-box基本使用" class="table-of-contents__link toc-highlight">5.11.4.1. Box基本使用</a></li><li><a href="#51142-包装动态大小类型-dst" class="table-of-contents__link toc-highlight">5.11.4.2. 包装动态大小类型 DST</a></li></ul></li><li><a href="#5115-rc-和-weak-共享堆内存" class="table-of-contents__link toc-highlight">5.11.5. Rc 和 Weak 共享堆内存</a><ul><li><a href="#51151-rc-强引用" class="table-of-contents__link toc-highlight">5.11.5.1. Rc 强引用</a></li><li><a href="#51152-构造链表" class="table-of-contents__link toc-highlight">5.11.5.2. 构造链表</a></li><li><a href="#51153-weak-弱引用" class="table-of-contents__link toc-highlight">5.11.5.3. Weak 弱引用</a></li></ul></li><li><a href="#5116-refcell-和-cell-提供内部可变性" class="table-of-contents__link toc-highlight">5.11.6. RefCell 和 Cell 提供内部可变性</a><ul><li><a href="#51161-cell" class="table-of-contents__link toc-highlight">5.11.6.1. Cell</a></li><li><a href="#51162-refcell" class="table-of-contents__link toc-highlight">5.11.6.2. RefCell</a></li></ul></li><li><a href="#5117-rc-box-refcell-cell-几种指针的区别对比-组合使用" class="table-of-contents__link toc-highlight">5.11.7. Rc Box RefCell Cell 几种指针的区别对比 组合使用</a></li><li><a href="#5118-pin-和-unpin" class="table-of-contents__link toc-highlight">5.11.8. Pin 和 Unpin</a></li><li><a href="#5119-cow-写时复制" class="table-of-contents__link toc-highlight">5.11.9. Cow 写时复制</a></li></ul></li><li><a href="#512-函数" class="table-of-contents__link toc-highlight">5.12. 函数</a><ul><li><a href="#5121-函数基本语法" class="table-of-contents__link toc-highlight">5.12.1. 函数基本语法</a></li><li><a href="#5122-函数体表达式" class="table-of-contents__link toc-highlight">5.12.2. 函数体表达式</a></li><li><a href="#5123-函数作为参数" class="table-of-contents__link toc-highlight">5.12.3. 函数作为参数</a></li><li><a href="#5124-result-返回值" class="table-of-contents__link toc-highlight">5.12.4. Result 返回值</a></li><li><a href="#5125-编译期函数执行-cfe" class="table-of-contents__link toc-highlight">5.12.5. 编译期函数执行 cfe</a></li><li><a href="#5126-发散函数" class="table-of-contents__link toc-highlight">5.12.6. 发散函数</a></li><li><a href="#5127-泛型函数" class="table-of-contents__link toc-highlight">5.12.7. 泛型函数</a></li><li><a href="#5128-高阶函数" class="table-of-contents__link toc-highlight">5.12.8. 高阶函数</a><ul><li><a href="#51281-函数指针" class="table-of-contents__link toc-highlight">5.12.8.1. 函数指针</a></li><li><a href="#51282-禁止函数捕获外部环境中变量" class="table-of-contents__link toc-highlight">5.12.8.2. 禁止函数捕获外部环境中变量</a></li></ul></li></ul></li><li><a href="#513-闭包" class="table-of-contents__link toc-highlight">5.13. 闭包</a><ul><li><a href="#5131-闭包基本使用" class="table-of-contents__link toc-highlight">5.13.1. 闭包基本使用</a></li><li><a href="#5132-rust-实现闭包的原理" class="table-of-contents__link toc-highlight">5.13.2. rust 实现闭包的原理</a></li><li><a href="#5133-捕获环境变量-and-三种闭包类型" class="table-of-contents__link toc-highlight">5.13.3. 捕获环境变量 and 三种闭包类型</a></li><li><a href="#5134-闭包作为返回值-or-参数" class="table-of-contents__link toc-highlight">5.13.4. 闭包作为返回值 or 参数</a><ul><li><a href="#51341-逃逸闭包-非逃逸闭包" class="table-of-contents__link toc-highlight">5.13.4.1. 逃逸闭包 非逃逸闭包</a></li><li><a href="#51342-闭包作为参数" class="table-of-contents__link toc-highlight">5.13.4.2. 闭包作为参数</a></li><li><a href="#51343-闭包作为返回值" class="table-of-contents__link toc-highlight">5.13.4.3. 闭包作为返回值</a></li><li><a href="#51344-闭包参数中的生命周期" class="table-of-contents__link toc-highlight">5.13.4.4. 闭包参数中的生命周期</a></li></ul></li><li><a href="#5135-迭代器" class="table-of-contents__link toc-highlight">5.13.5. 迭代器</a><ul><li><a href="#51351-什么是迭代器" class="table-of-contents__link toc-highlight">5.13.5.1. 什么是迭代器</a></li><li><a href="#51352-iterator-trait" class="table-of-contents__link toc-highlight">5.13.5.2. Iterator trait</a></li><li><a href="#51353-迭代器适配器-收集器-函数式风格" class="table-of-contents__link toc-highlight">5.13.5.3. 迭代器适配器 收集器 函数式风格</a></li><li><a href="#51354-自定义迭代器" class="table-of-contents__link toc-highlight">5.13.5.4. 自定义迭代器</a></li><li><a href="#51355-自定义适配器-收集器" class="table-of-contents__link toc-highlight">5.13.5.5. 自定义适配器 收集器</a></li></ul></li></ul></li><li><a href="#514-条件循环" class="table-of-contents__link toc-highlight">5.14. 条件循环</a></li><li><a href="#515-泛型" class="table-of-contents__link toc-highlight">5.15. 泛型</a><ul><li><a href="#5151-单态化" class="table-of-contents__link toc-highlight">5.15.1. 单态化</a></li><li><a href="#5152-多重约束-加号" class="table-of-contents__link toc-highlight">5.15.2. 多重约束 加号</a></li><li><a href="#5153-默认泛型参数-and-关联类型" class="table-of-contents__link toc-highlight">5.15.3. 默认泛型参数 and 关联类型</a></li><li><a href="#5154-空约束" class="table-of-contents__link toc-highlight">5.15.4. 空约束</a></li><li><a href="#5155-turbofish-操作符-and-返回值自动推导" class="table-of-contents__link toc-highlight">5.15.5. turbofish 操作符 and 返回值自动推导</a></li></ul></li><li><a href="#516-trait" class="table-of-contents__link toc-highlight">5.16. trait</a><ul><li><a href="#5161-trait-概念" class="table-of-contents__link toc-highlight">5.16.1. trait 概念</a><ul><li><a href="#51611-trait-基本使用" class="table-of-contents__link toc-highlight">5.16.1.1. trait 基本使用</a></li><li><a href="#51612-孤儿规则-通过fundamental规避" class="table-of-contents__link toc-highlight">5.16.1.2. 孤儿规则 通过fundamental规避</a></li><li><a href="#51613-特化-specialization" class="table-of-contents__link toc-highlight">5.16.1.3. 特化 Specialization</a></li><li><a href="#51614-trait-作为参数-需要-impl-前缀" class="table-of-contents__link toc-highlight">5.16.1.4. trait 作为参数 需要 impl 前缀</a></li><li><a href="#51615-trait-作为-返回值-返回动态类型" class="table-of-contents__link toc-highlight">5.16.1.5. trait 作为 返回值 返回动态类型</a></li><li><a href="#51616-trait-继承" class="table-of-contents__link toc-highlight">5.16.1.6. trait 继承</a></li><li><a href="#51617-静态分发-动态分发" class="table-of-contents__link toc-highlight">5.16.1.7. 静态分发 动态分发</a></li><li><a href="#51618-使用抽象类型" class="table-of-contents__link toc-highlight">5.16.1.8. 使用抽象类型</a><ul><li><a href="#516181-trait对象" class="table-of-contents__link toc-highlight">5.16.1.8.1. trait对象</a></li><li><a href="#516182-trait对象安全问题-sized-trait" class="table-of-contents__link toc-highlight">5.16.1.8.2. trait对象安全问题 Sized trait</a></li><li><a href="#516183-impl-trait" class="table-of-contents__link toc-highlight">5.16.1.8.3. impl trait</a></li></ul></li><li><a href="#51619-trait的类型转换" class="table-of-contents__link toc-highlight">5.16.1.9. trait的类型转换</a></li></ul></li><li><a href="#5162-可自动推导的trait" class="table-of-contents__link toc-highlight">5.16.2. 可自动推导的trait</a></li><li><a href="#5163-运算符重载相关的trait" class="table-of-contents__link toc-highlight">5.16.3. 运算符重载相关的trait</a></li><li><a href="#5164-from-和-into" class="table-of-contents__link toc-highlight">5.16.4. From 和 Into</a></li><li><a href="#5165-derefmut-和-deref" class="table-of-contents__link toc-highlight">5.16.5. DerefMut 和 Deref</a></li><li><a href="#5166-asref-asmut" class="table-of-contents__link toc-highlight">5.16.6. AsRef AsMut</a></li><li><a href="#5167-borrow-trait" class="table-of-contents__link toc-highlight">5.16.7. Borrow trait</a></li><li><a href="#5168-drop-资源释放" class="table-of-contents__link toc-highlight">5.16.8. Drop 资源释放</a></li><li><a href="#5169-标签-trait" class="table-of-contents__link toc-highlight">5.16.9. 标签 trait</a><ul><li><a href="#51691-send-和-sync" class="table-of-contents__link toc-highlight">5.16.9.1. Send 和 Sync</a></li><li><a href="#51692-copy-trait" class="table-of-contents__link toc-highlight">5.16.9.2. Copy trait</a></li><li><a href="#51693-sized-trait--和-动态类型dst" class="table-of-contents__link toc-highlight">5.16.9.3. Sized trait  和 动态类型DST</a></li></ul></li><li><a href="#51610-default-trait" class="table-of-contents__link toc-highlight">5.16.10. Default trait</a></li><li><a href="#51611-extend-trait" class="table-of-contents__link toc-highlight">5.16.11. Extend trait</a></li><li><a href="#51612-any-trait" class="table-of-contents__link toc-highlight">5.16.12. Any trait</a></li><li><a href="#51613-和比较排序相关的trait" class="table-of-contents__link toc-highlight">5.16.13. 和比较排序相关的trait</a></li></ul></li><li><a href="#517-元组" class="table-of-contents__link toc-highlight">5.17. 元组</a></li><li><a href="#518-结构体" class="table-of-contents__link toc-highlight">5.18. 结构体</a><ul><li><a href="#5181-结构体基本使用" class="table-of-contents__link toc-highlight">5.18.1. 结构体基本使用</a></li><li><a href="#5182-元组结构体-and-单元结构体" class="table-of-contents__link toc-highlight">5.18.2. 元组结构体 and 单元结构体</a></li><li><a href="#5183-结构体方法" class="table-of-contents__link toc-highlight">5.18.3. 结构体方法</a></li><li><a href="#5184-new-type-模式-和-类型别名-self别名" class="table-of-contents__link toc-highlight">5.18.4. new type 模式 和 类型别名 Self别名</a></li><li><a href="#5185-案例-彩色命令行输出" class="table-of-contents__link toc-highlight">5.18.5. 案例 彩色命令行输出</a></li></ul></li><li><a href="#519-枚举" class="table-of-contents__link toc-highlight">5.19. 枚举</a><ul><li><a href="#5191-枚举基本使用" class="table-of-contents__link toc-highlight">5.19.1. 枚举基本使用</a></li><li><a href="#5192-option" class="table-of-contents__link toc-highlight">5.19.2. Option</a></li><li><a href="#5193-c-风格的枚举" class="table-of-contents__link toc-highlight">5.19.3. c 风格的枚举</a></li><li><a href="#5194-案例-彩色命令行输出优化" class="table-of-contents__link toc-highlight">5.19.4. 案例 彩色命令行输出优化</a></li><li><a href="#5195-实例-创建链表" class="table-of-contents__link toc-highlight">5.19.5. 实例 创建链表</a></li></ul></li><li><a href="#520-match-模式匹配" class="table-of-contents__link toc-highlight">5.20. match 模式匹配</a><ul><li><a href="#5201-模式匹配简单使用" class="table-of-contents__link toc-highlight">5.20.1. 模式匹配简单使用</a></li><li><a href="#5202-if-lef-while-let-语法糖" class="table-of-contents__link toc-highlight">5.20.2. if lef while let 语法糖</a></li></ul></li><li><a href="#521-错误处理" class="table-of-contents__link toc-highlight">5.21. 错误处理</a><ul><li><a href="#5211-断言" class="table-of-contents__link toc-highlight">5.21.1. 断言</a></li><li><a href="#5212-panic-和-abort" class="table-of-contents__link toc-highlight">5.21.2. panic 和 Abort</a></li><li><a href="#5213-result--和-问号操作符" class="table-of-contents__link toc-highlight">5.21.3. Result  和 问号操作符</a></li><li><a href="#5214-错误装箱-自定义异常" class="table-of-contents__link toc-highlight">5.21.4. 错误装箱 自定义异常</a></li><li><a href="#5215-捕获异常" class="table-of-contents__link toc-highlight">5.21.5. 捕获异常</a></li><li><a href="#5216-错误处理进化过程" class="table-of-contents__link toc-highlight">5.21.6. 错误处理进化过程</a></li><li><a href="#5217-第三方库处理异常" class="table-of-contents__link toc-highlight">5.21.7. 第三方库处理异常</a></li></ul></li><li><a href="#522-io" class="table-of-contents__link toc-highlight">5.22. io</a><ul><li><a href="#5221-命令行参数" class="table-of-contents__link toc-highlight">5.22.1. 命令行参数</a></li><li><a href="#5222-文件-io" class="table-of-contents__link toc-highlight">5.22.2. 文件 io</a></li></ul></li><li><a href="#523-面向对象-oop" class="table-of-contents__link toc-highlight">5.23. 面向对象 oop</a><ul><li><a href="#5231-可见性" class="table-of-contents__link toc-highlight">5.23.1. 可见性</a></li><li><a href="#5232-多态" class="table-of-contents__link toc-highlight">5.23.2. 多态</a></li><li><a href="#5233-向下转型" class="table-of-contents__link toc-highlight">5.23.3. 向下转型</a></li><li><a href="#5234-各种self区分使用" class="table-of-contents__link toc-highlight">5.23.4. 各种self区分使用</a></li><li><a href="#5235-设计模式" class="table-of-contents__link toc-highlight">5.23.5. 设计模式</a><ul><li><a href="#52351-建造者模式" class="table-of-contents__link toc-highlight">5.23.5.1. 建造者模式</a></li><li><a href="#52352-访问者模式" class="table-of-contents__link toc-highlight">5.23.5.2. 访问者模式</a></li><li><a href="#52353-raii模式" class="table-of-contents__link toc-highlight">5.23.5.3. raii模式</a></li></ul></li></ul></li><li><a href="#524-子进程" class="table-of-contents__link toc-highlight">5.24. 子进程</a></li><li><a href="#525-反射" class="table-of-contents__link toc-highlight">5.25. 反射</a></li><li><a href="#526-宏" class="table-of-contents__link toc-highlight">5.26. 宏</a><ul><li><a href="#5261-宏基本介绍" class="table-of-contents__link toc-highlight">5.26.1. 宏基本介绍</a></li><li><a href="#5262-声明宏" class="table-of-contents__link toc-highlight">5.26.2. 声明宏</a><ul><li><a href="#52621-创建宏" class="table-of-contents__link toc-highlight">5.26.2.1. 创建宏</a></li><li><a href="#52622-重复循环匹配" class="table-of-contents__link toc-highlight">5.26.2.2. 重复循环匹配</a></li><li><a href="#52623-实际案例" class="table-of-contents__link toc-highlight">5.26.2.3. 实际案例</a></li></ul></li><li><a href="#5263-宏调试" class="table-of-contents__link toc-highlight">5.26.3. 宏调试</a></li><li><a href="#5264-过程宏" class="table-of-contents__link toc-highlight">5.26.4. 过程宏</a><ul><li><a href="#52641-过程宏基本使用规则" class="table-of-contents__link toc-highlight">5.26.4.1. 过程宏基本使用规则</a></li><li><a href="#52642-自定义属性宏" class="table-of-contents__link toc-highlight">5.26.4.2. 自定义属性宏</a></li><li><a href="#52643-函数调用宏" class="table-of-contents__link toc-highlight">5.26.4.3. 函数调用宏</a></li><li><a href="#52644-derive-宏" class="table-of-contents__link toc-highlight">5.26.4.4. derive 宏</a></li></ul></li><li><a href="#5265-使用第三方包" class="table-of-contents__link toc-highlight">5.26.5. 使用第三方包</a></li><li><a href="#5266-编译器插件" class="table-of-contents__link toc-highlight">5.26.6. 编译器插件</a></li></ul></li><li><a href="#61-unsafe-基本场景" class="table-of-contents__link toc-highlight">6.1. unsafe 基本场景</a></li><li><a href="#62-交叉编译" class="table-of-contents__link toc-highlight">6.2. 交叉编译</a></li><li><a href="#63-ffi-外部函数接口" class="table-of-contents__link toc-highlight">6.3. ffi 外部函数接口</a><ul><li><a href="#631-ffi-基本介绍" class="table-of-contents__link toc-highlight">6.3.1. ffi 基本介绍</a></li><li><a href="#632-和-elixir-交互" class="table-of-contents__link toc-highlight">6.3.2. 和 elixir 交互</a></li><li><a href="#633-和c-cpp-交互" class="table-of-contents__link toc-highlight">6.3.3. 和c cpp 交互</a><ul><li><a href="#6331-在-rust-中调用-c-函数" class="table-of-contents__link toc-highlight">6.3.3.1. 在 rust 中调用 C 函数</a></li><li><a href="#6332-在-rust调用-cpp" class="table-of-contents__link toc-highlight">6.3.3.2. 在 rust调用 cpp</a></li><li><a href="#6333-在-c-中调用-rust" class="table-of-contents__link toc-highlight">6.3.3.3. 在 c 中调用 rust</a></li></ul></li><li><a href="#634-和-python-交互" class="table-of-contents__link toc-highlight">6.3.4. 和 Python 交互</a></li><li><a href="#635-和-swift" class="table-of-contents__link toc-highlight">6.3.5. 和 Swift</a></li><li><a href="#636-和-js-javascript-nodejs-交互" class="table-of-contents__link toc-highlight">6.3.6. 和 js JavaScript nodejs 交互</a></li><li><a href="#637-和-java-交互" class="table-of-contents__link toc-highlight">6.3.7. 和 java 交互</a><ul><li><a href="#6371-java-调用-rust" class="table-of-contents__link toc-highlight">6.3.7.1. java 调用 rust</a></li><li><a href="#6372-rust-调用-java" class="table-of-contents__link toc-highlight">6.3.7.2. rust 调用 java</a></li></ul></li></ul></li><li><a href="#71-堆-和-栈" class="table-of-contents__link toc-highlight">7.1. 堆 和 栈</a></li><li><a href="#72-内存对齐" class="table-of-contents__link toc-highlight">7.2. 内存对齐</a></li><li><a href="#73-手动堆内存分配" class="table-of-contents__link toc-highlight">7.3. 手动堆内存分配</a></li><li><a href="#81-概念简单解释" class="table-of-contents__link toc-highlight">8.1. 概念简单解释</a></li><li><a href="#82-可见性管理" class="table-of-contents__link toc-highlight">8.2. 可见性管理</a></li><li><a href="#83-编译器版本管理" class="table-of-contents__link toc-highlight">8.3. 编译器版本管理</a></li><li><a href="#84-为项目单独指定config-配置" class="table-of-contents__link toc-highlight">8.4. 为项目单独指定config 配置</a></li><li><a href="#85-依赖管理-cargo" class="table-of-contents__link toc-highlight">8.5. 依赖管理 cargo</a><ul><li><a href="#851-cargo-基本命令" class="table-of-contents__link toc-highlight">8.5.1. cargo 基本命令</a></li><li><a href="#852-文件布局结构" class="table-of-contents__link toc-highlight">8.5.2. 文件布局结构</a></li><li><a href="#853-cargotoml" class="table-of-contents__link toc-highlight">8.5.3. Cargo.toml</a></li><li><a href="#854-cargolock" class="table-of-contents__link toc-highlight">8.5.4. cargo.lock</a></li><li><a href="#855-workspace" class="table-of-contents__link toc-highlight">8.5.5. workspace</a></li><li><a href="#856-依赖的版本号规则" class="table-of-contents__link toc-highlight">8.5.6. 依赖的版本号规则</a></li></ul></li><li><a href="#86-buildrs" class="table-of-contents__link toc-highlight">8.6. build.rs</a></li><li><a href="#87-项目管理案例" class="table-of-contents__link toc-highlight">8.7. 项目管理案例</a><ul><li><a href="#871-导出自定义宏" class="table-of-contents__link toc-highlight">8.7.1. 导出自定义宏</a></li><li><a href="#872-导入自定义-crate" class="table-of-contents__link toc-highlight">8.7.2. 导入自定义 crate</a></li><li><a href="#873-执行子目录中的-module" class="table-of-contents__link toc-highlight">8.7.3. 执行子目录中的 module</a></li><li><a href="#874-导入自定义-module" class="table-of-contents__link toc-highlight">8.7.4. 导入自定义 module</a></li><li><a href="#875-导入第三方-crate" class="table-of-contents__link toc-highlight">8.7.5. 导入第三方 crate</a></li></ul></li><li><a href="#111-通用概念" class="table-of-contents__link toc-highlight">11.1. 通用概念</a><ul><li><a href="#1111-进程-and-线程" class="table-of-contents__link toc-highlight">11.1.1. 进程 and 线程</a></li><li><a href="#1112-事件回调实现的异步并发" class="table-of-contents__link toc-highlight">11.1.2. 事件回调实现的异步并发</a></li></ul></li><li><a href="#112-线程基本使用" class="table-of-contents__link toc-highlight">11.2. 线程基本使用</a><ul><li><a href="#1121-创建线程" class="table-of-contents__link toc-highlight">11.2.1. 创建线程</a></li><li><a href="#1122-自定义配置线程" class="table-of-contents__link toc-highlight">11.2.2. 自定义配置线程</a></li><li><a href="#1123-线程本地变量" class="table-of-contents__link toc-highlight">11.2.3. 线程本地变量</a></li><li><a href="#1124-手动阻塞唤醒" class="table-of-contents__link toc-highlight">11.2.4. 手动阻塞唤醒</a></li></ul></li><li><a href="#113-线程同步" class="table-of-contents__link toc-highlight">11.3. 线程同步</a><ul><li><a href="#1131-错误示例" class="table-of-contents__link toc-highlight">11.3.1. 错误示例</a></li><li><a href="#1132-锁" class="table-of-contents__link toc-highlight">11.3.2. 锁</a></li><li><a href="#1133-原子类型" class="table-of-contents__link toc-highlight">11.3.3. 原子类型</a></li><li><a href="#1134-channel" class="table-of-contents__link toc-highlight">11.3.4. channel</a></li><li><a href="#1135-tokio-中的各种-channel-实现" class="table-of-contents__link toc-highlight">11.3.5. tokio 中的各种 channel 实现</a></li></ul></li><li><a href="#114-多线程小例子" class="table-of-contents__link toc-highlight">11.4. 多线程小例子</a><ul><li><a href="#1141-实现线程池" class="table-of-contents__link toc-highlight">11.4.1. 实现线程池</a></li><li><a href="#1142-实现-map-reduce-算法" class="table-of-contents__link toc-highlight">11.4.2. 实现 map-reduce 算法</a></li><li><a href="#1143-多线程统计和" class="table-of-contents__link toc-highlight">11.4.3. 多线程统计和</a></li><li><a href="#1144-带线程池的-webserver" class="table-of-contents__link toc-highlight">11.4.4. 带线程池的 webserver</a></li></ul></li><li><a href="#115-rayon-并行执行任务" class="table-of-contents__link toc-highlight">11.5. rayon 并行执行任务</a></li><li><a href="#116-crossbeam-无锁的数据结构" class="table-of-contents__link toc-highlight">11.6. CrossBeam 无锁的数据结构</a></li><li><a href="#117-rwlock-和-refcell" class="table-of-contents__link toc-highlight">11.7. RwLock 和 RefCell</a></li><li><a href="#118-mutex" class="table-of-contents__link toc-highlight">11.8. Mutex</a></li><li><a href="#119-atomicptr-和-cell" class="table-of-contents__link toc-highlight">11.9. AtomicPtr 和 Cell</a></li><li><a href="#1110-send-和-sync-trait" class="table-of-contents__link toc-highlight">11.10. Send 和 Sync trait</a></li><li><a href="#121-异步概念" class="table-of-contents__link toc-highlight">12.1. 异步概念</a><ul><li><a href="#1211-为什么使用异步" class="table-of-contents__link toc-highlight">12.1.1. 为什么使用异步</a></li><li><a href="#1212-普通多线程-webserver" class="table-of-contents__link toc-highlight">12.1.2. 普通多线程 webserver</a></li><li><a href="#1213-改进后的异步版本" class="table-of-contents__link toc-highlight">12.1.3. 改进后的异步版本</a></li></ul></li><li><a href="#122-基本使用" class="table-of-contents__link toc-highlight">12.2. 基本使用</a><ul><li><a href="#1221-block_on" class="table-of-contents__link toc-highlight">12.2.1. block_on</a></li><li><a href="#1222-await" class="table-of-contents__link toc-highlight">12.2.2. await</a></li><li><a href="#1223-joinn" class="table-of-contents__link toc-highlight">12.2.3. joinn</a></li></ul></li><li><a href="#123-future并发模式" class="table-of-contents__link toc-highlight">12.3. future并发模式</a><ul><li><a href="#1231-future底层是生成器" class="table-of-contents__link toc-highlight">12.3.1. future底层是生成器</a></li><li><a href="#1232-future基本使用用" class="table-of-contents__link toc-highlight">12.3.2. future基本使用用</a></li><li><a href="#1233-动手实现-future-类型" class="table-of-contents__link toc-highlight">12.3.3. 动手实现 Future 类型</a></li><li><a href="#1234-动手实现-异步-sleep" class="table-of-contents__link toc-highlight">12.3.4. 动手实现 异步 sleep</a></li></ul></li><li><a href="#124-async-std" class="table-of-contents__link toc-highlight">12.4. async-std</a></li><li><a href="#125-tokio" class="table-of-contents__link toc-highlight">12.5. tokio</a></li><li><a href="#141-tcp" class="table-of-contents__link toc-highlight">14.1. tcp</a></li><li><a href="#142-udp" class="table-of-contents__link toc-highlight">14.2. udp</a></li><li><a href="#191-http-代理" class="table-of-contents__link toc-highlight">19.1. http 代理</a></li><li><a href="#192-socket-代理" class="table-of-contents__link toc-highlight">19.2. socket 代理</a></li><li><a href="#211-事实上的标准库" class="table-of-contents__link toc-highlight">21.1. 事实上的标准库</a></li><li><a href="#212-markdown" class="table-of-contents__link toc-highlight">21.2. markdown</a></li><li><a href="#213-桌面开发" class="table-of-contents__link toc-highlight">21.3. 桌面开发</a></li><li><a href="#214-视频处理" class="table-of-contents__link toc-highlight">21.4. 视频处理</a></li><li><a href="#215-图片处理" class="table-of-contents__link toc-highlight">21.5. 图片处理</a></li><li><a href="#216-游戏开发三方库" class="table-of-contents__link toc-highlight">21.6. 游戏开发三方库</a></li><li><a href="#217-系统信息" class="table-of-contents__link toc-highlight">21.7. 系统信息</a></li><li><a href="#218-web-开发发" class="table-of-contents__link toc-highlight">21.8. web 开发发</a><ul><li><a href="#2181-swagger-openapi-生成" class="table-of-contents__link toc-highlight">21.8.1. swagger openapi 生成</a></li><li><a href="#2182-web框架" class="table-of-contents__link toc-highlight">21.8.2. web框架</a></li><li><a href="#2183-orm" class="table-of-contents__link toc-highlight">21.8.3. orm</a></li><li><a href="#2184-http-client" class="table-of-contents__link toc-highlight">21.8.4. http client</a></li></ul></li><li><a href="#219-序列化反序列化" class="table-of-contents__link toc-highlight">21.9. 序列化反序列化</a><ul><li><a href="#2191-toml" class="table-of-contents__link toc-highlight">21.9.1. toml</a></li><li><a href="#2192-json" class="table-of-contents__link toc-highlight">21.9.2. json</a></li></ul></li><li><a href="#2110-读写数据" class="table-of-contents__link toc-highlight">21.10. 读写数据</a></li><li><a href="#2111-增强工具" class="table-of-contents__link toc-highlight">21.11. 增强工具</a></li><li><a href="#2112-授权-authorization" class="table-of-contents__link toc-highlight">21.12. 授权 Authorization</a></li><li><a href="#2113-日志系统" class="table-of-contents__link toc-highlight">21.13. 日志系统</a><ul><li><a href="#21131-tracing" class="table-of-contents__link toc-highlight">21.13.1. tracing</a></li><li><a href="#21132-env_logger" class="table-of-contents__link toc-highlight">21.13.2. env_logger</a></li><li><a href="#21133-log4rs-and-log" class="table-of-contents__link toc-highlight">21.13.3. log4rs and log</a></li></ul></li><li><a href="#2114-文本解析器-parser" class="table-of-contents__link toc-highlight">21.14. 文本解析器 parser</a></li><li><a href="#2115-lazy-static-延迟初始化" class="table-of-contents__link toc-highlight">21.15. lazy static 延迟初始化</a></li><li><a href="#2116-电子书" class="table-of-contents__link toc-highlight">21.16. 电子书</a></li><li><a href="#2117-命令行程序" class="table-of-contents__link toc-highlight">21.17. 命令行程序</a><ul><li><a href="#21171-structopt" class="table-of-contents__link toc-highlight">21.17.1. structopt</a></li><li><a href="#21172-clap" class="table-of-contents__link toc-highlight">21.17.2. clap</a></li></ul></li><li><a href="#2118-异步编程" class="table-of-contents__link toc-highlight">21.18. 异步编程</a></li><li><a href="#2119-websocket" class="table-of-contents__link toc-highlight">21.19. websocket</a></li><li><a href="#2120-缩小体积" class="table-of-contents__link toc-highlight">21.20. 缩小体积</a></li><li><a href="#2121-http-client" class="table-of-contents__link toc-highlight">21.21. http client</a></li><li><a href="#2122-容错运行时" class="table-of-contents__link toc-highlight">21.22. 容错运行时</a></li><li><a href="#2123-监控" class="table-of-contents__link toc-highlight">21.23. 监控</a></li><li><a href="#2124-电子邮件" class="table-of-contents__link toc-highlight">21.24. 电子邮件</a></li><li><a href="#2125-分发工具" class="table-of-contents__link toc-highlight">21.25. 分发工具</a></li><li><a href="#2126-并发编程" class="table-of-contents__link toc-highlight">21.26. 并发编程</a></li><li><a href="#2127-gui-图形库" class="table-of-contents__link toc-highlight">21.27. gui 图形库</a></li><li><a href="#2128-底层网络-api" class="table-of-contents__link toc-highlight">21.28. 底层网络 api</a></li><li><a href="#2129-正则" class="table-of-contents__link toc-highlight">21.29. 正则</a></li><li><a href="#2130-随机" class="table-of-contents__link toc-highlight">21.30. 随机</a><ul><li><a href="#21301-rand-随机数字" class="table-of-contents__link toc-highlight">21.30.1. rand 随机数字</a></li></ul></li><li><a href="#2131-搜索引擎" class="table-of-contents__link toc-highlight">21.31. 搜索引擎</a></li><li><a href="#2132-开源集合容器" class="table-of-contents__link toc-highlight">21.32. 开源集合容器</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/en/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://discordapp.com/users/yuu#3743" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/xiaoyuhfq" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/en/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/xiaoyureed" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Xiaoyureed, Inc. Built with ❤️ by xiaoyu.</div></div></div></footer></div>
<script src="/en/assets/js/runtime~main.71354b01.js"></script>
<script src="/en/assets/js/main.be3ba4f3.js"></script>
</body>
</html>