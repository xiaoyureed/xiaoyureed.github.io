<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-java-concurrent">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Java Concurrent🌈 | Xiaoyureed&#x27;s 网络 Wiki </title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://xiaoyureed.github.io/en/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://xiaoyureed.github.io/en/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://xiaoyureed.github.io/en/docs/java-concurrent"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java Concurrent🌈 | Xiaoyureed&#x27;s 网络 Wiki "><meta data-rh="true" name="description" content="并行计算带来计算能力的提升但也引入了软件的复杂性, 应该只用于 图形处理, 服务端编程(Linus)"><meta data-rh="true" property="og:description" content="并行计算带来计算能力的提升但也引入了软件的复杂性, 应该只用于 图形处理, 服务端编程(Linus)"><link data-rh="true" rel="icon" href="/en/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://xiaoyureed.github.io/en/docs/java-concurrent"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/en/docs/java-concurrent" hreflang="en"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/java-concurrent" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://xiaoyureed.github.io/docs/java-concurrent" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/en/blog/rss.xml" title="Xiaoyureed&#39;s 网络 Wiki  RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/en/blog/atom.xml" title="Xiaoyureed&#39;s 网络 Wiki  Atom Feed"><link rel="stylesheet" href="/en/assets/css/styles.c6a654bf.css">
<link rel="preload" href="/en/assets/js/runtime~main.b94328d8.js" as="script">
<link rel="preload" href="/en/assets/js/main.fc98d8e0.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/en/"><div class="navbar__logo"><img src="/en/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/en/img/logo.png" alt="xiaoyureed Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Xiaoyureed</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/en/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/en/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/xiaoyureed" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/intro">intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/FreeMarker-note">FreeMarker Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/SpringBoot-note">Spring Boot 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/agile-development-user-story-scrum">敏捷开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/android">Android 开发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/autohotkey">Autohotkey 脚本</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/blockchain">blockchain区块链</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/c-sharp-and-dot-net">C# &amp; .NET</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/chatgpt">Chatgpt Usage Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cloud-native-platform">云服务平台</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cpp">CPP and C 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cross-gfw">Cross The GFW</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/cs-note">Computer Science Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/css-pre-processor">几种CSS预处理器比较选型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/data-structure-and-algorithm">Data Structure and Algorithm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/design-pattern-note">Design Pattern 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/dev-resources">开发者资源</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/devops">DevOps</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/distributed-system">Distributed System 分布式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/docker-note-virtual-dev-env">Docker Note &amp; Other Virtual Develop Environment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/effective-java-reading-note">Effective Java 阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/elk-elastic-log">Distributed log collection分布式日志收集</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/english-note">英语学习🔥</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/extjs-note">Extjs 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/flutter">flutter</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/games-development-introduce">游戏开发</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/git-note">Git 备忘 🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/github-starts">Github 星标⭐️</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/golang-note">Golang 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/gps-gis-tracing">基于地理位置开发技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/gradle">gradle</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/greasy-monkey">油猴插件&amp;编写脚本🐒</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/groovy-note">groovy note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/health">Health 关爱程序员健康🏥</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/how-to-test-java-app">How to Test Java App</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/html-note">HTML 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/idea-note">InteliJ idea tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/interview-system-design">经典的系统设计思路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/iot">Iot 物联网</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/java-code-clean">Java Clean Code Tips</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/en/docs/java-concurrent">Java Concurrent🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/java-memory-model-jmm-jvm">JMM and GC🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/java-note">Java Core 笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/jquery-note">JQuery notes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/js-tutorial">JavaScript tutorial</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/kotlin">kotlin</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/kubernetes-k8s">kubernetes-k8s ☁️</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/linux-note">鸟哥的 Linux 私房菜阅读笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/mac">Mac 开发环境</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/machine-learning-ml">machine-learning-ml</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/maven-note">Maven Notes🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/message-queue">Message Queue🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/money">Investment Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/mongodb-note">MongoDB Notes🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/monitor-system-grafana-prometheus-influxdb-hbase">monitor-system-grafana-prometheus监控🖥</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/mvc-mvvm">MVC to MVVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/mybatis-note">MyBatis Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/netty-note">netty</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/nlp-natural-language-processing">nlp-natural-language-processing👄</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/nodejs-yarn-npm">Nodejs, Yarn, Npm</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/oracle">Oracle 备忘</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-audio-video">Audio and Video development Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-big-data-introduce">大数据开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-cache">Cache 缓存🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-computational-ad">计算广告 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-crawler-spider">网络爬虫 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-db-design-note">关系型数据库表设计🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-desktop-develop">桌面应用开发 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-http">HTTP protocol Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-reactive-programming">响应式编程 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-rest-api">RESTful api 及 其他webService技术</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-rpc">RPC Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/outline-about-rule-engine-note">规则引擎 Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/php-note">PHP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/play-framework">Play框架</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/postgres-note">Postgres note🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/process-workflow-bpm-engine">工作流引擎</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/protect-your-app-authentication-oauth2-jwt-https">Protect Your App 安全保护认证鉴权🔑</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/python-note">Python🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/quant-money">量化交易</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/quarkus">Quarkus</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/react-note">React🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/real-time-communication-protocol">实时通信 Real-time</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/redis-note">Redis🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/regex">Regular Expression 正则🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/rust-note">Rust 笔记🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/saas-paas-iaas-as-a-service">SaaS Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/serverless">Serverless</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/service-mesh">service mesh 服务网格</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/servlet">Servlet Note</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/shell-bash-note">shell-bash脚本收集</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/spring-note">Spring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/springcloud-note">Spring Cloud 笔记🌈</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/springmvc-note">Spring MVC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/task-schedule-note">Task Schedule</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/tcp-ip-note">TCP IP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/tomcat-jetty-nginx">Tomcat Jetty Nginx 等 web 容器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/vertx">Vertx</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/video-creator">拍摄</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/webassembly">webassembly</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/webpack-esbuild-vite-rollup">前端打包构建工具</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/windows-sub-system-on-linux">WSL 使用</a></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/en/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Java Concurrent🌈</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Java Concurrent🌈</h1></header><div align="center">并行计算带来计算能力的提升但也引入了软件的复杂性, 应该只用于 图形处理, 服务端编程(Linus)<p>&quot;计算机硬件设计者将摩尔定律失效的责任推脱给了软件开发者&quot;</p><p>Amdahl定律,   Gustafson定律   ----- cpu个数, 串行比例, 并行后加速比的关系</p><p><a href="https://www.bilibili.com/video/BV1Je411W7Ew?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1Je411W7Ew?spm_id_from=333.337.search-card.all.click</a></p><p><a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener noreferrer">https://github.com/CL0610/Java-concurrency</a></p><p><a href="https://github.com/ZHENFENG13/concurrent-programming" target="_blank" rel="noopener noreferrer">https://github.com/ZHENFENG13/concurrent-programming</a> (《实战java高并发程序设计》)</p><p><a href="https://www.zhihu.com/question/59725713/answer/168709945" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/59725713/answer/168709945</a> </p><p><a href="https://github.com/oldratlee/fucking-java-concurrency" target="_blank" rel="noopener noreferrer">https://github.com/oldratlee/fucking-java-concurrency</a></p><p>TODO</p></div><h1>1. 为什么需要并行(多线程)计算- <a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B9%B6%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97">1. 为什么需要并行(多线程)计算</a></h1><ul><li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B9%B6%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97--1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B9%B6%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97">1. 为什么需要并行(多线程)计算- 1. 为什么需要并行(多线程)计算</a></li><li><a href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">2. 多线程需要解决的问题</a></li><li><a href="#3-%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5">3. 容易混淆的几个概念</a></li><li><a href="#4-%E5%B9%B6%E5%8F%91%E7%BA%A7%E5%88%AB">4. 并发级别</a></li><li><a href="#5-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-jmm">5. java内存模型-jmm</a></li><li><a href="#6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%843%E4%B8%AA%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7">6. 多线程线程安全的3个关键特性</a><ul><li><a href="#61-%E5%8E%9F%E5%AD%90%E6%80%A7atomicity">6.1. 原子性(atomicity)</a></li><li><a href="#62-%E5%8F%AF%E8%A7%81%E6%80%A7-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7">6.2. 可见性-缓存一致性</a></li><li><a href="#63-%E6%9C%89%E5%BA%8F%E6%80%A7-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92">6.3. 有序性-指令重排</a></li></ul></li><li><a href="#7-%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">7. 保证线程安全</a></li><li><a href="#8-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80">8. 语法基础</a><ul><li><a href="#81-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B">8.1. 线程和进程</a><ul><li><a href="#811-%E4%B8%A4%E8%80%85%E7%9A%84%E6%A6%82%E5%BF%B5">8.1.1. 两者的概念</a></li><li><a href="#812-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">8.1.2. 线程实现原理</a></li><li><a href="#813-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F">8.1.3. 线程的调度方式</a></li><li><a href="#814-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E7%8A%B6%E6%80%81">8.1.4. 线程的几个状态</a></li></ul></li><li><a href="#82-thread%E5%9F%BA%E6%9C%ACapi">8.2. thread基本api</a><ul><li><a href="#821-%E5%88%9B%E5%BB%BA">8.2.1. 创建</a></li><li><a href="#822-%E7%BB%88%E6%AD%A2">8.2.2. 终止</a></li><li><a href="#823-%E4%B8%AD%E6%96%AD-interruptedexception-%E5%A4%84%E7%90%86">8.2.3. 中断 InterruptedException 处理</a></li><li><a href="#824-%E7%AD%89%E5%BE%85%E5%92%8C%E9%80%9A%E7%9F%A5-wait-notify">8.2.4. 等待和通知-wait-notify</a></li><li><a href="#825-%E7%AD%89%E5%BE%85%E7%BB%93%E6%9D%9F%E5%92%8C%E8%B0%A6%E8%AE%A9-join-yield">8.2.5. 等待结束和谦让-join-yield</a></li><li><a href="#826-%E7%BA%BF%E7%A8%8B%E7%BB%84">8.2.6. 线程组</a></li><li><a href="#827-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B-daemon">8.2.7. 守护线程-daemon</a></li><li><a href="#828-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7">8.2.8. 线程优先级</a></li></ul></li><li><a href="#83-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97">8.3. 相关的关键字</a><ul><li><a href="#831-volatile">8.3.1. volatile</a></li><li><a href="#832-synchronized">8.3.2. synchronized</a></li></ul></li></ul></li><li><a href="#9-jdk%E4%B8%AD%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB%E5%BA%93%E9%80%A0%E6%88%90%E7%9A%84%E9%9A%90%E8%94%BD%E9%94%99%E8%AF%AF">9. jdk中非线程安全的类库造成的隐蔽错误</a><ul><li><a href="#91-%E5%85%88%E7%9C%8B%E4%B8%80%E4%B8%AA%E9%9A%90%E8%94%BD%E9%94%99%E8%AF%AF%E7%9A%84%E4%BE%8B%E5%AD%90-int%E5%9E%8B%E6%BA%A2%E5%87%BA">9.1. 先看一个隐蔽错误的例子-int型溢出</a></li><li><a href="#92-%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84arraylist">9.2. 并发下的ArrayList</a></li><li><a href="#93-%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84hashmap">9.3. 并发下的Hashmap</a></li><li><a href="#94-%E9%94%99%E8%AF%AF%E7%9A%84%E4%BD%BF%E7%94%A8%E9%94%81">9.4. 错误的使用锁</a></li></ul></li><li><a href="#10-concurrent%E5%8C%85">10. concurrent包</a><ul><li><a href="#101-%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6">10.1. 怎么进行同步控制</a><ul><li><a href="#1011-%E9%87%8D%E5%85%A5%E9%94%81-%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7">10.1.1. 重入锁-锁的公平性</a></li><li><a href="#1012-condition-%E9%87%8D%E5%85%A5%E9%94%81%E5%A5%BD%E6%90%AD%E6%A1%A3">10.1.2. Condition-重入锁好搭档</a></li><li><a href="#1013-semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE">10.1.3. semaphore-信号量-多个线程同时访问</a></li><li><a href="#1014-readwritelock-%E8%AF%BB%E5%86%99%E9%94%81">10.1.4. ReadWriteLock-读写锁</a></li><li><a href="#1015-countdownlatch-%E5%80%92%E8%AE%A1%E6%97%B6%E5%99%A8">10.1.5. CountDownLatch-倒计时器</a></li><li><a href="#1016-cyclicbarrier-%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F">10.1.6. CyclicBarrier-循环栅栏</a></li><li><a href="#1017-locksupport-%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%B7%A5%E5%85%B7%E7%B1%BB">10.1.7. LockSupport-线程阻塞工具类</a></li></ul></li><li><a href="#102-%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8-%E7%BA%BF%E7%A8%8B%E6%B1%A0">10.2. 线程复用-线程池</a><ul><li><a href="#1021-executor%E7%9A%84api">10.2.1. Executor的api</a><ul><li><a href="#10211-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0">10.2.1.1. 创建线程池</a></li><li><a href="#10212-%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E6%B1%A0%E5%AD%90%E7%9A%84%E5%AE%B9%E9%87%8F">10.2.1.2. 怎么确定池子的容量</a></li><li><a href="#10213-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E4%B8%AA%E7%8A%B6%E6%80%81">10.2.1.3. 线程池的几个状态</a></li><li><a href="#10214-%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0">10.2.1.4. 关闭线程池</a></li></ul></li><li><a href="#1022-threadpoolexecutor-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0">10.2.2. ThreadPoolExecutor-自定义线程池</a><ul><li><a href="#10221-%E6%A0%B8%E5%BF%83-api">10.2.2.1. 核心 api</a></li><li><a href="#10222-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-blockingqueue">10.2.2.2. 阻塞队列 BlockingQueue</a></li><li><a href="#10223-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5">10.2.2.3. 自定义拒绝策略</a></li><li><a href="#10224-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%8D%E7%A7%B0">10.2.2.4. 自定义线程池名称</a></li><li><a href="#10225-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B-%E5%90%8D%E7%A7%B0">10.2.2.5. 自定义线程 名称</a></li></ul></li><li><a href="#1023-%E6%97%A0%E9%94%81%E5%AE%89%E5%85%A8%E7%9A%84%E9%98%9F%E5%88%97">10.2.3. 无锁安全的队列</a></li><li><a href="#1024-%E6%8B%93%E5%B1%95%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E5%AF%BB%E6%89%BE%E5%A0%86%E6%A0%88">10.2.4. 拓展线程池-在线程池中寻找堆栈</a></li><li><a href="#1025-fork-join%E6%A1%86%E6%9E%B6">10.2.5. Fork-Join框架</a></li><li><a href="#1026-springboot%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">10.2.6. springboot中使用线程池</a></li><li><a href="#1027-hystrix-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB">10.2.7. hystrix-线程池隔离</a></li></ul></li><li><a href="#103-jdk%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8">10.3. jdk中的并发容器</a><ul><li><a href="#1031-%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D">10.3.1. 整体介绍</a></li><li><a href="#1032-concurrentlinkedqueue%E5%8E%9F%E7%90%86">10.3.2. ConcurrentLinkedQueue原理</a></li><li><a href="#1033-%E5%BC%80%E6%BA%90%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E9%98%9F%E5%88%97-disruptor">10.3.3. 开源高性能内存队列 disruptor</a></li></ul></li><li><a href="#104-aqs-%E6%97%A0%E9%94%81%E5%AE%9E%E7%8E%B0">10.4. aqs 无锁实现</a></li></ul></li><li><a href="#11-java8%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7">11. java8中的新特性</a></li><li><a href="#12-%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E9%94%81">12. 怎么优化锁</a><ul><li><a href="#121-%E6%8F%90%E9%AB%98%E9%94%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E5%88%99">12.1. 提高锁性能的原则</a><ul><li><a href="#1211-%E5%87%8F%E5%B0%91%E9%94%81%E6%8C%81%E6%9C%89%E6%97%B6%E9%97%B4-%E5%92%8C%E9%94%81%E7%B2%97%E5%8C%96-%E9%9C%80%E8%A6%81%E6%9D%83%E8%A1%A1">12.1.1. 减少锁持有时间-和锁粗化-需要权衡</a></li><li><a href="#1212-%E5%87%8F%E5%B0%8F%E9%94%81%E7%B2%92%E5%BA%A6">12.1.2. 减小锁粒度</a></li><li><a href="#1213-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E9%94%81%E4%BB%A3%E6%9B%BF%E7%8B%AC%E5%8D%A0%E9%94%81">12.1.3. 读写分离锁代替独占锁</a></li><li><a href="#1214-%E9%94%81%E5%88%86%E7%A6%BB">12.1.4. 锁分离</a></li></ul></li><li><a href="#122-jvm%E6%98%AF%E6%80%8E%E4%B9%88%E5%AF%B9%E9%94%81%E4%BC%98%E5%8C%96%E7%9A%84">12.2. jvm是怎么对锁优化的</a><ul><li><a href="#1221-%E4%BD%BF%E9%94%81%E8%BF%9B%E5%85%A5%E5%81%8F%E5%90%91%E6%A8%A1%E5%BC%8F-%E5%81%8F%E5%90%91%E9%94%81">12.2.1. 使锁进入偏向模式-偏向锁</a></li><li><a href="#1222-%E4%BD%BF%E7%94%A8%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">12.2.2. 使用轻量级锁</a></li><li><a href="#1223-%E8%87%AA%E6%97%8B%E9%94%81">12.2.3. 自旋锁</a></li><li><a href="#1224-%E9%94%81%E6%B6%88%E9%99%A4">12.2.4. 锁消除</a></li></ul></li><li><a href="#123-threadlocal">12.3. ThreadLocal</a><ul><li><a href="#1231-threadlocal%E6%A6%82%E5%BF%B5">12.3.1. threadlocal概念</a></li><li><a href="#1232-threadlocal-%E7%A4%BA%E4%BE%8B">12.3.2. threadLocal 示例</a></li><li><a href="#1233-%E5%86%8D%E7%9C%8B%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BE%8B%E5%AD%90%E4%BB%A5%E5%8F%8A%E6%94%B9%E8%BF%9B">12.3.3. 再看一个问题例子以及改进</a></li><li><a href="#1234-%E5%8E%9F%E7%90%86">12.3.4. 原理</a></li><li><a href="#1235-%E7%9C%8B%E6%BA%90%E7%A0%81">12.3.5. 看源码</a></li></ul></li><li><a href="#124-weakreference">12.4. weakReference</a><ul><li><a href="#1241-%E4%BB%80%E4%B9%88%E6%98%AFweakreference">12.4.1. 什么是WeakReference</a></li><li><a href="#1242-%E4%B8%BA%E4%BB%80%E4%BD%BF%E7%94%A8">12.4.2. 为什使用</a></li><li><a href="#1243-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8">12.4.3. 怎么使用</a></li><li><a href="#1244-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8">12.4.4. 四种引用</a></li><li><a href="#1245-referencequeue">12.4.5. ReferenceQueue</a></li><li><a href="#1246-weakhashmap--treadlocalmap">12.4.6. WeakHashMap \&amp; TreadLocalMap</a></li></ul></li><li><a href="#125-%E4%B8%8D%E5%8A%A0%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81">12.5. 不加锁-乐观锁</a><ul><li><a href="#1251-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E4%B8%8D%E5%8A%A0%E9%94%81%E7%9A%84%E7%AD%96%E7%95%A5">12.5.1. 怎么理解不加锁的策略</a></li><li><a href="#1252-atomicinteger-%E6%97%A0%E9%94%81%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0">12.5.2. AtomicInteger-无锁安全整数</a></li><li><a href="#1253-unsafe%E7%B1%BB-java%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88">12.5.3. Unsafe类-Java中的指针</a></li><li><a href="#1254-atomicreference-%E6%97%A0%E9%94%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8">12.5.4. AtomicReference-无锁的对象引用</a></li><li><a href="#1255-atomicstampedreference-%E5%B8%A6%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E5%BC%95%E7%94%A8">12.5.5. AtomicStampedReference-带时间戳的引用</a></li><li><a href="#1256-atomicintegerarray-%E6%97%A0%E9%94%81%E7%9A%84%E6%95%B0%E7%BB%84">12.5.6. AtomicIntegerArray-无锁的数组</a></li><li><a href="#1257-atomicintegerfieldupdater-%E5%8D%87%E7%BA%A7%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">12.5.7. AtomicIntegerFieldUpdater-升级普通变量支持原子操作</a></li><li><a href="#1258-synchronousqueue%E5%AE%9E%E7%8E%B0">12.5.8. SynchronousQueue实现</a></li></ul></li></ul></li><li><a href="#13-%E6%AD%BB%E9%94%81">13. 死锁</a><ul><li><a href="#131-%E6%80%8E%E4%B9%88%E6%89%93%E5%8D%B0%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF">13.1. 怎么打印线程堆栈信息</a></li></ul></li><li><a href="#14-%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AE%97%E6%B3%95">14. 并发相关的模式和算法</a><ul><li><a href="#141-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">14.1. 单例模式的最佳实现方式</a></li><li><a href="#142-%E4%B8%8D%E5%8F%98%E6%A8%A1%E5%BC%8F">14.2. 不变模式</a></li><li><a href="#143-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F">14.3. 生产者-消费者模式</a><ul><li><a href="#1431-%E4%BD%BF%E7%94%A8%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0">14.3.1. 使用阻塞队列实现</a></li><li><a href="#1432-%E6%97%A0%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0">14.3.2. 无锁的实现</a></li><li><a href="#1433-%E4%BD%BF%E7%94%A8%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0">14.3.3. 使用等待通知机制实现</a></li></ul></li><li><a href="#144-%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5">14.4. 等待通知</a></li><li><a href="#145-countdownlatch-cyclicbarrier">14.5. CountDownLatch CyclicBarrier</a></li><li><a href="#146-semaphore">14.6. Semaphore</a></li><li><a href="#147-reentrantlock%E4%B8%8Econdtion">14.7. ReentrantLock与Condtion</a></li><li><a href="#148-future%E6%A8%A1%E5%BC%8F">14.8. Future模式</a><ul><li><a href="#1481-%E5%85%B8%E5%9E%8Bfuture%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0">14.8.1. 典型Future模式实现</a></li><li><a href="#1482-jdk%E4%B8%AD%E7%9A%84future%E6%A8%A1%E5%BC%8F">14.8.2. jdk中的future模式</a></li></ul></li><li><a href="#149-map-reduce-%E6%A8%A1%E5%BC%8F">14.9. map-reduce 模式</a></li><li><a href="#1410-worker-pool-%E6%A8%A1%E5%BC%8F">14.10. worker-pool 模式</a></li><li><a href="#1411-%E5%B9%B6%E8%A1%8C%E6%B5%81%E6%B0%B4%E7%BA%BF">14.11. 并行流水线</a></li><li><a href="#1412-%E5%B9%B6%E8%A1%8C%E6%90%9C%E7%B4%A2">14.12. 并行搜索</a></li><li><a href="#1413-%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F">14.13. 并行排序</a><ul><li><a href="#14131-%E6%94%B9%E8%BF%9B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E5%88%86%E7%A6%BB%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E6%80%A7-%E5%A5%87%E5%81%B6%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F">14.13.1. 改进冒泡排序-分离数据相关性-奇偶交换排序</a></li><li><a href="#14132-%E6%94%B9%E8%BF%9B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">14.13.2. 改进插入排序-希尔排序</a></li></ul></li><li><a href="#1414-%E7%BD%91%E7%BB%9Cnio">14.14. 网络nio</a></li></ul></li><li><a href="#15-%E4%BD%BF%E7%94%A8-akka-%E6%9E%84%E5%BB%BA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F">15. 使用 akka 构建高并发程序</a></li><li><a href="#16-%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95">16. 并行程序怎么调试</a></li></ul><h1>2. 多线程需要解决的问题</h1><ul><li><p>上下文切换 - 线程切换的时候需要保存本次执行的信息, 再次获取 cpu 控制权需要恢复上次所保存的信息</p><ul><li><p>采用无锁编程，比如将数据按照 Hash(id) 进行取模分段，每个线程处理各自分段的数据，从而避免使用锁</p></li><li><p>采用 CAS(compare and swap) 算法，如 Atomic 包就是采用 CAS 算法</p></li><li><p>避免创建了一些线程但其中大部分都是处于 waiting 状态，因为每当从 waiting 状态切换到 running 状态都是一次上下文切换</p></li></ul></li><li><p>死锁 - 线程 A 和线程 B 都在互相等待对方释放锁，或者是其中某个线程在释放锁的时候出现异常如死循环</p><ul><li>尽量一个线程只获取一个锁, 只占用一个资源</li><li>使用定时锁，至少能保证锁最终会被释放。</li></ul></li><li><p>资源限制 - 一个线程不能无限制的使用资源, 这是为了避免一个线程出现异常导致整个系统出问题</p></li></ul><h1>3. 容易混淆的几个概念</h1><p>可以参考 java-note 中的 &quot;同步异步和阻塞非阻塞&quot; 一节</p><ul><li><p>synchronous(同步) 和 asynchronous(异步) - 用来形容某一次方法调用</p><ul><li><p>同步方法一旦开始, 就必须等到方法结束后(如果有返回值, 则是等到返回值返回后), 再执行后续方法</p></li><li><p>异步..........., 方法会立即返回, 继续进行后续任务; 异步任务通常会另外开一个 thread , 如果有返回结果则在 exec 完毕后会通知调用者</p></li></ul></li><li><p>concurrency(并发) 和 parallelism(并行) - 都可以表示多个任务一起执行</p><ul><li><p>concurrency 表示多个任务交替执行, 这些任务可能仍旧是串行的 --- 单cpu, 因为一次只能执行一条指令</p></li><li><p>parallelism 是真正的 同时执行 ------ 多cpu</p></li></ul></li><li><p>临界区 - 泛指公共资源, 被多个 thread 共享, 同一时间只能有一个 thread 能使用</p></li><li><p>blocking(阻塞) 和 non-blocking(非阻塞) - 用来形容cpu状态; 如果 cpu 阻塞, 当前 thread 会被挂起, cpu控制权被其他thread夺去, 在另一个 thread 释放 resource 前, 当前 thread 只能阻塞, 不能执行; ---------- 因此也可形容某个操作是否是阻塞的 (是否会造成 cpu 阻塞)</p><ul><li><p>blocking: 如果一个 thread 正在占用 临界区resources, 则其他的 thread 就需要在临界区等待(线程 被挂起) ------------- 一个耗时任务执行时, cpu空闲等待</p></li><li><p>non-blocking: 多个 thread 互不影响, 无论是否占用 临界区 resources, thread 都会尝试不断向前执行 -------- 一个耗时任务(如io任务)执行时, cpu不会空闲, 会去执行其他任务</p></li></ul></li><li><p>deadlock(死锁), starvation(饥饿), live lock(活锁)</p><ul><li><p>deadlock - 多个线程互相等待对方释放资源, 无解</p></li><li><p>starvation - thread 无法得到需要的resources, 而一直等待. 过一段时间有可能缓解的; eg: thread优先级太低; 资源被其他thread一直霸占</p></li><li><p>live lock - resources 不断再两个 thread 间跳动, 没有一个 thread 同时拿到运行必须的所有 resources, 造成两个都不能正常执行</p></li></ul></li></ul><h1>4. 并发级别</h1><ul><li><p>blocking - 一个 thread 是 blocking的, 在其他 thread 释放 resource 前, 该 thread 无法执行; 比如使用 <code>synchronized</code>, or <code>重入锁</code>, 得到的就是 blocking  thread</p></li><li><p>starvation-free(无饥饿) - 在线程排队执行时无视优先级, 不允许高优先级的 thread 插队; 就是 采用 &quot;公平锁&quot; 而不用 &quot;非公平锁&quot;</p></li><li><p>obstruction-free(无障碍) </p><ul><li><p>最弱的 non-blocking 调度</p></li><li><p>2个 thread 之间是 obstruction-free 的关系, 表示不会因为共享资源的问题导致一方被挂起等待, 都可以同时进入 临界区, 如果是 read-only 操作 都相安无事, 如果是 write 操作, 当 A thread 在 write时候检测到 B thread 也在 write, A 就会立即对自己的操作进行回滚.</p></li><li><p>不一定能保证程序顺利运行, 比如 两个 thread 都不断的回滚自己的write 操作 , 这样就没有一个 thread 能够顺利的走出 临界区</p><p>一种解决方法是: &quot;一致性标记&quot;, 每个 write操作都需要更新这个标记 - 在某个write操作前先读取保存这个标记, 在操作完成后再次读取, 和保存的版本比较, 如果一致则证明在修改期间没有其他线程的 write操作, 如果不一致 需要重试or报错.</p></li></ul></li><li><p>lock-free(无锁) </p><ul><li><p>所有的 thread 都能对 临界区访问, 并且保证一定有一个 thread 能够顺利离开临界区</p></li><li><p>典型特征是, 包含一个<code>死循环</code>, thread 会不断尝试 修改 共享变量, 修改成功那么thread顺利退出, 否则继续尝试修改</p></li></ul></li><li><p>wait-free(无等待) </p><ul><li><p>要求所有 thread 可以在有限步数内完成操作, 离开临界区</p></li><li><p>rcu(read-copy-update) 基本思想: read-only操作可以不加控制, 所有 read 操作都是 wart-free 的, 对 write操作, 先取得原始数据的 copy, 仅仅修改这份 copy即返回修改成功, 在合适的时间回写数据到数据库</p></li></ul></li></ul><h1>5. java内存模型-jmm</h1><p>{% post_link java-memory-model 📚 java-memory-model %}</p><h1>6. 多线程线程安全的3个关键特性</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="61-原子性atomicity">6.1. 原子性(atomicity)<a href="#61-原子性atomicity" class="hash-link" aria-label="Direct link to 6.1. 原子性(atomicity)" title="Direct link to 6.1. 原子性(atomicity)">​</a></h2><p>在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断，要么执行完成，要不就不执行 - 一个操作一旦开始, 就不会被其他 thread 干扰</p><p>eg: 对于 静态全局变量 int i, 两个 thread 同时赋值, 1, -1, 那么最终i的结果只能是 1或-1中的一个, 不会是其他结果 ------ <code>给int类型值赋值操作具有原子性</code></p><p>eg: 对于 静态全局变量 long i, .........................., 最终 i的值可能是怪异的结果 ---------------------------- <code>long 类型 占据8字节， 64bit, 在 32bit机器上读/写至少需要两条指令，不是原子性的</code>, 有可能thread1获取 cpu控制权, 一次读取 32bit, 也就是 long 型数据的二进制前一半, 正准备接着读取剩下一半, cpu控制权被 thread2 切走, thread2进行了修改操作， thread1接着读取， 拼出来的long就是怪异的结果；</p><p>在Java中可以使用 synchronized来保证方法和代码块内的操作是原子性的。底层原理是 <code>两个高级的字节码指令 monitorenter 和 monitorexit</code></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="62-可见性-缓存一致性">6.2. 可见性-缓存一致性<a href="#62-可见性-缓存一致性" class="hash-link" aria-label="Direct link to 6.2. 可见性-缓存一致性" title="Direct link to 6.2. 可见性-缓存一致性">​</a></h2><p>保证读取到的变量都是最新的;</p><ul><li><p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 ------------ 也可以说是 &quot;缓存一致性&quot; 问题, cpu读取到了 cache 中的脏数据</p></li><li><p>使用 volatile 声明 变量 i 来保证可见性 - 告诉jvm, 这个变量 i 是不稳定的, 随时会被多个thread 修改, 必须特殊对待 </p><ul><li><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去；</p></li><li><p>针对volatile变量的写操作会导致其他线程本地内存中的缓存无效。</p></li><li><p>禁止指令重排序优化</p></li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="63-有序性-指令重排">6.3. 有序性-指令重排<a href="#63-有序性-指令重排" class="hash-link" aria-label="Direct link to 6.3. 有序性-指令重排" title="Direct link to 6.3. 有序性-指令重排">​</a></h2><p>程序在执行时候 可能进行 指令重排, 重拍后的指令和原始指令不一样</p><p>重排前后, 串行程序运行结果都是一致的, 但是并行程序就不一定了</p><p>为什么又有 &quot;指令重排&quot;? ------ cpu执行一个汇编指令会分成很多步骤, 每个步骤涉及的硬件不同, 比如 step1进行完后, 对应的硬件就闲置了, 必须等到整个汇编指令对应的step都执行完才会被再次利用, cpu引入 &quot;流水线&quot;的工作机制, 指令重排后的命令可以减少流水线的中断</p><p>哪些指令不会被重排? ----------- 遵循这几个原则</p><ul><li><p>程序顺序原则 - 保证重排前后, 串行程序结果不变</p></li><li><p>volatile - 保证 volatile 变量的 write操作, 先发于 read操作, 这保证了 volatile变量的可见性</p></li><li><p>锁规则 - 保证 解锁 在随后的 加锁 前</p></li><li><p>传递性 - a先于b, b先于c, 那么 a先于c;</p></li><li><p>线程的 start() 先于 该 thread 的每个动作 - 也就是保证 thread 首先正常启动</p></li><li><p>线程的 interrupt() 先于 该 thread 被中断的代码</p></li></ul><p>使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作</p><h1>7. 保证线程安全</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">多线程开发中，要考虑好线程安全问题(同步, 互斥..)。而因为这些需求就出现了以下三种来实现线程安全的手段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*   互斥同步(阻塞同步)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    就是通过加锁(就是悲观锁)来实现对临界资源的访问限制。加锁方式有 synchronized 和Lock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*   非阻塞同步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 非阻塞同步属于乐观锁机制。典型的实现方式就是 CAS 操作, 详细见: [1](https://www.ibm.com/developerworks/cn/java/j-jtp04186/), [2](http://lxy2330.iteye.com/blog/1153135), [3](http://blog.csdn.net/aesop_wubo/article/details/7537960)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * CAS(compare and swap), 先比较, 如果变量没有变化, 再交换赋值, java.util.concurrent.atomic包中几乎大部分类都采用了CAS操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * CAS有三个操作参数：内存地址，期望值，要修改的新值，当期望值和内存当中的值进行比较不相等的时候，表示内存中的值已经被别线程改动过，这时候失败返回，只有相等时，才会将内存中的值改为新的值，并返回成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * ABA问题: ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * ABA问题的解决思路是: 加版本号，每次变量更新的时候把变量的版本号加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题(在JDK的java.util.concurrent.atomic包中提供了AtomicStampedReference来解决ABA问题)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * 乐观锁和悲观锁: 是两种思想, 乐观锁就是对加锁对象比较乐观，假定它不存在很多并发更新请求。悲观锁反之. 可以有很多实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 数据库中: 悲观锁就是for update; 乐观锁就是加 version字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * JDK方面：悲观锁就是sync; 乐观锁就是原子类（内部使用CAS实现）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*   无同步方案(维护自己的变量)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    要保证线程安全，并不是一定就需要同步，同步只是保证共享数据征用时正确性的手段，如果一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证正确性。由此引出 ThreadLocal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Copy-on-write，你变你的，我变我的，每变一次都生成新的副本，只要不冲突就可以并行；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>8. 语法基础</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="81-线程和进程">8.1. 线程和进程<a href="#81-线程和进程" class="hash-link" aria-label="Direct link to 8.1. 线程和进程" title="Direct link to 8.1. 线程和进程">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="811-两者的概念">8.1.1. 两者的概念<a href="#811-两者的概念" class="hash-link" aria-label="Direct link to 8.1.1. 两者的概念" title="Direct link to 8.1.1. 两者的概念">​</a></h3><ul><li><p>进程(process)代表一个内存中运行的应用程序</p><ul><li><p>每个进程都有自己独立的一块内存空间， 因为进程是资源分配和拥有的单位 (计算机在分配计算资源时, 是按照进程为单位分配的)</p></li><li><p>一个进程中可以运行多个线程， 这些线程共享进程的资源（内存，文件io）; </p></li><li><p>至少拥有一个thread - main thread， 也就是运行 mian()方法的线程，它被称为主线程， 对于java， 所有 thread 执行完毕 程序退出， 对于golang，main thread 执行完毕程序就退出了， 这和两者的 thread实现原理有关</p></li></ul></li><li><p>线程是指进程中的一个执行流程，</p><ul><li><p>thread 是cpu调度的最小单位</p></li><li><p>线程不能够独立执行， 必须存在于某个进程中</p></li><li><p>每个线程都有一个调用栈， 一旦创建一个新的线程，就产生一个新的调用栈。</p></li><li><p>线程总体分两类：用户线程和守候线程。对于Java， 当所有用户线程执行完毕的时候，JVM自动关闭</p></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="812-线程实现原理">8.1.2. 线程实现原理<a href="#812-线程实现原理" class="hash-link" aria-label="Direct link to 8.1.2. 线程实现原理" title="Direct link to 8.1.2. 线程实现原理">​</a></h3><p>在操作系统的OS Thread和编程语言的User Thread之间，实际上存在3中线程对应模型，也就是：1:1，1:N，M:N</p><ul><li><p>使用内核线程实现 （Java） - 一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢，频繁切换效率很低</p><p>  这种实现方式，线程直接由操作系统内核支持。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程，轻量级进程与内核线程之间是1:1的关系，称为一对一的线程模型 </p></li><li><p>使用用户线程实现 - 协程 - 多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核</p><p>  用户线程的建立、 同步、 销毁和调度完全在用户态中完成，不需要内核的帮助。内核线程与用户线程为1：N的关系</p></li><li><p>使用用户线程加轻量级进程混合实现 （Golang） - 多个 协程 （比如 goroutine）在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。</p><p>  这种实现方式将内核线程与用户线程一起使用，在这种混合实现下，既存在用户线程，也存在轻量级进程。 用户线程还是完全建立在用户空间中 。用户线程与轻量级进程为N:M的关系。</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="813-线程的调度方式">8.1.3. 线程的调度方式<a href="#813-线程的调度方式" class="hash-link" aria-label="Direct link to 8.1.3. 线程的调度方式" title="Direct link to 8.1.3. 线程的调度方式">​</a></h3><p>协同式线程调度和抢占式线程调度。</p><ul><li><p>协同式线程调度 - 线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。</p><p>  优点：实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。  </p><p>  缺点：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。  </p></li><li><p>抢占式线程调度 （Java） - 每个线程由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield（）可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。</p><p>  线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="814-线程的几个状态">8.1.4. 线程的几个状态<a href="#814-线程的几个状态" class="hash-link" aria-label="Direct link to 8.1.4. 线程的几个状态" title="Direct link to 8.1.4. 线程的几个状态">​</a></h3><p>thread 几种状态: <a href="https://www.draw.io/?lightbox=1&amp;highlight=0000ff&amp;edit=_blank&amp;layers=1&amp;nav=1&amp;title=Untitled%20Diagram.xml#R5VlLc5swEP41mmkP8SAwr2PtkPbQzmQmhzZHBWRQA5JHyLGdX18B4inseuJX0iYzGbEsy%2B633%2B5KBFjzbPOVo2Xyg0U4BaYRbYB1C0zT9yz5txBsK4FtupUg5iSqRLAVPJBXrISGkq5IhPOeomAsFWTZF4aMUhyKngxxztZ9tQVL%2B29dohhrgocQpbr0J4lEUkm9OopC%2Fg2TOKnfDB2%2FupOhWllFkicoYuuOyAqANeeMiWqVbeY4LbCrcameu9txt3GMYyoOeWBaPfCC0pWKTfkltnWwOJKxq0vGRcJiRlEatNIZZysa4cKiIa8SkaVyCeXyNxZiq9KHVoJJUWvhO2NLpReyjIRq3SBS2KqcKTzYGZ8S5WzFQ6Wl2CUQj7HSMhtsJScxy7DgW6nCcYoEeelbR4odcaPXAigXCsNxPF0Nz1y6IT591mAVeCP6aHGck1f0VCoUwS8ZoaL0xZ4B%2B1ZKUEpiKgWhjB5zKXjBXBDJyy%2FqRkaiqExJip5wOkPhc1wmZ85Sxsv3Wovyp8G2sIA3Y1WjPGm52kV9Oo6nMnRjTMypqTivavxGWT8YcmX9vkCho8IWi1xmdZiTxomD0uSfnvZdDneS2qPzofXwNtqbOu29C9G%2BbsxdQAMXzGbAt0DgAP8W%2BHf%2FWAn4fysB6Dr2%2By0BaOqtakvDhDMqCRppyTqI7XhDxC%2BlUqwfi%2FXEf2sdSKz5trQ3Me36%2BrFj%2Fx5zImMuiHDEvBgpHGgdWTmD1NX08o0eIyzD6JuofFBPHZdfR8vvGpGxSdTtdJTR87a2vSk9XfrsSzU%2B%2F2RwNrUzce1O%2BQxAgz3MJgZ0a8GwFq47eeClRk%2Bzkz5dBiDodi%2FX7mdAY%2B3%2FAjQcmfEe8AIwc0Fgg1kAfLnwgT8FHjxzUkx7Xy%2B58MYLXvHAoU9xvqK03LjsnuBFqOuECPywRGUQa3lM39Pcu6mJU5TnvX49sn%2FSANu5T7LM%2FkSEtrpetwdrWOsknUO1YxwPHrRHZySh8ccAz3QH2wnnguB5GnZy9mSEIrF39%2FiO4HOMAfcuCZ%2BlwUfx%2BqPgdsWS1XF7Sln4%2FFE4BwecM71Lgqd%2FnqJMkMX26qeC8b2vsWfndcS4tk8%2FrsePe5blTaDX%2FtafW%2Bt27Q1yWnmpnf50ux6cdMxC1%2BlzyjzfqXKk68tTR1QQ%2BCNNzqk3mJzT85WhvGw%2F6FeYt%2F8VsYI%2F" target="_blank" rel="noopener noreferrer">online</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="82-thread基本api">8.2. thread基本api<a href="#82-thread基本api" class="hash-link" aria-label="Direct link to 8.2. thread基本api" title="Direct link to 8.2. thread基本api">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="821-创建">8.2.1. 创建<a href="#821-创建" class="hash-link" aria-label="Direct link to 8.2.1. 创建" title="Direct link to 8.2.1. 创建">​</a></h3><ul><li><p>使用 start(), 而不是 run()</p></li><li><p>实现 Runnable 接口 而不是 继承 Thread 类</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="822-终止">8.2.2. 终止<a href="#822-终止" class="hash-link" aria-label="Direct link to 8.2.2. 终止" title="Direct link to 8.2.2. 终止">​</a></h3><ul><li><p>不要使用 stop() </p><ul><li><p>因为太暴力, 强行将未执行完的 thread 终止, 会造成数据不一致的问题</p></li><li><p>为什么会出现  <code>数据不一致</code>呢? - stop() 会直接终止 thread, 立即释放 thread 所持有的 锁, 如果此时 thread 正 write 数据到一半,   被强行终止, 对象就被改坏了, 同时 锁被释放, 这个错误的对象就被读取了</p></li></ul></li><li><p>自己定义一个 &quot;是否停止&quot; 的 标记变量, 决定何时退出 - jdk提供更好的办法: interrupt(中断)</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="823-中断-interruptedexception-处理">8.2.3. 中断 InterruptedException 处理<a href="#823-中断-interruptedexception-处理" class="hash-link" aria-label="Direct link to 8.2.3. 中断 InterruptedException 处理" title="Direct link to 8.2.3. 中断 InterruptedException 处理">​</a></h3><p>thread 不立即退出, 只是接受到一个中断信号, 至于接收到这个信号干什么, 有我们自己写代码决定</p><p>api:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Thread thread = new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              if (Thread.currentThread().isInterrupted()) {// 收到中断信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              // 执行我们自己的逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  System.out.println(&quot;收到中断信号,停止该线程!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  Thread.sleep(600);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  // TimeUnit.SECONDS.sleep(60); // 优雅的 睡眠</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  e.printStackTrace();// sleep 时候 被 interrupt, 抛异常, 会清除 interrupt 标记, 即没有收到中断信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  Thread.currentThread().interrupt();// 需要再次手动恢复 interrupt 标记, 即收到中断信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              System.out.println(&quot;Running!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              Thread.yield(); // 谦让</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  thread.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Thread.sleep(2000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  thread.interrupt();//进行中断操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="824-等待和通知-wait-notify">8.2.4. 等待和通知-wait-notify<a href="#824-等待和通知-wait-notify" class="hash-link" aria-label="Direct link to 8.2.4. 等待和通知-wait-notify" title="Direct link to 8.2.4. 等待和通知-wait-notify">​</a></h3><ul><li><p>必须在 synchronized 中使用, 等待, 唤醒操作都必须先获得目标对象的一个监视器（锁）</p></li><li><p>不推荐使用 - 会干扰 系统 api 工作 或被系统api影响, 比如 join(), 本质就是调用 wait(), 如果随便使用 wait(), 会干扰 这个api</p></li><li><p>这两个方法定义 在 Object 类 上, 任何对象都可以调用, 比如: thread A call了 obj.wait(), thread A 会进入obj的等待队列, 直到其他 thread 调用 了 obj.notify(), obj 会从自己的等待队列中随机选取一个 thread;</p><p>这时 obj 就像是 thread A B 间的 通讯手段</p></li><li><p>不要使用 suspend()挂起, resume()恢复 ---- 因为这样挂起thread 锁不会释放, 而且由于指令重排, resume()在suspend()前执行会造成thread永远挂起</p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//wait()方法会释放目标对象的锁,而Thread.sleep()方法不会释放任何资源.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SimpleWaitAndNotify {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final static Object object = new Object();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class Thread1 extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (object) { // 执行 wait 方法前, 首先获取 object 对象锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(System.currentTimeMillis() + &quot;:thread1 start !&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(System.currentTimeMillis() + &quot;:thread1 wait for object !&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    object.wait();// 执行完毕后 thread 会释放object锁, 等待, 一旦有 notify 信号, 则再次获取 object 锁, 被唤醒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(System.currentTimeMillis() + &quot;:thread1 end!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class Thread2 extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (object) { //首先获取 object 对象锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(System.currentTimeMillis() + &quot;:thread2 start ! notify one thread&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                object.notify();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(2000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(System.currentTimeMillis() + &quot;:thread2 end!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="825-等待结束和谦让-join-yield">8.2.5. 等待结束和谦让-join-yield<a href="#825-等待结束和谦让-join-yield" class="hash-link" aria-label="Direct link to 8.2.5. 等待结束和谦让-join-yield" title="Direct link to 8.2.5. 等待结束和谦让-join-yield">​</a></h3><p>threa1.join()表示 thread1加入了当前线程 - 会使得 current thread 等待 thread1执行完毕 再执行</p><p>thread1.yield() 让出 cpu 控制权, 重新争夺cpu</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class JoinMain {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public volatile static int i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class AddThread extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;add!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (i = 0; i &lt; 1000000; i++) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(500);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        AddThread at = new AddThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        at.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        at.join();//使用join()方法后,主线程会等待AddThread执行完毕,i输出为1000000,如果没有这条语句,i输出为0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //可以查看join的底层代码,本质即让调用线程在当前线程对象实例上等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="826-线程组">8.2.6. 线程组<a href="#826-线程组" class="hash-link" aria-label="Direct link to 8.2.6. 线程组" title="Direct link to 8.2.6. 线程组">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ThreadGroupName implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String groupAndName = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.currentThread().getThreadGroup().getName() + &quot;-&quot; + Thread.currentThread().getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;I am &quot; + groupAndName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(3000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadGroup tg = new ThreadGroup(&quot;PrintGroup&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t1 = new Thread(tg, new ThreadGroupName(), &quot;T1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t2 = new Thread(tg, new ThreadGroupName(), &quot;T2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(tg.activeCount());// 活动线程的大概总数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t3 = new Thread(tg, new ThreadGroupName(), &quot;T3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t3.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(tg.activeCount());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tg.list();// 打印所有的线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="827-守护线程-daemon">8.2.7. 守护线程-daemon<a href="#827-守护线程-daemon" class="hash-link" aria-label="Direct link to 8.2.7. 守护线程-daemon" title="Direct link to 8.2.7. 守护线程-daemon">​</a></h3><p>当系统只有 daemon thread 存在, jvm 就自动退出了</p><p>比如 GC 线程, JIT线程 就是 daemon</p><p>可通过 <code>thread.setDaemon(true);</code></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class DaemonDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class DaemonT extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;I am alive&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * thread被设置为守护线程,系统中只有主线程main为用户线程,因此</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *在main线程休眠3秒退出时,整个程序也随之结束,如果不把线程thread设置为守护线程,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * main线程结束后,t线程还会不停的打印,永远也不会结束.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * tip:当一个Java应用内,只有守护线程时,Java虚拟机就会退出.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param args</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread = new DaemonT();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread.setDaemon(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(3000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="828-线程优先级">8.2.8. 线程优先级<a href="#828-线程优先级" class="hash-link" aria-label="Direct link to 8.2.8. 线程优先级" title="Direct link to 8.2.8. 线程优先级">​</a></h3><p>虽然Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行， 但是 “并不是一定先被执行”</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class PriorityDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class HightPriority extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                synchronized (PriorityDemo.class) {//此处产生资源竞争</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (count &gt; 1000000) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        System.out.println(&quot;HightPriority is complete!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class LowPriority extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                synchronized (PriorityDemo.class) {//此处产生资源竞争</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (count &gt; 1000000) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        System.out.println(&quot;LowPriority is complete!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 低优先级的线程先启动,但是并不能保证每次都是LowPriority先完成,资</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     源竞争的情况下还是会先确保优先级较高的线程 (这里的线程 hight) 获得资源.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param args</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread high = new HightPriority();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread low = new LowPriority();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        high.setPriority(Thread.MAX_PRIORITY);// 有 3 个枚举量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        low.setPriority(Thread.MIN_PRIORITY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        low.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        high.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="83-相关的关键字">8.3. 相关的关键字<a href="#83-相关的关键字" class="hash-link" aria-label="Direct link to 8.3. 相关的关键字" title="Direct link to 8.3. 相关的关键字">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="831-volatile">8.3.1. volatile<a href="#831-volatile" class="hash-link" aria-label="Direct link to 8.3.1. volatile" title="Direct link to 8.3.1. volatile">​</a></h3><p>保证变量的 &quot;可见性(变量更新立即刷入堆内存共享)&quot;, &quot;有序性(禁止指令重排序)&quot;, 但是无法保证 &quot;原子性(变量的读取,更新,保存可以由一个thread连续完成)&quot;</p><ul><li><p>volatile 使得变量具有可见性, 对比于synchronized, lock所带来的庞大开销, 是轻量级的同步机制 ------最终效果就是：一条线程更新了变量，其他线程会立刻知道共享变量的最新版本值</p><ul><li><p>当写一个volatile变量时，JMM会把该线程对应的本地内存（线程栈）中的变量强制刷新到主内存（堆内存）中去；</p></li><li><p>针对volatile变量的写操作会导致其他线程本地内存中的缓存无效。</p></li><li><p>禁止指令重排序优化</p></li></ul></li><li><p>volatile对于单个的共享变量的读/写具有原子性，但是像num++这种复合操作，volatile无法保证其原子性，提出了解决方案，就是使用并发包中的原子操作类，通过循环CAS的方式来保证num++操作的原子性</p></li></ul><p>用法: 直接修饰变量</p><p>底层的内存变化原理参见：java-memory-model.md 中的 #thread具体怎么访问对象中的值呢以及volatile关键字</p><p>使用场景:</p><ul><li>变量仅仅作为一个<code>状态标志</code>, 如布尔值</li><li>构造单例模式时, 使用双重空检查, 变量需要声明为 volatile, 禁止指令重排序;</li><li>变量只会被一个thread更改, 其他thread只会读取这个变量</li><li>读取多,而写操作少时, 相比于直接读写都加锁, 采用 &quot;写加锁读加volatile&quot; 的策略实现高性能的 &quot;读写锁&quot;</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 线程1执行doWork()的过程中，可能有另外的线程2调用了shutdown，所以boolean变量必须是volatile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//而如果使用 synchronized 块编写循环要比使用 volatile 状态标志编写麻烦很多</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这里如果使用 synchronized 怎么实现呢? // todo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">volatile boolean shutdownRequested;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void shutdown() { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shutdownRequested = true; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void doWork() { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!shutdownRequested) { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do stuff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//注意volatile！！！！！！！！！！！！！！！！！  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private volatile static Singleton instace;   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static Singleton getInstance(){   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //第一次null检查     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(instance == null){            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized(Singleton.class) {    //1     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //第二次null检查       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(instance == null){          //2  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                instance = new Singleton();//3  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return instance; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UserManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public volatile String lastUser; //发布的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean authenticate(String user, String password) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean valid = passwordIsValid(user, password);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (valid) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            User u = new User();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            activeUsers.add(u);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lastUser = user;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return valid;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CheesyCounter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile int value;// 读取操作借助 volatile实现了可见性; 允许多个线程同时读</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //读操作，没有synchronized，提高性能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getValue() { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //写操作，必须synchronized。因为x++不是原子操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 只允许单个thread同时写操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized int increment() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>仅仅使用 volatile 无法保证线程安全</p><p>要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul><p>以下是错误示例:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 错误示例: 对变量的写入操作依赖了当前值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 需要对方法加锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class VolatileDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static volatile int i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class PlusTask implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 0; j &lt; 10000; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i++;// i = i + 1; 违背了条件一</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * volatile保证变量的可见性,但是无法保证一些复合操作的原子性, 现在启动10个线程对i进行累加操作,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如果一切正常的话,结果应为100000,但是结果为94875或者其他小于100000,因此线程的并发中没有保证i的原子性.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 比如: 刚开始, thread1, thread2 同时读取 i=0, 各自计算后得到 i=1, 并先后写入这个结果, 这样, 虽然 i++ 执行了 2次, 实际上 i 只增加了 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param args</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long start = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread[] threads = new Thread[10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; 10; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threads[j] = new Thread(new PlusTask());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threads[j].start();// 多个 thread 同时对变量 i 写入, 会产生覆盖 , so 最终 i 达不到 100000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; 10; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threads[j].join();// main thread wait until these thread end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long end = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long time = end - start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;耗时:&quot; + time);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 错误示例: 变量包含在了具有其他变量的不变式中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 需要对方法加锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//如果初始状态是(0, 5)，同一时间内，线程 A 调用setLower(4) 并且线程 B 调用setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是(4, 3) —— 一个无效值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class NumberRange {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile  int lower, upper;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getLower() { return lower; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getUpper() { return upper; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setLower(int value) { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value &gt; upper) // 违背了规则二</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lower = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setUpper(int value) { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value &lt; lower) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        upper = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="832-synchronized">8.3.2. synchronized<a href="#832-synchronized" class="hash-link" aria-label="Direct link to 8.3.2. synchronized" title="Direct link to 8.3.2. synchronized">​</a></h3><p>synchronized使得代码块具有 <code>原子性（atomicity）</code>和 <code>可见性（visibility）</code>, 有序性</p><p>volatile 变量 能够确保自己被某个 thread 修改后, 立即(刷入堆内存)被 其他 thread 看到(解决了可见性), 但是 <code>无法禁止多个thread同时访问一个变量</code>, 多个 thread 同时修改这个变量 , 还是会冲突(不能保证线程安全)</p><p>synchronized 使得 同一时间, 只能有一个 thread 进入 同步块. 这样一次性解决了 线程安全, 可见性, 有序性</p><p>用法有三:</p><ul><li><p>作用于实例方法 - 对当<code>前实例对象</code>加锁 (即this对象), 进入方法前, 先获取 当前实例的锁</p></li><li><p>指定加锁对象 - 使用synchronized修饰代码块. 锁住的是 <code>()</code> 中的对象, 进入同步代买块前需要先获取对象的锁，这里的对象必须是两个thread 的共享对象；</p></li><li><p>作用于静态方法. -  synchronized 修饰静态的方法或静态代码块(是<code>当前类的Class对象</code>作为锁的对象), 进入前需要获取当前类的锁</p></li></ul><p>原理: JVM 是通过thread进入、退出对象监视器( Monitor, 就是锁在Hotspot虚拟机中的专门的名字 )来实现对方法、同步块的同步的; 编译后, 同步块的入口和出口分别有 <code>monitorenter</code>,<code>monitorexit</code> 指令，进入 Monitor 后线程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p><p><code>javap -c &lt;class name&gt;</code> 查看编译后信息, 可以看到在同步块的入口和出口分别有 monitorenter,monitorexit 指令。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class AccountSync implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static AccountSync instance = new AccountSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static volatile int i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; 10000000; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * synchronized的作用是实现线程间的同步,对同步的代码加锁,使得每一次都只能有一个线程进入同步块从而保证线程间的安全性.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             * 每次 thread 进入前, 需要先请求 instance 的锁, 如果当前有其他thread 持有instance的锁, 这个thread就等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (instance) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(instance);// 这里 thread1, thread2 都使用同一个 runnable 接口实例, 这样才能保证两个thread 关注同一个对象, 获取和释放的是同一个对象锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(instance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * wrong! 使用了不同的 runnable 接口实例, thread1,2关注的是不同的对象锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 如何改进? 将同步代码块搬到 静态方法中进行同步. 这样,即使两个 thread 指向不同的 runnable 对象, 但是同步块请求的是 &quot;当前类&quot; 的锁(唯一), 不是实例的锁, 仍旧可以保证同步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Thread thread1 = new Thread(new AccountSync());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Thread thread2 = new Thread(new AccountSync());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>等效的 代码:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class AccountingVol implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static AccountingVol instance = new AccountingVol();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static volatile int i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // thread 再进入这个实例方法前, 需要获取当前对象实例的锁, 也就是 instance 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void increase() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; 10000000; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            increase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(instance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(instance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>9. jdk中非线程安全的类库造成的隐蔽错误</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="91-先看一个隐蔽错误的例子-int型溢出">9.1. 先看一个隐蔽错误的例子-int型溢出<a href="#91-先看一个隐蔽错误的例子-int型溢出" class="hash-link" aria-label="Direct link to 9.1. 先看一个隐蔽错误的例子-int型溢出" title="Direct link to 9.1. 先看一个隐蔽错误的例子-int型溢出">​</a></h2><p>典型如 int 型变量溢出</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int v1 = 1023434540;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int v2 = 1448547380;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int v3 = (v1 + v2)/2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;v3: &quot; + v3);// v3: -911492688</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="92-并发下的arraylist">9.2. 并发下的ArrayList<a href="#92-并发下的arraylist" class="hash-link" aria-label="Direct link to 9.2. 并发下的ArrayList" title="Direct link to 9.2. 并发下的ArrayList">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ArrayListMultiThread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class AddThread implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; 10000; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                arrayList.add(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * ArrayList是一个线程不安全的容器,多线程操作时可能有3中情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * - 不出现错误 - arraylist 最终大小20000, 并行程序有问题也不一定每次都暴露出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * - 会出现冲突,报错信息如下:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Exception in thread &quot;Thread-1&quot; java.lang.ArrayIndexOutOfBoundsException: 22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * at java.util.ArrayList.add(ArrayList.java:441)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * at chapter2.ArrayListMultiThread$AddThread.run(ArrayListMultiThread.java:27)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * at java.lang.Thread.run(Thread.java:745)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 这是因为 ArrayList 在动态扩容时候, 内部一致性被破坏, 在没有锁保护的情况下, 被另外一个thread访问到这种不一致状态  导致出现越界问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * - 出现错误的结果, 但是不报错 -  这是由于2个thread同时对 array list同一个位置进行赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Vector是一个线程安全的容器,可以代替ArrayList</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(new AddThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(new AddThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(arrayList.size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="93-并发下的hashmap">9.3. 并发下的Hashmap<a href="#93-并发下的hashmap" class="hash-link" aria-label="Direct link to 9.3. 并发下的Hashmap" title="Direct link to 9.3. 并发下的Hashmap">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class HashMapMultiThread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class AddThread implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int start = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public AddThread(int start) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.start = start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = start; i &lt; 100000; i += 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                map.put(Integer.toString(i), Integer.toBinaryString(i));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  HashMap是一个线程不安全的容器,多线程操作时会出现冲突</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  jdk7下,可能会导致电脑死机,jdk8中问题已修复</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * cpu使用率100%, 死循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 由于多线程冲突, hashmap.put() 时， 内部的链表成环了, 一迭代就成了死循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param args</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(new HashMapMultiThread.AddThread(0));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(new HashMapMultiThread.AddThread(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(map.size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="94-错误的使用锁">9.4. 错误的使用锁<a href="#94-错误的使用锁" class="hash-link" aria-label="Direct link to 9.4. 错误的使用锁" title="Direct link to 9.4. 错误的使用锁">​</a></h2><p>前面提到, 两个 thread 关注不同的 对象锁, 仍旧会造成线程安全问题</p><p>看看另外的一个错误案例</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class BadLockOnInteger implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Integer i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static BadLockOnInteger instance = new BadLockOnInteger();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; 1000000; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (i) {// 这里同步的并不是同一个对象,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            //正确做法应该是 synchronized (instance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i++;// 实际执行 i=Integer.valueOf(i.intValue() + 1) // 实际上是创建了一个新的对象 i&#x27; , </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      // 2个thread 不一定能够看到同一个 i, 因为 i 指向的对象一直在变化, 2个thread每次加锁都加在了不同的 i 对象上了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 得到的结果并不是2000000,在多线程的操作中出现了错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param args</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(instance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(instance);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>10. concurrent包</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="101-怎么进行同步控制">10.1. 怎么进行同步控制<a href="#101-怎么进行同步控制" class="hash-link" aria-label="Direct link to 10.1. 怎么进行同步控制" title="Direct link to 10.1. 怎么进行同步控制">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1011-重入锁-锁的公平性">10.1.1. 重入锁-锁的公平性<a href="#1011-重入锁-锁的公平性" class="hash-link" aria-label="Direct link to 10.1.1. 重入锁-锁的公平性" title="Direct link to 10.1.1. 重入锁-锁的公平性">​</a></h3><ul><li><p>重入锁可以替代 synchronized</p></li><li><p>借助 <code>java.util.concurrent.locks.ReentrantLock</code> 实现</p></li><li><p>提供新特性 - 对于 处理死锁, 线程饥饿 有奇效</p><ul><li><p>&quot;中断响应&quot;: 使用synchronized 加锁, 如果一个thread在等待, 那么结果只有2个, 要么一直等待, 要么获取锁执行后顺利执行. 重入锁提供了第三种行为: 这个thread可以中断, 取消对锁的请求</p></li><li><p>&quot;锁申请等待限时&quot;: thread 等待另一个 thread释放锁, 超过一段时间, 那么放弃获取锁</p></li><li><p>&quot;公平锁&quot;: 通过 synchronized 产生的锁, 是不公平锁, <code>public ReentrantLock(boolean fair)</code> 可以设置重入锁是否公平, 默认是 false;</p></li></ul></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ReenterLock implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ReentrantLock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static int i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    手动指定何时进入退出锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; 1000000; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.lock();// 进入, 获得锁, 如果锁被占用, 等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // lock.lock() // 可多次进入 - 所以谓之 &quot;重入锁&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock.unlock();// 退出, 释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // lock.unlock() // 进入几次, 必须退出几次, 如果退出次数比进入次数多, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                // 则抛异常, 反之如果少, 则thread 仍然持有锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReenterLock reenterLock = new ReenterLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(reenterLock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(reenterLock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">////////////////// 中断响应 ////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class IntLock implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ReentrantLock lock1 = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ReentrantLock lock2 = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lock; // 控制锁申请顺序, 构造死锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public IntLock(int lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.lock = lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (lock == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock1.lockInterruptibly();// 获取锁, 但优先响应中断 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    // 这种方式获得的重入锁使得 thread 在等待获取锁的过程中, 可对中断进行响应</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(500);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock2.lockInterruptibly();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock2.lockInterruptibly();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(500);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock1.lockInterruptibly();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (lock1.isHeldByCurrentThread()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock1.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (lock2.isHeldByCurrentThread()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock2.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(Thread.currentThread().getId() + &quot;线程退出&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IntLock r1 = new IntLock(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IntLock r2 = new IntLock(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(r1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(r2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 死锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(1000);// main thread 休眠</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.interrupt(); // thread2中断, thread2会放弃对 lock1 的申请, 同时释放 lock2, 那么 thread1可以得到lock2, 得以顺利执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 最终 两个 thread 双双顺利退出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////// 锁请求等待限时 ////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TimeLock implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ReentrantLock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (lock.tryLock(5, TimeUnit.SECONDS)) { // 获取锁, 等待时间 5, 单位: 秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  // 不带参数de lock.tryLock() 如果锁未被占用则申请成功, return true, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  // 如果正在被占用, 则不等待立即 return false; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  // 可以循环 tryLock(), 循环尝试获取锁, 这样不会引起死锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(Thread.currentThread().getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;get lock success&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(6000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(Thread.currentThread().getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;get lock failed&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (lock.isHeldByCurrentThread()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TimeLock timeLock = new TimeLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(timeLock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(timeLock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">///////////////////// 循环 tryLock() ////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TryLock implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ReentrantLock lock1 = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ReentrantLock lock2 = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TryLock(int lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.lock = lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (lock == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (lock1.tryLock()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Thread.sleep(500);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (lock2.tryLock()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                System.out.println(Thread.currentThread().getId() + &quot;:My Job done;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                lock2.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        lock1.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (lock2.tryLock()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Thread.sleep(500);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (lock1.tryLock()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                System.out.println(Thread.currentThread().getId() + &quot;:My Job done;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                lock1.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        lock2.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 上面代码中采用了非常容易死锁的加锁顺序,导致thread1和thread2由于锁的竞争而互相等待从而引起死锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 使用了tryLock后,线程不会一直等待而是不停的尝试去获得锁资源,只需要等待一定的时间,线程最终会获得所需要的资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param args</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TryLock r1 = new TryLock(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TryLock r2 = new TryLock(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(r1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(r2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////// 公平锁 //////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class FairLock implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ReentrantLock fairLock = new ReentrantLock(true);//设置true指定锁是公平的,也可以不设置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //public static ReentrantLock unfairLock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                fairLock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // unfairLock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(Thread.currentThread().getName() + &quot;获得锁&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                fairLock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // unfairLock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 公平锁的一个特点是:不会产生饥饿现象,只要排队最终都会得到资源.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * &lt;p/&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 但是实现公平锁要求系统维护一个有序队列,因此公平锁的实现成本较高,性能相对低下.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param args</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FairLock r1 = new FairLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(r1, &quot;Thread_t1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(r1, &quot;Thread_t2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread3 = new Thread(r1, &quot;Thread_t3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread3.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1012-condition-重入锁好搭档">10.1.2. Condition-重入锁好搭档<a href="#1012-condition-重入锁好搭档" class="hash-link" aria-label="Direct link to 10.1.2. Condition-重入锁好搭档" title="Direct link to 10.1.2. Condition-重入锁好搭档">​</a></h3><p>Condition的强大之处在于它可以为多个线程间建立不同的Condition， 使用synchronized/wait()只有一个阻塞队列，notifyAll会唤起所有阻塞队列下的线程，而使用lock/condition，可以实现多个阻塞队列，signalAll只会唤起某个阻塞队列下的阻塞线程 (典型使用就是 实现阻塞队列, 需要两个 condition, 分别作为 producer 的 condition 和 consumer 的 condition)</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ReenterLockCondition implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static ReentrantLock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Condition condition = lock.newCondition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            condition.await();// 当前thread 在 condition 对象上等待 // 类似 Object.wait()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      // 当执行 await()时候, 要求 当前thread 持有 condition 相关的锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      // 调用 await() 完成后, 当前线程休眠, 会释放当前锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Thread is going on&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReenterLockCondition reenterLockCondition = new ReenterLockCondition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(reenterLockCondition);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(2000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock(); // 首先获取condition相关的锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        condition.signal();// 唤醒 condition 的等待队列中的 一个 thread // 类似 Object.notify()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 一旦被唤醒, 这个thread会尝试重新获得 condition 绑定的 重入锁, 获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 成功才会正常继续执行, 因此 这里的 main thread 需要释放 lock, 让渡给唤醒的thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1013-semaphore-信号量-多个线程同时访问">10.1.3. semaphore-信号量-多个线程同时访问<a href="#1013-semaphore-信号量-多个线程同时访问" class="hash-link" aria-label="Direct link to 10.1.3. semaphore-信号量-多个线程同时访问" title="Direct link to 10.1.3. semaphore-信号量-多个线程同时访问">​</a></h3><p>信号量 是一个语言无关的概念, check here: {% post_link cs-note 📚 cs-note %}#信号量</p><p>无论是内部锁(synchronized) 还是 重入锁(ReentrantLock) 同一时刻只允许一个 thread访问一个资源; </p><p>semaphore(信号量) 可以指定多个thread, 同时访问一个资源</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SemapDemo implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Semaphore semp = new Semaphore(5); // 声明了包含 5 个 permission 的 semaphore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        // 即: 同时能申请 5 个许可; 当每个 thread 每次只申请一个许可, 则 这个 semaphore 同时允许 5 个thread 访问某个资源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同时允许 5 个 thread 进入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            semp.acquire(); // 尝试获取一个permission, 如果无法获取, 等待直到有另外的 thread 释放 permission 或者 current thread 被 interrupt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(2000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(Thread.currentThread().getId() + &quot;:done!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            semp.release(); // 释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 如果发生信号量泄漏(申请了但没有释放), 那么可以进入临界区的 thread将越来越少, 直到所有的thread均无法访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 总共20个线程,系统会以5个线程一组为单位,依次执行并输出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param args</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executorService = Executors.newFixedThreadPool(20);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final SemapDemo demo = new SemapDemo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 20; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executorService.submit(demo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1014-readwritelock-读写锁">10.1.4. ReadWriteLock-读写锁<a href="#1014-readwritelock-读写锁" class="hash-link" aria-label="Direct link to 10.1.4. ReadWriteLock-读写锁" title="Direct link to 10.1.4. ReadWriteLock-读写锁">​</a></h3><ul><li><p>读写锁 - 对于两个thread, &quot;读读操作&quot;之间的关系 是 非阻塞的, &quot;读写操作&quot;, &quot;写写操作&quot; 是阻塞的</p></li><li><p>如果系统中 write 操作 &lt;&lt; read操作, 则读写锁可以发挥最大功效</p></li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ReadWriteLockDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Lock lock = new ReentrantLock(); // 普通重入锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();// 读写锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Lock readLock = reentrantReadWriteLock.readLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Lock writeLock = reentrantReadWriteLock.writeLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object handleRead(Lock lock) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(1000);//模拟读操作的耗时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;读操作:&quot; + value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void handleWrite(Lock lock, int index) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(1000);//模拟写操作的耗时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;写操作:&quot; + value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            value = index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final ReadWriteLockDemo demo = new ReadWriteLockDemo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Runnable readRunnable = new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //分别使用两种锁来运行,性能差别很直观的就体现出来,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 使用读写锁后读操作可以并行,节省了大量时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    demo.handleRead(readLock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //demo.handleRead(lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Runnable writeRunnable = new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //分别使用两种锁来运行,性能差别很直观的就体现出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    demo.handleWrite(writeLock, new Random().nextInt(100));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //demo.handleWrite(lock, new Random().nextInt(100));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 18; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(readRunnable).start();// 开启 18 个 read thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              // read thread 会 完全并行, 这里耗时可忽略不计</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 18; i &lt; 20; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(writeRunnable).start();// 开启 2 个 write thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                            // 主要是写操作耗时, 整个程序耗时 2 s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1015-countdownlatch-倒计时器">10.1.5. CountDownLatch-倒计时器<a href="#1015-countdownlatch-倒计时器" class="hash-link" aria-label="Direct link to 10.1.5. CountDownLatch-倒计时器" title="Direct link to 10.1.5. CountDownLatch-倒计时器">​</a></h3><p>意为 &quot;倒计时栅栏&quot;</p><p>使得某个 thread  在执行中碰到  <code>countdownlatch.wait()</code>, 则等待, 等到倒计时结束(即计数量归零)才开始执行;</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class CountDownLatchDemo implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final CountDownLatch end = new CountDownLatch(10);// 创建倒计时器实例 计数量为10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        // 这表示需要有 10 个 thread 完成任务, 被 end倒计时器 设置为等待 的 thread才能开始执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final CountDownLatchDemo demo = new CountDownLatchDemo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(new Random().nextInt(3) * 1000);// 模拟检查任务耗时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;check complete&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            end.countDown(); // 通知 end, 有一个 thread 完成了任务, 计数量可以 -1 了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executorService.submit(demo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        end.await();// 使得 main thread 等待所有的 10 个 thread 完成 才开始继续执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Fire!&quot;);// 发射火箭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executorService.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1016-cyclicbarrier-循环栅栏">10.1.6. CyclicBarrier-循环栅栏<a href="#1016-cyclicbarrier-循环栅栏" class="hash-link" aria-label="Direct link to 10.1.6. CyclicBarrier-循环栅栏" title="Direct link to 10.1.6. CyclicBarrier-循环栅栏">​</a></h3><p>每调用一次 <code>cyclicBarrier.await()</code> 就进入新的计量循环(进入新一轮等待)</p><p>可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所以被阻塞的线程才能继续执行</p><p>如果需要可重用的 CountDownLatch，考虑使用 CyclicBarrier。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class CyclicBarrierDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class Soldier implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String soldier;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final CyclicBarrier cyclicBarrier;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Soldier(CyclicBarrier cyclicBarrier, String soldier) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.soldier = soldier;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.cyclicBarrier = cyclicBarrier;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cyclicBarrier.await();// 等待, 开始第一次计量, 直到所有的 Soldier 线程 启动完毕, 才开始继续执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                doWork();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cyclicBarrier.await();// 再次等待, 开始第二次计量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (BrokenBarrierException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void doWork() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(Math.abs(new Random().nextInt() % 10000));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(soldier + &quot;:任务完成&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class BarrierRun implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean flag;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int N;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public BarrierRun(boolean flag, int N) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.flag = flag;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.N = N;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (flag) {// 第二次计量,进入这个分支</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;司令:[士兵&quot; + N + &quot;个,任务完成!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;司令:[士兵&quot; + N + &quot;个,集合完毕!&quot;);// 第一次计量, 进入这个分支</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                flag = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int N = 10;// 计数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread[] allSoldier = new Thread[N];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean flag = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CyclicBarrier cyclicBarrier = new CyclicBarrier(N, new BarrierRun(flag, N));// barrier实例, 计数量达到指标时候则执行 BarrierRun 线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;集合队伍!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; N; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;士兵&quot; + i + &quot;报道!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            allSoldier[i] = new Thread(new Soldier(cyclicBarrier, &quot;士兵&quot; + i));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            allSoldier[i].start();// 启动一个 soldier 线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          // 当第十个启动完毕, 一次 计数量 完成, 执行一次 BarrierRun 线程, 计数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          // 恢复 10, 进行第二次 计量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1017-locksupport-线程阻塞工具类">10.1.7. LockSupport-线程阻塞工具类<a href="#1017-locksupport-线程阻塞工具类" class="hash-link" aria-label="Direct link to 10.1.7. LockSupport-线程阻塞工具类" title="Direct link to 10.1.7. LockSupport-线程阻塞工具类">​</a></h3><p>使得thread阻塞</p><p>和 Thread.suspend() 相比更好, 因为使用suspend()会挂起thread, 锁不会释放, 而且由于指令重排, resume()在suspend()前执行会造成thread永远挂起</p><p>和 Object.wait() 相比更好, 因为不需要先获得某个对象的锁</p><p>原理是使用了类似信号量的机制 (存疑)</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class LockSupportDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Object u = new Object();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static ChangeObjectThread t1 = new ChangeObjectThread(&quot;t1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static ChangeObjectThread t2 = new ChangeObjectThread(&quot;t2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class ChangeObjectThread extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public ChangeObjectThread(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            super.setName(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (u) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;in &quot; + getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                LockSupport.park();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LockSupport.unpark(t1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LockSupport.unpark(t2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t2.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="102-线程复用-线程池">10.2. 线程复用-线程池<a href="#102-线程复用-线程池" class="hash-link" aria-label="Direct link to 10.2. 线程复用-线程池" title="Direct link to 10.2. 线程复用-线程池">​</a></h2><p>类似数据路连接池</p><p>jdk提供一套 Executor 框架, 本质就是一个 thread pool</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1021-executor的api">10.2.1. Executor的api<a href="#1021-executor的api" class="hash-link" aria-label="Direct link to 10.2.1. Executor的api" title="Direct link to 10.2.1. Executor的api">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10211-创建线程池">10.2.1.1. 创建线程池<a href="#10211-创建线程池" class="hash-link" aria-label="Direct link to 10.2.1.1. 创建线程池" title="Direct link to 10.2.1.1. 创建线程池">​</a></h4><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Executors.newCachedThreadPool()：无限线程池。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Executors.newFixedThreadPool(nThreads)：创建固定大小的线程池。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Executors.newSingleThreadExecutor()：创建单个线程的线程池。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 还有一个任务调度线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 底层调用的还是 ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ThreadPoolDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class MyTask implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(System.currentTimeMillis() + &quot;Thread ID:&quot; + Thread.currentThread().getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyTask myTask = new MyTask();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int poolSize = Runtime.getRuntime().availableProcessors();// 获取CPU核心,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;poolSize=&quot; + poolSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executorService = Executors.newFixedThreadPool(poolSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 20; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executorService.submit(myTask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10212-怎么确定池子的容量">10.2.1.2. 怎么确定池子的容量<a href="#10212-怎么确定池子的容量" class="hash-link" aria-label="Direct link to 10.2.1.2. 怎么确定池子的容量" title="Direct link to 10.2.1.2. 怎么确定池子的容量">​</a></h4><p>IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2
CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10213-线程池的几个状态">10.2.1.3. 线程池的几个状态<a href="#10213-线程池的几个状态" class="hash-link" aria-label="Direct link to 10.2.1.3. 线程池的几个状态" title="Direct link to 10.2.1.3. 线程池的几个状态">​</a></h4><p>thread pool 的几个状态:</p><p>RUNNING 自然是运行状态，指可以接受任务执行队列里的任务
SHUTDOWN 指调用了 shutdown() 方法，不再接受新任务了，但是队列里的任务得执行完毕。
STOP 指调用了 shutdownNow() 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。
TIDYING 所有任务都执行完毕，在调用 shutdown()/shutdownNow() 中都会尝试更新为这个状态。
TERMINATED 终止状态，当执行 terminated() 后会更新为这个状态。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10214-关闭线程池">10.2.1.4. 关闭线程池<a href="#10214-关闭线程池" class="hash-link" aria-label="Direct link to 10.2.1.4. 关闭线程池" title="Direct link to 10.2.1.4. 关闭线程池">​</a></h4><p>无非就是两个方法 shutdown()/shutdownNow(), 但是区别大大的</p><p>shutdown() 执行后停止接受新任务，会把队列的任务执行完毕。
shutdownNow() 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> long start = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt;= 5; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pool.execute(new Job());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pool.shutdown();// 关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//每隔一秒钟检查一次是否执行完毕（是否状态为 TERMINATED），当从 while 循环退出时就表明线程池已经完全终止了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOGGER.info(&quot;线程还在执行。。。&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long end = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LOGGER.info(&quot;一共处理了【{}】&quot;, (end - start));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>优雅的关闭:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 优雅一点关闭，先通知，再等待，最后强制关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">this.executor.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.executor.awaitTermination(10, TimeUnit.SECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">this.executor.shutdownNow();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1022-threadpoolexecutor-自定义线程池">10.2.2. ThreadPoolExecutor-自定义线程池<a href="#1022-threadpoolexecutor-自定义线程池" class="hash-link" aria-label="Direct link to 10.2.2. ThreadPoolExecutor-自定义线程池" title="Direct link to 10.2.2. ThreadPoolExecutor-自定义线程池">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10221-核心-api">10.2.2.1. 核心 api<a href="#10221-核心-api" class="hash-link" aria-label="Direct link to 10.2.2.1. 核心 api" title="Direct link to 10.2.2.1. 核心 api">​</a></h4><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ThreadPoolExecutor(int corePoolSize, // 线程数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int maximumPoolSize, // 最大线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long keepAliveTime, TimeUnit unit, // 容量超过 coreSize, 空闲多长时间会被销毁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BlockingQueue&lt;Runnable&gt; workQueue,// 任务队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadFactory factory, // 线程工厂, 使用默认即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RejectedExecutionHandler handler)// 拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 对于 workQueue, 允许多种, 先进先出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - SynchronousQueue(直接提交队列) - 没有容量, 每个添加都要等待一个删除. 对于新的任务会尝试创建新的thread, 直到达到 maximumPoolSize之后执行拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - ArrayBlockingQueue(有界队列) - 带有容量. 只在容量满载时将线程数提升到 coreSize之上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - LinkedBlockingQueue(无界队列) - 类似有界队列, 容量无限(也可以定义为指定容量), 直到资源耗尽也不会执行拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - PriorityBlockingQueue(优先任务队列) - 带有容量, 有自定义顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 自定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 对于 factory, 只有一个方法, 可以实现自己的逻辑来创建 thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 对于拒绝策略 handler, 有多种</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - AbortPolicy - 直接抛异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - CallerRunsPolicy - 直接在当前thread种, 运行当前被丢弃的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - DiscardOledestPolicy - 丢弃最老的请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - DiscardPolicy - 直接丢弃, 不报异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 自定义 RejectionExecutionHandler 接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10222-阻塞队列-blockingqueue">10.2.2.2. 阻塞队列 BlockingQueue<a href="#10222-阻塞队列-blockingqueue" class="hash-link" aria-label="Direct link to 10.2.2.2. 阻塞队列 BlockingQueue" title="Direct link to 10.2.2.2. 阻塞队列 BlockingQueue">​</a></h4><p>api 提供三类操作:</p><ul><li><p>抛异常 (如果操作不能马上进行，则抛出异常)</p><p>  add(o), remove(o), element(o)</p></li><li><p>返回特定值 (如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false)</p><p>  offer(o), poll(o), peek(o)</p><p>  offer(o, timeot, unit), poll(o, timeout, unit) 如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false</p></li><li><p>阻塞 (如果操作不能马上进行，操作会被阻塞)</p><p>  put(o), take(o)</p></li></ul><p>扩展 ThreadPoolExecutor</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ExtThreadPool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class MyTask implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public MyTask(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;正在执行:Thread ID:&quot; + Thread.currentThread().getId() + &quot;,Task Name:&quot; + name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executorService = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingDeque&lt;Runnable&gt;()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            protected void beforeExecute(Thread t, Runnable r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;准备执行:&quot; + ((MyTask) r).name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            protected void afterExecute(Thread t, Runnable r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;执行完成:&quot; + ((MyTask) r).name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            protected void terminated() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;线程池退出!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 5; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MyTask task = new MyTask(&quot;TASK-GEYM-&quot; + i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executorService.execute(task);// 另一种不同于 submit() 的提交任务方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executorService.shutdown();// 温和的关闭</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10223-自定义拒绝策略">10.2.2.3. 自定义拒绝策略<a href="#10223-自定义拒绝策略" class="hash-link" aria-label="Direct link to 10.2.2.3. 自定义拒绝策略" title="Direct link to 10.2.2.3. 自定义拒绝策略">​</a></h4><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class RejectThreadPoolDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class MyTask implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(System.currentTimeMillis() + &quot;:Thread ID:&quot; + Thread.currentThread().getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyTask myTask = new MyTask();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executorService = new ThreadPoolExecutor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 5, 5,                          // 5常驻线程, 5最大线程 , 等价于固定大小线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 0L, TimeUnit.SECONDS, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 new LinkedBlockingDeque&lt;Runnable&gt;(10),// 容量10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  Executors.defaultThreadFactory()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                , new RejectedExecutionHandler() { // 自定义策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(r.toString() + &quot; is discard&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 100; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executorService.submit(myTask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10224-自定义线程池名称">10.2.2.4. 自定义线程池名称<a href="#10224-自定义线程池名称" class="hash-link" aria-label="Direct link to 10.2.2.4. 自定义线程池名称" title="Direct link to 10.2.2.4. 自定义线程池名称">​</a></h4><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 命名线程工厂</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class NamedThreadFactory implements ThreadFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final AtomicInteger poolNumber = new AtomicInteger(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final ThreadGroup group;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final AtomicInteger threadNumber = new AtomicInteger(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private final String namePrefix;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        NamedThreadFactory(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SecurityManager s = System.getSecurityManager();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (null == name || name.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                name = &quot;pool&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            namePrefix = name + &quot;-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Thread newThread(Runnable r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (t.isDaemon())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                t.setDaemon(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (t.getPriority() != Thread.NORM_PRIORITY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                t.setPriority(Thread.NORM_PRIORITY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ThreadPoolExecutor executorOne = new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new LinkedBlockingQueue&lt;&gt;(), new NamedThreadFactory(&quot;ASYN-ACCEPT-POOL&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="10225-自定义线程-名称">10.2.2.5. 自定义线程 名称<a href="#10225-自定义线程-名称" class="hash-link" aria-label="Direct link to 10.2.2.5. 自定义线程 名称" title="Direct link to 10.2.2.5. 自定义线程 名称">​</a></h4><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ThreadFactory factory = new ThreadFactory() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自定义 thread name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final AtomicInteger seq = new AtomicInteger();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Thread newThread(Runnable r) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t = new Thread(r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.setName(&quot;rpc-&quot; + seq.getAndIncrement());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 闲置时间超过30秒的线程自动销毁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">this.executor = new ThreadPoolExecutor(1, coreSize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        30, TimeUnit.SECONDS, queue, factory,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new ThreadPoolExecutor.CallerRunsPolicy());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1023-无锁安全的队列">10.2.3. 无锁安全的队列<a href="#1023-无锁安全的队列" class="hash-link" aria-label="Direct link to 10.2.3. 无锁安全的队列" title="Direct link to 10.2.3. 无锁安全的队列">​</a></h3><p>ConcurrentLinkedQueue</p><p>TODO</p><p><a href="https://blog.csdn.net/qq_38293564/article/details/80798310" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_38293564/article/details/80798310</a></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1024-拓展线程池-在线程池中寻找堆栈">10.2.4. 拓展线程池-在线程池中寻找堆栈<a href="#1024-拓展线程池-在线程池中寻找堆栈" class="hash-link" aria-label="Direct link to 10.2.4. 拓展线程池-在线程池中寻找堆栈" title="Direct link to 10.2.4. 拓展线程池-在线程池中寻找堆栈">​</a></h3><p>线程池会吃掉线程抛出的异常, 看看这个例子</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class NoTraceDivTaskDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class DivTask implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int a, b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public DivTask(int a, int b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.a = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.b = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            double re = a / b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(re);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 0L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 5; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*poolExecutor.submit(new DivTask(100, i));*/ //没有报错提示,  但是 i=0 时明显除数不能为0应该报错;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            poolExecutor.execute(new DivTask(100, i));//通过execute()提交任务, 有报错提示</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        输出了结果, 但是只有4行结果, 正常的话应该有5行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>更好的改进方法是直接拓展 线程池</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class TraceThreadPoolExecutor extends ThreadPoolExecutor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public TraceThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 也可以覆盖 submit方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void execute(Runnable task) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.execute(wrap(task, clientTrace(), Thread.currentThread().getName()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Runnable wrap(final Runnable task, final Exception clientTrace, String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    task.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    clientTrace.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Exception clientTrace() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Exception(&quot;Client stack trace&quot;);// 保存着提交任务的线程的堆栈信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TraceDivTaskDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadPoolExecutor threadPoolExecutor = new TraceThreadPoolExecutor(0, Integer.MAX_VALUE, 0L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 5; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threadPoolExecutor.execute(new NoTraceDivTaskDemo.DivTask(100, i));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1025-fork-join框架">10.2.5. Fork-Join框架<a href="#1025-fork-join框架" class="hash-link" aria-label="Direct link to 10.2.5. Fork-Join框架" title="Direct link to 10.2.5. Fork-Join框架">​</a></h3><p>类似 MapReduce</p><p>jdk提供一个 <code>ForkJoinPool</code> 线程池, 对于 fork() 并不急于分叉出新的 线程, 而是将新任务提交给 ForkJoinPool ; 这样, 提交的任务数可能远远大于实际线程数, 每个线程拥有一个任务队列容纳任务, 每次从队列头部获取任务执行, 如果这个 线程将队列任务全部完成, 会去帮助其他线程 ---- 从其他 thread 的任务队列尾部获取任务执行</p><p>ForkJoinPool 提供一个方法 submit, 提交 <code>ForkJoinTask</code> 任务(这种任务支持 form()分解和 join()等待), 它包含2个子类 <code>RecursiveAction</code> (无返回值任务) 和 <code>RecursiveTask</code> (有返回值任务)</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class CountTask extends RecursiveTask {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int THRESHOLD = 10000;// 超过这个分界点, 就使用 任务分解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CountTask(long start, long end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.start = start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.end = end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Long compute() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long sum = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean canCompute = (end - start) &lt; THRESHOLD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (canCompute) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (long i = start; i &lt;= end; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sum += i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            long step = (start + end) / 100;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ArrayList&lt;CountTask&gt; subTasks = new ArrayList&lt;CountTask&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            long pos = start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; 100; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                long lastOne = pos + step;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (lastOne &gt; end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lastOne = end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                CountTask subTask = new CountTask(pos, lastOne);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                pos += step + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                subTasks.add(subTask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                subTask.fork();// 提交子任务, 类似递归调用, 若调用层次太深, 可能会栈溢出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (CountTask t : subTasks) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sum += (Long) t.join();// 等待所有子任务结束, 求和</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return sum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountTask task = new CountTask(0, 200000L);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = result.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;sum=&quot; + res);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (ExecutionException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1026-springboot中使用线程池">10.2.6. springboot中使用线程池<a href="#1026-springboot中使用线程池" class="hash-link" aria-label="Direct link to 10.2.6. springboot中使用线程池" title="Direct link to 10.2.6. springboot中使用线程池">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1027-hystrix-线程池隔离">10.2.7. hystrix-线程池隔离<a href="#1027-hystrix-线程池隔离" class="hash-link" aria-label="Direct link to 10.2.7. hystrix-线程池隔离" title="Direct link to 10.2.7. hystrix-线程池隔离">​</a></h3><h2 class="anchor anchorWithStickyNavbar_LWe7" id="103-jdk中的并发容器">10.3. jdk中的并发容器<a href="#103-jdk中的并发容器" class="hash-link" aria-label="Direct link to 10.3. jdk中的并发容器" title="Direct link to 10.3. jdk中的并发容器">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1031-整体介绍">10.3.1. 整体介绍<a href="#1031-整体介绍" class="hash-link" aria-label="Direct link to 10.3.1. 整体介绍" title="Direct link to 10.3.1. 整体介绍">​</a></h3><ul><li><p>ConcurrentHashMap - 安全的 hashmap</p></li><li><p>CopyOnWriteArrayList - 安全的 arraylist, 适合读多写少的场景, 性能远远好于 Vector</p></li><li><p>ConcurrentLinkedQueue - 安全的LinkedList, 链表实现</p></li><li><p>BlockingQueue - 阻塞队列, 作为数据共享的通道</p></li><li><p>ConcurrentSkipListMap - 跳表的实现</p></li></ul><p>另外 , Collections 工具类可以将任意集合包装为安全的集合, 当然性能就差远了</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1032-concurrentlinkedqueue原理">10.3.2. ConcurrentLinkedQueue原理<a href="#1032-concurrentlinkedqueue原理" class="hash-link" aria-label="Direct link to 10.3.2. ConcurrentLinkedQueue原理" title="Direct link to 10.3.2. ConcurrentLinkedQueue原理">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1033-开源高性能内存队列-disruptor">10.3.3. 开源高性能内存队列 disruptor<a href="#1033-开源高性能内存队列-disruptor" class="hash-link" aria-label="Direct link to 10.3.3. 开源高性能内存队列 disruptor" title="Direct link to 10.3.3. 开源高性能内存队列 disruptor">​</a></h3><p><a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2016/11/18/disruptor.html</a>
<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener noreferrer">https://github.com/LMAX-Exchange/disruptor</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="104-aqs-无锁实现">10.4. aqs 无锁实现<a href="#104-aqs-无锁实现" class="hash-link" aria-label="Direct link to 10.4. aqs 无锁实现" title="Direct link to 10.4. aqs 无锁实现">​</a></h2><p><a href="https://www.jianshu.com/p/7b0e11a1e605" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/7b0e11a1e605</a> //todo</p><h1>11. java8中的新特性</h1><p>check {% post_link java-note 📚 java-note %}中的 #java8</p><h1>12. 怎么优化锁</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="121-提高锁性能的原则">12.1. 提高锁性能的原则<a href="#121-提高锁性能的原则" class="hash-link" aria-label="Direct link to 12.1. 提高锁性能的原则" title="Direct link to 12.1. 提高锁性能的原则">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1211-减少锁持有时间-和锁粗化-需要权衡">12.1.1. 减少锁持有时间-和锁粗化-需要权衡<a href="#1211-减少锁持有时间-和锁粗化-需要权衡" class="hash-link" aria-label="Direct link to 12.1.1. 减少锁持有时间-和锁粗化-需要权衡" title="Direct link to 12.1.1. 减少锁持有时间-和锁粗化-需要权衡">​</a></h3><p>减少锁持有时间就是说，将被同步方法拆分， 只锁定原方法的一部分</p><p>比如 一个同步方法可以分成三个小方法, 只有一个或两个小方法需要同步, 则同步块可以缩小到小方法上, 这样整个大方法持有锁的时间就缩短了</p><p>但是减少是有限度的, 如果频繁进行锁请求和释放, 也会消耗系统资源, 所以 jvm 在碰到这种情况时会合并锁请求, like this: (但是我们应该有意识地主动优化)</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static void test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    synchronized (lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do sth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    doSth();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    synchronized(lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do sth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 会被jvm优化成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static void test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    synchronized (lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do sth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doSth();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do sth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt; 100; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    synchronized(lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do sth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 应该改成这样</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">synchronized(lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; 100; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do sth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1212-减小锁粒度">12.1.2. 减小锁粒度<a href="#1212-减小锁粒度" class="hash-link" aria-label="Direct link to 12.1.2. 减小锁粒度" title="Direct link to 12.1.2. 减小锁粒度">​</a></h3><p>缩小锁定对象范围, 通过拆分被锁定对象的数据结构， 缩小锁定范围</p><p>典型如 ConcurrentHashMap 的实现</p><p>要保证hashmap的线程安全, 最粗略的方法就是对整个 hashmap加锁, 但是这样做就锁粒度太大;</p><p>实际上的实现是这样的, ConcurrentHashMap 内部进一步细分为多个 hashmap,称之为 &quot;segment&quot;, 一个 ConcurrentHashMap默认分成了 16 个 segment, 也就是说有可能同时支持 16 个 thread 并行插入元素; 如果想向 map 中添加 entry, 并不是将整个 map 加锁, 而是根据 entry 计算得出的 hashcode 得到 该entry 会被存入 哪个 segment, 然后对该 segment 加锁, 随之完成 put()操作, </p><p>但是减小锁粒度会引入新的问题: 要访问全局信息, 这是需要取得全局锁, 消耗的资源比较多; 如 ConcurrentHashMap 中想要取得 size 信息时候, 需要获取 所有 segment 的锁, 得到 size 后, 释放所有锁;</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1213-读写分离锁代替独占锁">12.1.3. 读写分离锁代替独占锁<a href="#1213-读写分离锁代替独占锁" class="hash-link" aria-label="Direct link to 12.1.3. 读写分离锁代替独占锁" title="Direct link to 12.1.3. 读写分离锁代替独占锁">​</a></h3><p>使用读写分离锁</p><p>这样当两个thread都是read操作时， 不会阻塞</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1214-锁分离">12.1.4. 锁分离<a href="#1214-锁分离" class="hash-link" aria-label="Direct link to 12.1.4. 锁分离" title="Direct link to 12.1.4. 锁分离">​</a></h3><p>典型如 LinkedBlockingQueue 的实现, 提供 put() 从队列尾部添加, take() 从队列头部获取, 这两个操作都需要获取队列的锁</p><p>如果使用 &quot;独占锁&quot;, 那么put 和 take 就不能实现并行执行;</p><p>jdk真正的实现是, 使用两个不同的锁 takeLock 和 putLock (两个不同的 ReentrantLock), 分离 put, take 操作. 因此take和put 操作不存在锁竞争关系, 只有当个2个thread 是 put-put 关系, 或者是 take-take关系时候才有竞争关系</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="122-jvm是怎么对锁优化的">12.2. jvm是怎么对锁优化的<a href="#122-jvm是怎么对锁优化的" class="hash-link" aria-label="Direct link to 12.2. jvm是怎么对锁优化的" title="Direct link to 12.2. jvm是怎么对锁优化的">​</a></h2><p>这里所说的锁都是jvm的优化手段, 不是真正的语言上的锁</p><p>下面几个jvm的优化手段是循序渐进的, 一个thread真正被挂起之前, 会依次尝试如下的手段</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1221-使锁进入偏向模式-偏向锁">12.2.1. 使锁进入偏向模式-偏向锁<a href="#1221-使锁进入偏向模式-偏向锁" class="hash-link" aria-label="Direct link to 12.2.1. 使锁进入偏向模式-偏向锁" title="Direct link to 12.2.1. 使锁进入偏向模式-偏向锁">​</a></h3><p>使用jvm参数: <code>-XX:+UsedBiasedLocking</code> 开启偏向锁</p><p>核心思想是: jvm开启偏向锁的情况下, 一个thread一旦获取锁, 这个锁就进入偏向模式(即这个锁偏向这个thread), 当同一个 thread 再次请求该锁时, 无需再次做任何同步操作, 这样就<code>节省了很多锁申请的操作</code></p><p>场景: 对于锁竞争很少的场景很有效 - 因为 同一个 thread 可能多次请求相同的锁; 如果时锁竞争激烈的场合, 每次都是不同的 thread请求相同的锁, 偏向模式就失效了</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1222-使用轻量级锁">12.2.2. 使用轻量级锁<a href="#1222-使用轻量级锁" class="hash-link" aria-label="Direct link to 12.2.2. 使用轻量级锁" title="Direct link to 12.2.2. 使用轻量级锁">​</a></h3><p><a href="https://blog.csdn.net/shuaicenglou3032/article/details/77170068" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/shuaicenglou3032/article/details/77170068</a></p><p>轻量级锁主要思想是: 提供了一种新的判断 thread是否持有锁的判断方式 - 如果加锁对象的头部存在指针指向某个 thread , 则这个thread 拥有这个锁</p><p>当 偏向锁 失效, jvm 不会立即挂起 thread, 而是会判断thread是否拥有 轻量级锁, 如果拥有, 则顺利进入 临界区, 如果没有拥有, 则膨胀为重量级锁</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1223-自旋锁">12.2.3. 自旋锁<a href="#1223-自旋锁" class="hash-link" aria-label="Direct link to 12.2.3. 自旋锁" title="Direct link to 12.2.3. 自旋锁">​</a></h3><p>锁膨胀后, jvm还会做最后的努力: 自旋锁 -     jvm会让 即将被挂起的thread 做几个空循环, 在经过几次循环后, 如果这个锁能够被获取了, 就顺利进入临界区, 如果还是不能获取   , 才会真正将 thread 挂起</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1224-锁消除">12.2.4. 锁消除<a href="#1224-锁消除" class="hash-link" aria-label="Direct link to 12.2.4. 锁消除" title="Direct link to 12.2.4. 锁消除">​</a></h3><p><code>-XX:+EliminateLocks</code> 打开jvm锁消除功能</p><p>jvm会在编译时, 对上下文扫描, 去除掉不可能存在资源竞争的锁, 比如: Vector 作为方法内的局部变量, 实在线程栈上分配空间的, 属于thread私有, 不会出现线程安全问题, 所以 Vecotr 中的 锁是没有必要的, jvm会在编译时消除这些锁</p><p>逃逸分析
<code>-XX:+DoEscapeAnalysis</code></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="123-threadlocal">12.3. ThreadLocal<a href="#123-threadlocal" class="hash-link" aria-label="Direct link to 12.3. ThreadLocal" title="Direct link to 12.3. ThreadLocal">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1231-threadlocal概念">12.3.1. threadlocal概念<a href="#1231-threadlocal概念" class="hash-link" aria-label="Direct link to 12.3.1. threadlocal概念" title="Direct link to 12.3.1. threadlocal概念">​</a></h3><p>根据字面意思理解就是 &quot;线程本地的&quot;, 每个线程拥有自己的变量, 其他线程无法访问;</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1232-threadlocal-示例">12.3.2. threadLocal 示例<a href="#1232-threadlocal-示例" class="hash-link" aria-label="Direct link to 12.3.2. threadLocal 示例" title="Direct link to 12.3.2. threadLocal 示例">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * ThreadLocal  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2017年9月2日 下午5:15:54</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">结果:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">init value: false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thread1 value: true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thread2 value: null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ThreadLocal&lt;Boolean&gt; threadLocal = new ThreadLocal&lt;Boolean&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Client client = new Client();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final ThreadLocal&lt;Boolean&gt; threadLocal = client.getThreadLocal();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        threadLocal.set(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;init value: &quot; + threadLocal.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                threadLocal.set(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;thread1 value: &quot; + threadLocal.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).start();;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;thread2 value: &quot; + threadLocal.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).start();;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以看出不同的thread访问同一个threadLocal, 结果不同;</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1233-再看一个问题例子以及改进">12.3.3. 再看一个问题例子以及改进<a href="#1233-再看一个问题例子以及改进" class="hash-link" aria-label="Direct link to 12.3.3. 再看一个问题例子以及改进" title="Direct link to 12.3.3. 再看一个问题例子以及改进">​</a></h3><p>为每个线程准备一份变量</p><p>下面这个demo会异常:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ParseDateDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //private static ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;(); // 更好的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class ParseDate implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public ParseDate(int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.i = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Date date = sdf.parse(&quot;2017-05-06 12:33:&quot; + i % 60);// 这个方法不是安全的, 一个可行的改进方法是前后加锁,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               //但是更好的方法是为每个 thread准备一个 SimpleDateFormat</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // if (threadLocal.get() == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //     threadLocal.set(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Date date = threadLocal.get().parse(&quot;2017-05-06 12:33:&quot; + i % 60);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(i + &quot;:&quot; + date);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (ParseException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executorService = Executors.newFixedThreadPool(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 1000; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executorService.execute(new ParseDate(i));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1234-原理">12.3.4. 原理<a href="#1234-原理" class="hash-link" aria-label="Direct link to 12.3.4. 原理" title="Direct link to 12.3.4. 原理">​</a></h3><p>Thread 内部有个成员 <code>ThreadLocalMap</code>, 类似 hashmap, key为 &quot;当前线程访问的 threadlocal对象&quot;, value 为 &quot;threadLocal保存的值&quot;, </p><p><code>ThreadLocalMap</code> 保存了当前线程的所有 &quot;线程局部变量&quot; - 也就是说, 所谓的 &quot;线程局部变量&quot; 是维护在 Thread内部的, 只要这个线程不退出, &quot;线程局部变量&quot; 将永远存在. Thread 退出, 将进行 ThreadLocalMap的清理.</p><p>使用完毕的 ThreadLocal, 记得进行清理 - 因为线程可能永远不会退出(比如使用了固定容量的线程池, tomcat 就使用了线程池处理请求), 线程内部将永远维护 &quot;线程局部变量&quot;, 所以应该手动清除</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1235-看源码">12.3.5. 看源码<a href="#1235-看源码" class="hash-link" aria-label="Direct link to 12.3.5. 看源码" title="Direct link to 12.3.5. 看源码">​</a></h3><ul><li><p>一个 Thread 中存在一个 ThreadLocalMap field，ThreadLocalMap中的 key 是一个 Weakreference， 指向ThreadLocal，value代表通过Thread Local存储的变量。</p></li><li><p>ThreadLocalMap 可以存储多个 key(即ThreadLocal)， 也就是说同一个 Thread 可以设置多个 “本地线程变量”</p></li><li><p>为什么不同的线程访问同一个ThreadLocal，得到的确是不同的数值, 因为不同的thread内部维护了不同的threadLocalMap; &quot;本地线程变量&quot; 实际上还是保存在 Thread 自身内部</p></li></ul><p>先看看整体的示意图</p><p>从ThreadLocal#set进入, 看看实现:</p><p>片段1</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">     // 将指定的值设置进当前线程的threadLocal中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void set(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据当前线程获取 ThreadLocalMap, 可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //以猜测 ThreadLocalMap大概是一个存储键值对的容器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //片段2是ThreadLocalMap的类结构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadLocalMap map = getMap(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (map != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果获取到了, 设置一个键值对, key 为当前线程所访问的 ThreadLocal,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // value 为 存储的值. 从这里进入, 看看ThreadLocalMap#set 的实现, 见 片段3; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            map.set(this, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果没有获取到map, 初始化一个: 根据 当前</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //线程 (第一个参数)获取到线程内部的threadLocalMap, 将键值对[threadLocal, value] 存入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            createMap(t, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>片段2: ThreadLocalMap的类结构</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static class ThreadLocalMap {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Entry类继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，即每个Entry对象都</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //有一个ThreadLocal的弱引用作为key，这是为了防止内存泄露。一旦</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //线程结束，外部的 threadLocal 引用被设置为 null , 则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里的key 看似仍旧指向 ThreadLocal 对象, 实际上这个指向无</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //效, ThreadLocal直接变为一个不可达的对象，这个Entry就可以被回收了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /** The value associated with this ThreadLocal. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                super(k);// 将 k 作为 &quot;弱引用&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                value = v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ThreadLocalMap 的初始容量，必须为2的倍数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static final int INITIAL_CAPACITY = 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // resized时候需要的table</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Entry[] table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // table中的entry个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 扩容数值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int threshold; // Default to 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Construct a new map initially containing (firstKey, firstValue).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * ThreadLocalMaps are constructed lazily, so we only create</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * one when we have at least one entry to put in it.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         构造函数, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 初始容量为16的entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            table = new Entry[INITIAL_CAPACITY];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 计算 firstKey 的hashcode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 存储到 table 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            table[i] = new Entry(firstKey, firstValue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            size = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setThreshold(INITIAL_CAPACITY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>片段3: ThreadLocalMap#set 的实现</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void set(ThreadLocal&lt;?&gt; key, Object value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int len = tab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = key.threadLocalHashCode &amp; (len-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遍历 table, 为table 中的每个匹配上key(threadLocal) 的entry设置value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry e = tab[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e != null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = tab[i = nextIndex(i, len)]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadLocal&lt;?&gt; k = e.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (k == key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (k == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            replaceStaleEntry(key, value, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tab[i] = new Entry(key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int sz = ++size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) // cleanSomeSlots的作用主要是清理无用的entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rehash();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果Entry在存放过程中冲突了，调用nextIndex来处理，如下所示。hashmap中对冲突的处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static int nextIndex(int i, int len) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ((i + 1 &lt; len) ? i + 1 : 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>看看 ThreadLocal#get 的实现</p><p>code4</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public T get() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread t = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取 thread对应的ThreadLocalMap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ThreadLocalMap map = getMap(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (map != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            T result = (T)e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return setInitialValue(); // 如果map 为null, 跟进看看, 见code5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>code5</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private T setInitialValue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    T value = initialValue(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread t = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ThreadLocalMap map = getMap(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (map != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.set(this, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        createMap(t, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return value; //  返回值见initialValue()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected T initialValue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;// 如果不设置ThreadLocal的数值，默认就是null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="124-weakreference">12.4. weakReference<a href="#124-weakreference" class="hash-link" aria-label="Direct link to 12.4. weakReference" title="Direct link to 12.4. weakReference">​</a></h2><p>weakReference 并不能解决多线程的安全问题, 这里只是 ThreadLocal的源码中, 跟到内部类 ThreadLocalMap 里, 在类结构里发现了 WeakReference</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1241-什么是weakreference">12.4.1. 什么是WeakReference<a href="#1241-什么是weakreference" class="hash-link" aria-label="Direct link to 12.4.1. 什么是WeakReference" title="Direct link to 12.4.1. 什么是WeakReference">​</a></h3><p>jdk 文档: <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/7/docs/api/java/lang/ref/WeakReference.html</a></p><p>一个弱引用(WeakReference) 指向一个对象 o, GC可以随时回收对象 o, 不管这个指向是否存在</p><p>假设垃圾收集器在某个时间点决定一个对象是弱可达的(weakly reachable)（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后垃圾收集器会把这个弱可达对象标记为可终结(finalizable)的，这样它们随后就会被回收。而这些没用的弱引用对象会加入 引用队列(Reference Queue), 方便集中处理</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1242-为什使用">12.4.2. 为什使用<a href="#1242-为什使用" class="hash-link" aria-label="Direct link to 12.4.2. 为什使用" title="Direct link to 12.4.2. 为什使用">​</a></h3><p>现在有这样一个需求:</p><p>类 User 被标记为 final, 不可拓展, 但是现在需要为每个 user增加一个属性: 编号, 可行的方案是 使用 HashMap&lt;User, Integer&gt;, 但是可能会造成内存泄漏; 因为如果某个user被删除了, 内存中也就不再需要这个user指向的对象了, 指定 user=null (实际上可能不必这样显式的指定), 但是还有引用指向User对象: hashMap中的引用. 所以要想真正的回收User对象, 仅仅把它的强引用赋值为null是不够的，还要把相应的条目从HashMap中移除. 回收一个对象需要清除两处引用, 这不符合人的直觉.
这时 弱引用 就有用处了: 用一个指向User对象的弱引用作为hashMap的key就行了</p><p>此外, app使用缓存(cache)时, 由于cache的对象正是程序运行需要的, 那么只要程序正在运行, cache中的引用就不会被回收, 如果需要回收, 必须交给编写者手动回收, 而这显然背离了GC的本质, 这时也可以引入弱引用;</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1243-怎么使用">12.4.3. 怎么使用<a href="#1243-怎么使用" class="hash-link" aria-label="Direct link to 12.4.3. 怎么使用" title="Direct link to 12.4.3. 怎么使用">​</a></h3><p>首先看一个简单的示例</p><p>User实体类</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @date 2017年9月2日</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String password;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>测试类</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * weakReference client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @version 0.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @author xy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">结果:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过weakReference获取到User: User(password=null, name=null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过weakReference获取到User: User(password=null, name=null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">通过weakReference获取到User: User(password=null, name=null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">User 被回收了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        User user = new User();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WeakReference&lt;User&gt; weakReferenceOfUser = new WeakReference&lt;User&gt;(user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(true) { // 进入循环, 强引用user已经没有被使用了, 相当于已经失效了; 如果在这个循环体中使用到了 强引用user, 则User对象不会被回收, 循环永远不会结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            User userFromWeakReference = weakReferenceOfUser.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (userFromWeakReference != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;通过weakReference获取到User: &quot; + userFromWeakReference);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;User 被回收了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>WeakReference的一个特点是它何时被回收是不可确定的, 因为这是由GC运行的不确定性所确定的. 所以, 一般用weak reference引用的对象是有价值被cache, 而且很容易被重新被构建, 且很消耗内存的对象</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1244-四种引用">12.4.4. 四种引用<a href="#1244-四种引用" class="hash-link" aria-label="Direct link to 12.4.4. 四种引用" title="Direct link to 12.4.4. 四种引用">​</a></h3><p>实际上 Java中存在四种引用:</p><ul><li><p>Strong Reference</p><p>最常用, 通过new创建对象返回的引用</p></li><li><p>SoftReference</p><p>SoftReference 和 Weak Reference 的区别在于: 软引用指向的对象只有在内存不足时才会被回收, 而弱引用无论内存是否充足都会被回收</p></li><li><p>Weak Reference</p></li><li><p>PhantomRefrence</p><p>最&quot;弱&quot;的引用, 通过它连对象都无法获取, 唯一作用就是通过指向一个对象, 当这个对象被回收, 虚引用会被加入到 引用队列(ReferenceQueue), 用于记录指向的对象已经被回收;</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1245-referencequeue">12.4.5. ReferenceQueue<a href="#1245-referencequeue" class="hash-link" aria-label="Direct link to 12.4.5. ReferenceQueue" title="Direct link to 12.4.5. ReferenceQueue">​</a></h3><p>在weak reference指向的对象被回收后, weak reference本身也就没有用了. ReferenceQueue可以保存这些所指向的对象已经被回收的reference. 用法见第二个构造函数</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">WeakReference(T referent) //创建一个指向给定对象的弱引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) //创建一个指向给定对象并且登记到给定引用队列的弱引用</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1246-weakhashmap--treadlocalmap">12.4.6. WeakHashMap &amp; TreadLocalMap<a href="#1246-weakhashmap--treadlocalmap" class="hash-link" aria-label="Direct link to 12.4.6. WeakHashMap &amp; TreadLocalMap" title="Direct link to 12.4.6. WeakHashMap &amp; TreadLocalMap">​</a></h3><p>两者原理有相似, 放在这里比较;</p><p>TreadLocalMap是ThreadLocal的一个内部类, 源码分析过了, 见 {% post_link ThreadLocal理解 这里 %};</p><p>WeakHashMap 里的entry可能会被GC自动删除如果没有额外的强引用指向entry中的key，即使我没有调用remove()或者clear()方法; 这个特点特别适用于需要缓存的场景. 在使用缓存时肯定不能缓存所有对象；对象缓存命中最好，但缓存没命中也不会造成错误，因为可以通过计算重新得到</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="125-不加锁-乐观锁">12.5. 不加锁-乐观锁<a href="#125-不加锁-乐观锁" class="hash-link" aria-label="Direct link to 12.5. 不加锁-乐观锁" title="Direct link to 12.5. 不加锁-乐观锁">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1251-怎么理解不加锁的策略">12.5.1. 怎么理解不加锁的策略<a href="#1251-怎么理解不加锁的策略" class="hash-link" aria-label="Direct link to 12.5.1. 怎么理解不加锁的策略" title="Direct link to 12.5.1. 怎么理解不加锁的策略">​</a></h3><p>加锁是一种 &quot;悲观策略&quot;, 这种策略总是假设临界区的 并发冲突一定会存在, 所以一定要加锁</p><p>&quot;无锁&quot; 是 一种 &quot;乐观策略&quot;, 这种策略假设临界区不会有冲突发生, 自然无需加锁 , 也就无阻塞(天然免疫死锁问题), 但是万一碰到了冲突怎么办呢 -- 使用 CAS(compare and swap)技术, 思路是: 比较然后交换, 一旦检测到冲突, 就循环重试直到没有冲突为止</p><p>优点: 📌 没有锁竞争带来的系统开销; 📌 没有线程切换带来的开销</p><p>具体算法: 一个 cas操作 包含三个参数 CAS(v, e, n), v-待更新的变量, e-变量v的预期值, n-新的值. 只有当 v == e, 才会设置 v = n, 如果 v != e, 说明更新操作期间有其他线程修改了 v 的值, 则当前thread 的 cas操作失败, 但是失败线程不会被挂起, 只是被告知失败, 为了保证成功, 一般都会写一个死循环, 只得到成功后跳出; 在大部分封装好的类库种 只需要传入 v, n即可</p><p>硬件上, 大部分 cpu 都支持 原子化的 cas操作了</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1252-atomicinteger-无锁安全整数">12.5.2. AtomicInteger-无锁安全整数<a href="#1252-atomicinteger-无锁安全整数" class="hash-link" aria-label="Direct link to 12.5.2. AtomicInteger-无锁安全整数" title="Direct link to 12.5.2. AtomicInteger-无锁安全整数">​</a></h3><p>相比于 Integer, AtomicInteger 是可变的</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class AtomicIntegerDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static AtomicInteger i = new AtomicInteger();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class AddThread implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 0; j &lt; 10000; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i.incrementAndGet();// 使用 cas操作 将自己加1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread[] threads = new Thread[10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; 10; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threads[j] = new Thread(new AddThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; 10; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threads[j].start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int j = 0; j &lt; 10; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threads[j].join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(i);// 正常输出 100000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1253-unsafe类-java中的指针">12.5.3. Unsafe类-Java中的指针<a href="#1253-unsafe类-java中的指针" class="hash-link" aria-label="Direct link to 12.5.3. Unsafe类-Java中的指针" title="Direct link to 12.5.3. Unsafe类-Java中的指针">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1254-atomicreference-无锁的对象引用">12.5.4. AtomicReference-无锁的对象引用<a href="#1254-atomicreference-无锁的对象引用" class="hash-link" aria-label="Direct link to 12.5.4. AtomicReference-无锁的对象引用" title="Direct link to 12.5.4. AtomicReference-无锁的对象引用">​</a></h3><p>类似 atomicinteger, 但是更具普遍性, AtomicInteger 是对 Intege对象的封装, AtomicReference 是对普通的对象引用的封装</p><p>线程判断被修改对象是否可以被写入, 条件是对象的当前值是否等于期望值(即修改操作前获取的对象值)</p><p>但是考虑一个场景: 当线程在判断是否可以写入时, 另外的某个thread将对象连续修改了2次, 第一次修改为某个值, 第二次又改回来了, 就像什么也没有修改一样, 那么当前线程就判断可以正常写入 - bug由此产生.看下面的demo: 给某个账户里充值代金券, 且只充值1次</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class AtomicRefrenceDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final AtomicReference&lt;Integer&gt; money = new AtomicReference&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        money.set(19);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 开启100个赠送代金卷进程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 100; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Integer m = money.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (m &lt; 20) { // 小于 20 则充值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (money.compareAndSet(m, m + 20)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                System.out.println(&quot;余额小于20元,充值成功,余额:&quot; + money.get() + &quot;元&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;余额大于20,无需充值&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 开启一个消费进程, 但是内部循环100次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 考虑这种场景: 账户已经被充值了一次, 这时有一个充值thread访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            了账户, 正准备判断是否可以正常写入, 消费thread 连续消费</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            了20元, 赠送thread会误认为这个账户没有被赠送过 , 会再次赠送</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        - 原因: 账户余额被多个thread反复修改, 最终恢复成原样, 使得 cas 操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            无法准确判断是否可以写入; ------ AtomicStampedReference 可以很好的解决</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int i = 0; i &lt; 100; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Integer m = money.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (m &gt; 10) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;金额大于10元&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (money.compareAndSet(m, m - 10)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                System.out.println(&quot;成功消费10元,余额:&quot; + money.get() + &quot;元&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;没有足够的金额&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1255-atomicstampedreference-带时间戳的引用">12.5.5. AtomicStampedReference-带时间戳的引用<a href="#1255-atomicstampedreference-带时间戳的引用" class="hash-link" aria-label="Direct link to 12.5.5. AtomicStampedReference-带时间戳的引用" title="Direct link to 12.5.5. AtomicStampedReference-带时间戳的引用">​</a></h3><p>AtomicStampedReference 内部不经维护了对象值, 还由一个时间戳, 当对象值被修改, 时间戳也相应变化, cas操作判断是否可以写入时, 对象值和时间戳都必须符合期望值, 才会写入成功</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class AtomicStampedReferenceDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static AtomicStampedReference&lt;Integer&gt; money = new AtomicStampedReference&lt;Integer&gt;(19, 0);// 0 表示初始时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 100; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final int timestap = money.getStamp();// 获得时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Integer m = money.getReference();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (m &lt; 20) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 每次写入, 时间戳也要修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (money.compareAndSet(m, m + 20, timestap, timestap + 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                System.out.println(&quot;余额小于20元,充值成功,余额:&quot; + money.getReference() + &quot;元&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;余额大于20,无需充值&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int i = 0; i &lt; 100; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        int timestap = money.getStamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Integer m = money.getReference();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (m &gt; 10) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;金额大于10元&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (money.compareAndSet(m, m - 10, timestap, timestap + 1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                System.out.println(&quot;成功消费10元,余额:&quot; + money.getReference() + &quot;元&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            System.out.println(&quot;没有足够的金额&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1256-atomicintegerarray-无锁的数组">12.5.6. AtomicIntegerArray-无锁的数组<a href="#1256-atomicintegerarray-无锁的数组" class="hash-link" aria-label="Direct link to 12.5.6. AtomicIntegerArray-无锁的数组" title="Direct link to 12.5.6. AtomicIntegerArray-无锁的数组">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class AtomicInterArrayDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 声明数组, 长度10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static AtomicIntegerArray array = new AtomicIntegerArray(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class AddThread implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = 0; i &lt; 10000; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                array.getAndIncrement(i % array.length());//每个元素各加1000次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread[] threads = new Thread[10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threads[i] = new Thread(new AddThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threads[i].start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threads[i].join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(array);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1257-atomicintegerfieldupdater-升级普通变量支持原子操作">12.5.7. AtomicIntegerFieldUpdater-升级普通变量支持原子操作<a href="#1257-atomicintegerfieldupdater-升级普通变量支持原子操作" class="hash-link" aria-label="Direct link to 12.5.7. AtomicIntegerFieldUpdater-升级普通变量支持原子操作" title="Direct link to 12.5.7. AtomicIntegerFieldUpdater-升级普通变量支持原子操作">​</a></h3><p>Integer, Long, 普通对象引用 都有自己的 updater, 用来支持 cas操作</p><ul><li>updater 只能修改自己可见范围内的变量, 比如 下面的 score 如果时 private 的, 就不行</li><li>变量必须是 volatile 的, 这是为了保证变量总是能被读取到</li><li>updater 不支持 static 的变量 - 这是因为 cas操作会通过对象实例中的偏移量直接进行赋值, static的变量不再对象实例中</li></ul><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 模拟选举</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AtomicIntegerFieldUpdaterDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class Candidate {// 候选人</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile int score;// 并非线程安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 针对 Candidate 类的 score 成员的  updater</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public final static AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, &quot;score&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static AtomicInteger allScore = new AtomicInteger(0);// 这个变量用来验证实验结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final Candidate stu = new Candidate();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread[] t = new Thread[10000];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10000; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            t[i] = new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (Math.random() &gt; 0.4) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        scoreUpdater.incrementAndGet(stu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        allScore.incrementAndGet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            t[i].start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10000; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            t[i].join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;score=&quot; + stu.score);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;allScore=&quot; + allScore);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1258-synchronousqueue实现">12.5.8. SynchronousQueue实现<a href="#1258-synchronousqueue实现" class="hash-link" aria-label="Direct link to 12.5.8. SynchronousQueue实现" title="Direct link to 12.5.8. SynchronousQueue实现">​</a></h3><h1>13. 死锁</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="131-怎么打印线程堆栈信息">13.1. 怎么打印线程堆栈信息<a href="#131-怎么打印线程堆栈信息" class="hash-link" aria-label="Direct link to 13.1. 怎么打印线程堆栈信息" title="Direct link to 13.1. 怎么打印线程堆栈信息">​</a></h2><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，</p><h1>14. 并发相关的模式和算法</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="141-单例模式的最佳实现方式">14.1. 单例模式的最佳实现方式<a href="#141-单例模式的最佳实现方式" class="hash-link" aria-label="Direct link to 14.1. 单例模式的最佳实现方式" title="Direct link to 14.1. 单例模式的最佳实现方式">​</a></h2><p>对于使用频率高的对象, 可以节省new操作耗费的时间, 同时节省更多内存, GC 压力也减轻了</p><p>最简单的单例如下: 没有任何加锁操作, 并发下表现会很好; 但是实例不是 &quot;懒加载&quot; 的, 在类被装载的时候, 实例就会被创建</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Singleton {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Singleton() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Singleton is create&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Singleton instance = new Singleton();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Singleton getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>懒加载, 但是加了锁， 并发表现不好</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * LazySingleton</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class LazySingleton {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private LazySingleton() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Singleton is create&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static LazySingleton instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static synchronized LazySingleton getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (instance == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            instance = new LazySingleton();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>最好的方式：懒加载， 不加锁</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Singleton {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 类级内部类，用于缓存类实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 内部类的初始化方式保证了该类将在被调用时才会被装载，从而实现了延迟加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * instance 修饰为静态， 保证了只会实例化一次， 也就是单例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 同时由于instance采用静态初始化的方式，因此JVM能保证其线程安全性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class Instance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private static Singleton instance = new Singleton();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 从而达到单例模式控制类实例数目的目的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Singleton() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 类实例的全局访问方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return 单例类实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Singleton getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Instance.instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="142-不变模式">14.2. 不变模式<a href="#142-不变模式" class="hash-link" aria-label="Direct link to 14.2. 不变模式" title="Direct link to 14.2. 不变模式">​</a></h2><p>不变模式天生支持多线程 - 核心思路: 一个对象一旦被创建, 则他的内部状态/数据永远不会改变, so 没有一个 thread 可以修改这个对象的状态, 针对不变对象的多线程操作无需同步</p><p>什么是不变对象:</p><ul><li>去除掉 setter;</li><li>所有 field 私有</li><li>final 修饰 对象的 class, 确保不会被继承</li><li>有一个构造方法</li></ul><p>典型不变对象 -- String, Integer, Long</p><p>适用于：📌 创建后不再发生任何变化 📌 对象需要被共享， 多线程访问</p><p>一个典型的不变对象</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public final class Product {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String no;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String price;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Product(String no, String name, String price) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.no = no;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.price = price;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getNo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return no;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getPrice() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return price;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="143-生产者-消费者模式">14.3. 生产者-消费者模式<a href="#143-生产者-消费者模式" class="hash-link" aria-label="Direct link to 14.3. 生产者-消费者模式" title="Direct link to 14.3. 生产者-消费者模式">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1431-使用阻塞队列实现">14.3.1. 使用阻塞队列实现<a href="#1431-使用阻塞队列实现" class="hash-link" aria-label="Direct link to 14.3.1. 使用阻塞队列实现" title="Direct link to 14.3.1. 使用阻塞队列实现">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Data {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final int intDdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Data(int value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.intDdata = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @return the intDdata</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public int getIntDdata() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return intDdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public String toString() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return &quot;data:[intData=]&quot; + this.intDdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Consumer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Consumer implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private BlockingQueue&lt;Data&gt; queue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Consumer(BlockingQueue&lt;Data&gt; queue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.queue = queue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;start [consumer], id=&quot; + Thread.currentThread().getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Thread.currentThread().isInterrupted()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(&quot;stop [consumer], id=&quot; + Thread.currentThread().getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Data data = queue.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (null != data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          int re = data.getIntDdata() * data.getIntDdata();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          Thread.sleep(new Random().nextInt(1000));// simulate the time consumption</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.out.println(MessageFormat.format(&quot;{0} * {1} = {2}&quot;, data.getIntDdata, data.getIntDdata(), re));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Thread.currentThread().interrupt();// 中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/////////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Producer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Producer implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private volatile boolean running = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private BlockingQueue&lt;Data&gt; queue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private AtomicInteger count = new AtomicInteger(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Producer(BlockingQueue&lt;Data&gt; queue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.queue = queue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;start [producer], id=&quot; + Thread.currentThread().getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      while (running) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构造数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(new Random().nextInt(1000));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Data data = new Data(count.incrementAndGet());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean ok = queue.offer(data, 2, TimeUnit.SECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!ok) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          System.err.println(&quot;failed to put data, data: &quot; + data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void stop() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.running = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//////////////////////////////////</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Client</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LinkedBlockingQueue&lt;Data&gt; queue = new LinkedBlockingQueue&lt;Data&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Consumer consumer1 = new Consumer(queue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Consumer consumer2 = new Consumer(queue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Consumer consumer3 = new Consumer(queue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Producer producer1 = new Producer(queue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Producer producer2 = new Producer(queue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Producer producer3 = new Producer(queue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ExecutorService pool = new ThreadPoolExecutor(6, 6, 0L, TimeUnit.SECONDS, Executors.defaultThreadFactory());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pool.execute(producer1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pool.execute(producer2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pool.execute(producer3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pool.execute(consumer1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pool.execute(consumer2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pool.execute(consumer3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Thread.sleep(10*1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    producer1.stop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    producer2.stop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    producer3.stop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Thread.sleep(3*1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pool.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1432-无锁的实现">14.3.2. 无锁的实现<a href="#1432-无锁的实现" class="hash-link" aria-label="Direct link to 14.3.2. 无锁的实现" title="Direct link to 14.3.2. 无锁的实现">​</a></h3><p>BlockingQueue 不是高性能的实现， 完全使用锁来实现线程的同步</p><p>ConcurrentLinkedQueue 才是高性能的实现， 完全使用 无锁的方式(CAS操作) 来实现线程同步</p><p>disruptor框架 - 无锁方式的队列</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1433-使用等待通知机制实现">14.3.3. 使用等待通知机制实现<a href="#1433-使用等待通知机制实现" class="hash-link" aria-label="Direct link to 14.3.3. 使用等待通知机制实现" title="Direct link to 14.3.3. 使用等待通知机制实现">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">范式:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">producer:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">获取锁 { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(条件不满足) { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        对象.wait(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    对应的处理逻辑 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">consumer:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">获取锁 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    改变条件 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    对象.notifyAll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">https://www.jianshu.com/p/8ba98bea481e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="144-等待通知">14.4. 等待通知<a href="#144-等待通知" class="hash-link" aria-label="Direct link to 14.4. 等待通知" title="Direct link to 14.4. 等待通知">​</a></h2><p><a href="https://juejin.cn/post/6844904094532894727" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904094532894727</a>
<a href="https://blog.csdn.net/u011296165/article/details/89598025" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/u011296165/article/details/89598025</a></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="145-countdownlatch-cyclicbarrier">14.5. CountDownLatch CyclicBarrier<a href="#145-countdownlatch-cyclicbarrier" class="hash-link" aria-label="Direct link to 14.5. CountDownLatch CyclicBarrier" title="Direct link to 14.5. CountDownLatch CyclicBarrier">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="146-semaphore">14.6. Semaphore<a href="#146-semaphore" class="hash-link" aria-label="Direct link to 14.6. Semaphore" title="Direct link to 14.6. Semaphore">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="147-reentrantlock与condtion">14.7. ReentrantLock与Condtion<a href="#147-reentrantlock与condtion" class="hash-link" aria-label="Direct link to 14.7. ReentrantLock与Condtion" title="Direct link to 14.7. ReentrantLock与Condtion">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="148-future模式">14.8. Future模式<a href="#148-future模式" class="hash-link" aria-label="Direct link to 14.8. Future模式" title="Direct link to 14.8. Future模式">​</a></h2><p>futureTask CompletableFuture</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1481-典型future模式实现">14.8.1. 典型Future模式实现<a href="#1481-典型future模式实现" class="hash-link" aria-label="Direct link to 14.8.1. 典型Future模式实现" title="Direct link to 14.8.1. 典型Future模式实现">​</a></h3><p>核心思想是 - 异步调用</p><p>future模式流程图:</p><p>main() 方法调用耗时的子函数, 会立即返回一个 &quot;契约&quot;(相当于伪造的数据), 这时 main() 会接着往下执行, 未来当耗时的子函数执行完, main()才获得真正的结果</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 核心 interface - 表示希望获取的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Data {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getResult();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 真实数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class RealData implements Data {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected final String result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public RealData(String param) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //RealData的构造很慢,需要用户等待很久,这里用sleep模拟</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StringBuffer stringBuffer = new StringBuffer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            stringBuffer.append(param);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = stringBuffer.toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getResult() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 核心 伪造的数据 - 会立即返回给调用者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class FutureData implements Data {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected RealData realData = null; // 真实数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected boolean isReady = false; // 真实数据是否构造完毕</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void setRealData(RealData realData) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isReady) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.realData = realData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        isReady = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyAll(); // 唤醒所有等待的 thread</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized String getResult() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!isReady) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                wait(); // 如果 realData 还没有构造好, 线程等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return realData.result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 客户端</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Data request(final String queryStr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final FutureData futureData = new FutureData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {//RealData的构造很慢,所以在单独的线程中运行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                RealData realData = new RealData(queryStr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                futureData.setRealData(realData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return futureData; // 直接返回包装数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Client client = new Client();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //这里会立即返回,因为得到的是FutureData而不是RealData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Data data = client.request(&quot;name&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;请求完毕&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //这里用一个sleep代替了对其他业务逻辑的处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //在处理这些业务逻辑的过程中,RealData被创建,从而充分利用了等待时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(2000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //使用真实的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;数据=&quot; + data.getResult());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1482-jdk中的future模式">14.8.2. jdk中的future模式<a href="#1482-jdk中的future模式" class="hash-link" aria-label="Direct link to 14.8.2. jdk中的future模式" title="Direct link to 14.8.2. jdk中的future模式">​</a></h3><p>jdk内部提供了一套完整的实现</p><p>类结构图:</p><p>其他一些功能性api:</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Callable 接口 - 构造真实数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class RealData2 implements Callable&lt;String&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public RealData2(String data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.data = data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String call() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StringBuffer stringBuffer = new StringBuffer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            stringBuffer.append(data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(100);// 模拟耗时操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return stringBuffer.toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class FutureMain {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) throws ExecutionException, InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //构造FutureTask - 有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // new RealData2(&quot;a&quot;) 告诉了 FutureTask 真实数据如何产生</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new RealData2(&quot;a&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executorService = Executors.newFixedThreadPool(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //执行FutureTask,相当于前一个例子中的client.request(&quot;a&quot;)发送请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //在这里开启线程进行RealData的call()执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executorService.submit(futureTask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;请求完毕&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //这里依然可以做额外的数据操作,使用sleep代替其他业务逻辑的处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(2000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //相当于前一个例子中的data.getResult(),取得call()方法的返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //如果此时call()方法没有执行完成,则依然会等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;数据=&quot; + futureTask.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="149-map-reduce-模式">14.9. map-reduce 模式<a href="#149-map-reduce-模式" class="hash-link" aria-label="Direct link to 14.9. map-reduce 模式" title="Direct link to 14.9. map-reduce 模式">​</a></h2><p>把工作拆分成多份，多个线程共同完成后，再组合结果，Java8中的stream与Fork/Join就是这种模式的体现</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1410-worker-pool-模式">14.10. worker-pool 模式<a href="#1410-worker-pool-模式" class="hash-link" aria-label="Direct link to 14.10. worker-pool 模式" title="Direct link to 14.10. worker-pool 模式">​</a></h2><p>收到消息给不同的Thread进行处理</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1411-并行流水线">14.11. 并行流水线<a href="#1411-并行流水线" class="hash-link" aria-label="Direct link to 14.11. 并行流水线" title="Direct link to 14.11. 并行流水线">​</a></h2><p>并发算法适合分解各个子运算没有依赖的计算来利用多核优势</p><p>如果不幸碰到了相互依赖的子运算组成的计算, 可以使用 &quot;并行流水线&quot; 来利用多核优势 - 可以类比 cpu的流水线工作机制</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 定义一个在线程之间数据传递的载体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Msg {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public double i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public double j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String orgStr = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 加法 - 流水线中的一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Plus implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static BlockingDeque&lt;Msg&gt; blockingDeque = new LinkedBlockingDeque&lt;Msg&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Msg msg = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg = blockingDeque.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg.i = msg.j + msg.i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Multiply.blockingDeque.add(msg);// 传递给乘法线程中的queue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 乘法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Multiply implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static BlockingDeque&lt;Msg&gt; blockingDeque = new LinkedBlockingDeque&lt;Msg&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Msg msg = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg = blockingDeque.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg.i = msg.j * msg.i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Div.blockingDeque.add(msg);// 传递给 除法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 除法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Div implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static BlockingDeque&lt;Msg&gt; blockingDeque = new LinkedBlockingDeque&lt;Msg&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Msg msg = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg = blockingDeque.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg.i = msg.i / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(msg.orgStr + &quot;=&quot; + msg.i);// 输出最终结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class PStreamMain {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(new Plus()).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(new Multiply()).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(new Div()).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 提交 100 万个计算请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt;= 1000; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 0; j &lt;= 1000; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Msg msg = new Msg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg.i = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg.j = j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                msg.orgStr = &quot;((&quot; + i + &quot;+&quot; + j + &quot;)*&quot; + i + &quot;)/2&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Plus.blockingDeque.add(msg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1412-并行搜索">14.12. 并行搜索<a href="#1412-并行搜索" class="hash-link" aria-label="Direct link to 14.12. 并行搜索" title="Direct link to 14.12. 并行搜索">​</a></h2><p>有序 - 二分法
无需 - 挨个查找, 更好的方法: 并行</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int[] arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static ExecutorService pool = Executors.newCachedThreadPool();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int thread_num = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static AtomicInteger result = new AtomicInteger(-1);// 多个 thread 通过这个共享信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class SearchTask implements Callable&lt;Integer&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int begin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public SearchTask(int begin, int end, int target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.begin = begin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.end = end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.target = target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Integer call() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return search(target, begin, end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr = new int[] {2, 4, 5, 9, 11, 80, 294305, 777, 83};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int index = parallelSearch(777);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;search finished, index=&quot; + index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int parallelSearch(int target) throws InterruptedException, ExecutionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;Future&lt;Integer&gt;&gt; re = new ArrayList&lt;Future&lt;Integer&gt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int subArrSize = arr.length / (thread_num + 1);// 宁愿每个子数组size小一些, 数组个数多一些</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; arr.length; i += subArrSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int end = i + subArrSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (end &gt; arr.length) {// 可以去掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                end = arr.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            re.add(pool.submit(new SearchTask(i, end, target)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Future&lt;Integer&gt; fu : re) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Integer i = fu.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (i &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int search(int target, int begin, int end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (result.get() &gt;= 0) {// another thread should has finished the search</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return result.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = begin; i &lt; end; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (arr[i] == target) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                boolean ok = result.compareAndSet(-1, i);// get the index of target, and put it into result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (ok) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果设置失败, 表示其他线程抢先找到了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return result.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历完还是没找到, 返回 -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1413-并行排序">14.13. 并行排序<a href="#1413-并行排序" class="hash-link" aria-label="Direct link to 14.13. 并行排序" title="Direct link to 14.13. 并行排序">​</a></h2><p>一般的排序都是串行的, 这里介绍并行的排序算法</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="14131-改进冒泡排序-分离数据相关性-奇偶交换排序">14.13.1. 改进冒泡排序-分离数据相关性-奇偶交换排序<a href="#14131-改进冒泡排序-分离数据相关性-奇偶交换排序" class="hash-link" aria-label="Direct link to 14.13.1. 改进冒泡排序-分离数据相关性-奇偶交换排序" title="Direct link to 14.13.1. 改进冒泡排序-分离数据相关性-奇偶交换排序">​</a></h3><p>对于冒泡排序中的某个元素, 它可能和前一个元素交换, 也可能同后一个元素交换, 整个过程是一个相互依赖的整体, 怎么分离成多个部分呢?</p><p>奇偶交换排序 - 将整个排序过程分为两部分: 奇交换 - 只比较奇数索引的元素和相邻的下一个元素; 偶交换 - 只比较偶数索引的元素及其相邻的下一个元素</p><p>奇偶排序示意图: from <a href="https://blog.csdn.net/lemon_tree12138/article/details/50605563" target="_blank" rel="noopener noreferrer">here</a></p><p>将整个比较分割为 独立的 奇阶段, 偶阶段. 在每个阶段内, 所有的比较交换没有相互依赖, so 每次比较都可以独立执行</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int[] arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr = new int[] { 763, 203, 2, 32, 8, 99, 455, 777, 343, 234 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bubbleSort(arr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i : arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.print(i+&quot;, &quot;);//2, 8, 32, 99, 203, 234, 343, 455, 763, 777,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //普通的冒泡排序:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void bubbleSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = arr.length - 1; i &gt; 0; i--) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 0; j &lt; i; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (arr[j] &gt; arr[j + 1]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int tmp = arr[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    arr[j] = arr[j + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    arr[j + 1] = tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 串行的奇偶冒泡排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void oddEvenSort(int[] arr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean exch = true;// 本次循环是否进行了数据交换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int startIndex = 0;// 1: 奇交换, 0: 偶交换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (exch || startIndex == 1) {// 如果上一次循环发生了交换 or 奇交换, 重复循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    // 当没有元素交换, 且当前进行的是偶交换 - 退出循环</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            exch = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int i = startIndex; i &lt; arr.length - 1; i += 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (arr[i] &gt; arr[i+1]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int tmp = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    arr[i] = arr[i+1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    arr[i+1] = tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    exch = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (startIndex == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                startIndex = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                startIndex = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="14132-改进插入排序-希尔排序">14.13.2. 改进插入排序-希尔排序<a href="#14132-改进插入排序-希尔排序" class="hash-link" aria-label="Direct link to 14.13.2. 改进插入排序-希尔排序" title="Direct link to 14.13.2. 改进插入排序-希尔排序">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1414-网络nio">14.14. 网络nio<a href="#1414-网络nio" class="hash-link" aria-label="Direct link to 14.14. 网络nio" title="Direct link to 14.14. 网络nio">​</a></h2><h1>15. 使用 akka 构建高并发程序</h1><h1>16. 并行程序怎么调试</h1></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/en/docs/tags/java">java</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/en/docs/tags/concurrent">concurrent</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/xiaoyureed/xiaoyureed.github.io/tree/main/docs/java-concurrent.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/en/docs/java-code-clean"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Java Clean Code Tips</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/en/docs/java-memory-model-jmm-jvm"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">JMM and GC🌈</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#61-原子性atomicity" class="table-of-contents__link toc-highlight">6.1. 原子性(atomicity)</a></li><li><a href="#62-可见性-缓存一致性" class="table-of-contents__link toc-highlight">6.2. 可见性-缓存一致性</a></li><li><a href="#63-有序性-指令重排" class="table-of-contents__link toc-highlight">6.3. 有序性-指令重排</a></li><li><a href="#81-线程和进程" class="table-of-contents__link toc-highlight">8.1. 线程和进程</a><ul><li><a href="#811-两者的概念" class="table-of-contents__link toc-highlight">8.1.1. 两者的概念</a></li><li><a href="#812-线程实现原理" class="table-of-contents__link toc-highlight">8.1.2. 线程实现原理</a></li><li><a href="#813-线程的调度方式" class="table-of-contents__link toc-highlight">8.1.3. 线程的调度方式</a></li><li><a href="#814-线程的几个状态" class="table-of-contents__link toc-highlight">8.1.4. 线程的几个状态</a></li></ul></li><li><a href="#82-thread基本api" class="table-of-contents__link toc-highlight">8.2. thread基本api</a><ul><li><a href="#821-创建" class="table-of-contents__link toc-highlight">8.2.1. 创建</a></li><li><a href="#822-终止" class="table-of-contents__link toc-highlight">8.2.2. 终止</a></li><li><a href="#823-中断-interruptedexception-处理" class="table-of-contents__link toc-highlight">8.2.3. 中断 InterruptedException 处理</a></li><li><a href="#824-等待和通知-wait-notify" class="table-of-contents__link toc-highlight">8.2.4. 等待和通知-wait-notify</a></li><li><a href="#825-等待结束和谦让-join-yield" class="table-of-contents__link toc-highlight">8.2.5. 等待结束和谦让-join-yield</a></li><li><a href="#826-线程组" class="table-of-contents__link toc-highlight">8.2.6. 线程组</a></li><li><a href="#827-守护线程-daemon" class="table-of-contents__link toc-highlight">8.2.7. 守护线程-daemon</a></li><li><a href="#828-线程优先级" class="table-of-contents__link toc-highlight">8.2.8. 线程优先级</a></li></ul></li><li><a href="#83-相关的关键字" class="table-of-contents__link toc-highlight">8.3. 相关的关键字</a><ul><li><a href="#831-volatile" class="table-of-contents__link toc-highlight">8.3.1. volatile</a></li><li><a href="#832-synchronized" class="table-of-contents__link toc-highlight">8.3.2. synchronized</a></li></ul></li><li><a href="#91-先看一个隐蔽错误的例子-int型溢出" class="table-of-contents__link toc-highlight">9.1. 先看一个隐蔽错误的例子-int型溢出</a></li><li><a href="#92-并发下的arraylist" class="table-of-contents__link toc-highlight">9.2. 并发下的ArrayList</a></li><li><a href="#93-并发下的hashmap" class="table-of-contents__link toc-highlight">9.3. 并发下的Hashmap</a></li><li><a href="#94-错误的使用锁" class="table-of-contents__link toc-highlight">9.4. 错误的使用锁</a></li><li><a href="#101-怎么进行同步控制" class="table-of-contents__link toc-highlight">10.1. 怎么进行同步控制</a><ul><li><a href="#1011-重入锁-锁的公平性" class="table-of-contents__link toc-highlight">10.1.1. 重入锁-锁的公平性</a></li><li><a href="#1012-condition-重入锁好搭档" class="table-of-contents__link toc-highlight">10.1.2. Condition-重入锁好搭档</a></li><li><a href="#1013-semaphore-信号量-多个线程同时访问" class="table-of-contents__link toc-highlight">10.1.3. semaphore-信号量-多个线程同时访问</a></li><li><a href="#1014-readwritelock-读写锁" class="table-of-contents__link toc-highlight">10.1.4. ReadWriteLock-读写锁</a></li><li><a href="#1015-countdownlatch-倒计时器" class="table-of-contents__link toc-highlight">10.1.5. CountDownLatch-倒计时器</a></li><li><a href="#1016-cyclicbarrier-循环栅栏" class="table-of-contents__link toc-highlight">10.1.6. CyclicBarrier-循环栅栏</a></li><li><a href="#1017-locksupport-线程阻塞工具类" class="table-of-contents__link toc-highlight">10.1.7. LockSupport-线程阻塞工具类</a></li></ul></li><li><a href="#102-线程复用-线程池" class="table-of-contents__link toc-highlight">10.2. 线程复用-线程池</a><ul><li><a href="#1021-executor的api" class="table-of-contents__link toc-highlight">10.2.1. Executor的api</a><ul><li><a href="#10211-创建线程池" class="table-of-contents__link toc-highlight">10.2.1.1. 创建线程池</a></li><li><a href="#10212-怎么确定池子的容量" class="table-of-contents__link toc-highlight">10.2.1.2. 怎么确定池子的容量</a></li><li><a href="#10213-线程池的几个状态" class="table-of-contents__link toc-highlight">10.2.1.3. 线程池的几个状态</a></li><li><a href="#10214-关闭线程池" class="table-of-contents__link toc-highlight">10.2.1.4. 关闭线程池</a></li></ul></li><li><a href="#1022-threadpoolexecutor-自定义线程池" class="table-of-contents__link toc-highlight">10.2.2. ThreadPoolExecutor-自定义线程池</a><ul><li><a href="#10221-核心-api" class="table-of-contents__link toc-highlight">10.2.2.1. 核心 api</a></li><li><a href="#10222-阻塞队列-blockingqueue" class="table-of-contents__link toc-highlight">10.2.2.2. 阻塞队列 BlockingQueue</a></li><li><a href="#10223-自定义拒绝策略" class="table-of-contents__link toc-highlight">10.2.2.3. 自定义拒绝策略</a></li><li><a href="#10224-自定义线程池名称" class="table-of-contents__link toc-highlight">10.2.2.4. 自定义线程池名称</a></li><li><a href="#10225-自定义线程-名称" class="table-of-contents__link toc-highlight">10.2.2.5. 自定义线程 名称</a></li></ul></li><li><a href="#1023-无锁安全的队列" class="table-of-contents__link toc-highlight">10.2.3. 无锁安全的队列</a></li><li><a href="#1024-拓展线程池-在线程池中寻找堆栈" class="table-of-contents__link toc-highlight">10.2.4. 拓展线程池-在线程池中寻找堆栈</a></li><li><a href="#1025-fork-join框架" class="table-of-contents__link toc-highlight">10.2.5. Fork-Join框架</a></li><li><a href="#1026-springboot中使用线程池" class="table-of-contents__link toc-highlight">10.2.6. springboot中使用线程池</a></li><li><a href="#1027-hystrix-线程池隔离" class="table-of-contents__link toc-highlight">10.2.7. hystrix-线程池隔离</a></li></ul></li><li><a href="#103-jdk中的并发容器" class="table-of-contents__link toc-highlight">10.3. jdk中的并发容器</a><ul><li><a href="#1031-整体介绍" class="table-of-contents__link toc-highlight">10.3.1. 整体介绍</a></li><li><a href="#1032-concurrentlinkedqueue原理" class="table-of-contents__link toc-highlight">10.3.2. ConcurrentLinkedQueue原理</a></li><li><a href="#1033-开源高性能内存队列-disruptor" class="table-of-contents__link toc-highlight">10.3.3. 开源高性能内存队列 disruptor</a></li></ul></li><li><a href="#104-aqs-无锁实现" class="table-of-contents__link toc-highlight">10.4. aqs 无锁实现</a></li><li><a href="#121-提高锁性能的原则" class="table-of-contents__link toc-highlight">12.1. 提高锁性能的原则</a><ul><li><a href="#1211-减少锁持有时间-和锁粗化-需要权衡" class="table-of-contents__link toc-highlight">12.1.1. 减少锁持有时间-和锁粗化-需要权衡</a></li><li><a href="#1212-减小锁粒度" class="table-of-contents__link toc-highlight">12.1.2. 减小锁粒度</a></li><li><a href="#1213-读写分离锁代替独占锁" class="table-of-contents__link toc-highlight">12.1.3. 读写分离锁代替独占锁</a></li><li><a href="#1214-锁分离" class="table-of-contents__link toc-highlight">12.1.4. 锁分离</a></li></ul></li><li><a href="#122-jvm是怎么对锁优化的" class="table-of-contents__link toc-highlight">12.2. jvm是怎么对锁优化的</a><ul><li><a href="#1221-使锁进入偏向模式-偏向锁" class="table-of-contents__link toc-highlight">12.2.1. 使锁进入偏向模式-偏向锁</a></li><li><a href="#1222-使用轻量级锁" class="table-of-contents__link toc-highlight">12.2.2. 使用轻量级锁</a></li><li><a href="#1223-自旋锁" class="table-of-contents__link toc-highlight">12.2.3. 自旋锁</a></li><li><a href="#1224-锁消除" class="table-of-contents__link toc-highlight">12.2.4. 锁消除</a></li></ul></li><li><a href="#123-threadlocal" class="table-of-contents__link toc-highlight">12.3. ThreadLocal</a><ul><li><a href="#1231-threadlocal概念" class="table-of-contents__link toc-highlight">12.3.1. threadlocal概念</a></li><li><a href="#1232-threadlocal-示例" class="table-of-contents__link toc-highlight">12.3.2. threadLocal 示例</a></li><li><a href="#1233-再看一个问题例子以及改进" class="table-of-contents__link toc-highlight">12.3.3. 再看一个问题例子以及改进</a></li><li><a href="#1234-原理" class="table-of-contents__link toc-highlight">12.3.4. 原理</a></li><li><a href="#1235-看源码" class="table-of-contents__link toc-highlight">12.3.5. 看源码</a></li></ul></li><li><a href="#124-weakreference" class="table-of-contents__link toc-highlight">12.4. weakReference</a><ul><li><a href="#1241-什么是weakreference" class="table-of-contents__link toc-highlight">12.4.1. 什么是WeakReference</a></li><li><a href="#1242-为什使用" class="table-of-contents__link toc-highlight">12.4.2. 为什使用</a></li><li><a href="#1243-怎么使用" class="table-of-contents__link toc-highlight">12.4.3. 怎么使用</a></li><li><a href="#1244-四种引用" class="table-of-contents__link toc-highlight">12.4.4. 四种引用</a></li><li><a href="#1245-referencequeue" class="table-of-contents__link toc-highlight">12.4.5. ReferenceQueue</a></li><li><a href="#1246-weakhashmap--treadlocalmap" class="table-of-contents__link toc-highlight">12.4.6. WeakHashMap &amp; TreadLocalMap</a></li></ul></li><li><a href="#125-不加锁-乐观锁" class="table-of-contents__link toc-highlight">12.5. 不加锁-乐观锁</a><ul><li><a href="#1251-怎么理解不加锁的策略" class="table-of-contents__link toc-highlight">12.5.1. 怎么理解不加锁的策略</a></li><li><a href="#1252-atomicinteger-无锁安全整数" class="table-of-contents__link toc-highlight">12.5.2. AtomicInteger-无锁安全整数</a></li><li><a href="#1253-unsafe类-java中的指针" class="table-of-contents__link toc-highlight">12.5.3. Unsafe类-Java中的指针</a></li><li><a href="#1254-atomicreference-无锁的对象引用" class="table-of-contents__link toc-highlight">12.5.4. AtomicReference-无锁的对象引用</a></li><li><a href="#1255-atomicstampedreference-带时间戳的引用" class="table-of-contents__link toc-highlight">12.5.5. AtomicStampedReference-带时间戳的引用</a></li><li><a href="#1256-atomicintegerarray-无锁的数组" class="table-of-contents__link toc-highlight">12.5.6. AtomicIntegerArray-无锁的数组</a></li><li><a href="#1257-atomicintegerfieldupdater-升级普通变量支持原子操作" class="table-of-contents__link toc-highlight">12.5.7. AtomicIntegerFieldUpdater-升级普通变量支持原子操作</a></li><li><a href="#1258-synchronousqueue实现" class="table-of-contents__link toc-highlight">12.5.8. SynchronousQueue实现</a></li></ul></li><li><a href="#131-怎么打印线程堆栈信息" class="table-of-contents__link toc-highlight">13.1. 怎么打印线程堆栈信息</a></li><li><a href="#141-单例模式的最佳实现方式" class="table-of-contents__link toc-highlight">14.1. 单例模式的最佳实现方式</a></li><li><a href="#142-不变模式" class="table-of-contents__link toc-highlight">14.2. 不变模式</a></li><li><a href="#143-生产者-消费者模式" class="table-of-contents__link toc-highlight">14.3. 生产者-消费者模式</a><ul><li><a href="#1431-使用阻塞队列实现" class="table-of-contents__link toc-highlight">14.3.1. 使用阻塞队列实现</a></li><li><a href="#1432-无锁的实现" class="table-of-contents__link toc-highlight">14.3.2. 无锁的实现</a></li><li><a href="#1433-使用等待通知机制实现" class="table-of-contents__link toc-highlight">14.3.3. 使用等待通知机制实现</a></li></ul></li><li><a href="#144-等待通知" class="table-of-contents__link toc-highlight">14.4. 等待通知</a></li><li><a href="#145-countdownlatch-cyclicbarrier" class="table-of-contents__link toc-highlight">14.5. CountDownLatch CyclicBarrier</a></li><li><a href="#146-semaphore" class="table-of-contents__link toc-highlight">14.6. Semaphore</a></li><li><a href="#147-reentrantlock与condtion" class="table-of-contents__link toc-highlight">14.7. ReentrantLock与Condtion</a></li><li><a href="#148-future模式" class="table-of-contents__link toc-highlight">14.8. Future模式</a><ul><li><a href="#1481-典型future模式实现" class="table-of-contents__link toc-highlight">14.8.1. 典型Future模式实现</a></li><li><a href="#1482-jdk中的future模式" class="table-of-contents__link toc-highlight">14.8.2. jdk中的future模式</a></li></ul></li><li><a href="#149-map-reduce-模式" class="table-of-contents__link toc-highlight">14.9. map-reduce 模式</a></li><li><a href="#1410-worker-pool-模式" class="table-of-contents__link toc-highlight">14.10. worker-pool 模式</a></li><li><a href="#1411-并行流水线" class="table-of-contents__link toc-highlight">14.11. 并行流水线</a></li><li><a href="#1412-并行搜索" class="table-of-contents__link toc-highlight">14.12. 并行搜索</a></li><li><a href="#1413-并行排序" class="table-of-contents__link toc-highlight">14.13. 并行排序</a><ul><li><a href="#14131-改进冒泡排序-分离数据相关性-奇偶交换排序" class="table-of-contents__link toc-highlight">14.13.1. 改进冒泡排序-分离数据相关性-奇偶交换排序</a></li><li><a href="#14132-改进插入排序-希尔排序" class="table-of-contents__link toc-highlight">14.13.2. 改进插入排序-希尔排序</a></li></ul></li><li><a href="#1414-网络nio" class="table-of-contents__link toc-highlight">14.14. 网络nio</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/en/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/en/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/en/assets/js/runtime~main.b94328d8.js"></script>
<script src="/en/assets/js/main.fc98d8e0.js"></script>
</body>
</html>